<html>
<head>
<title>Multiset.thy</title>
<style type="text/css"><!--

.syntax-NULL {
  color: #000000;
}
.syntax-COMMENT1 {
  color: #cc0000;
}
.syntax-COMMENT2 {
  color: #ff8400;
}
.syntax-COMMENT3 {
  color: #6600cc;
}
.syntax-COMMENT4 {
  color: #cc6600;
}
.syntax-DIGIT {
  color: #ff0000;
}
.syntax-FUNCTION {
  color: #9966ff;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
}
.syntax-KEYWORD1 {
  color: #006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #02b902;
}
.syntax-LITERAL1 {
  color: #ff00cc;
}
.syntax-LITERAL2 {
  color: #cc00cc;
}
.syntax-LITERAL3 {
  color: #9900cc;
}
.syntax-LITERAL4 {
  color: #6600cc;
}
.syntax-MARKUP {
  color: #0000ff;
}
.syntax-OPERATOR {
  color: #000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #000000;
}
.syntax-COMMENT1 {
  color: #cc0000;
}
.syntax-COMMENT2 {
  color: #ff8400;
}
.syntax-COMMENT3 {
  color: #6600cc;
}
.syntax-COMMENT4 {
  color: #cc6600;
}
.syntax-DIGIT {
  color: #ff0000;
}
.syntax-FUNCTION {
  color: #9966ff;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
}
.syntax-KEYWORD1 {
  color: #006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #02b902;
}
.syntax-LITERAL1 {
  color: #ff00cc;
}
.syntax-LITERAL2 {
  color: #cc00cc;
}
.syntax-LITERAL3 {
  color: #9900cc;
}
.syntax-LITERAL4 {
  color: #6600cc;
}
.syntax-MARKUP {
  color: #0000ff;
}
.syntax-OPERATOR {
  color: #000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #000000;
}
.syntax-COMMENT1 {
  color: #cc0000;
}
.syntax-COMMENT2 {
  color: #ff8400;
}
.syntax-COMMENT3 {
  color: #6600cc;
}
.syntax-COMMENT4 {
  color: #cc6600;
}
.syntax-DIGIT {
  color: #ff0000;
}
.syntax-FUNCTION {
  color: #9966ff;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
}
.syntax-KEYWORD1 {
  color: #006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #02b902;
}
.syntax-LITERAL1 {
  color: #ff00cc;
}
.syntax-LITERAL2 {
  color: #cc00cc;
}
.syntax-LITERAL3 {
  color: #9900cc;
}
.syntax-LITERAL4 {
  color: #6600cc;
}
.syntax-MARKUP {
  color: #0000ff;
}
.syntax-OPERATOR {
  color: #000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #000000;
  font-weight: bold;
}
.syntax-COMMENT1 {
  color: #cc0000;
  font-weight: bold;
}
.syntax-COMMENT2 {
  color: #ff8400;
  font-weight: bold;
}
.syntax-COMMENT3 {
  color: #6600cc;
  font-weight: bold;
}
.syntax-COMMENT4 {
  color: #cc6600;
  font-weight: bold;
}
.syntax-DIGIT {
  color: #ff0000;
  font-weight: bold;
}
.syntax-FUNCTION {
  color: #9966ff;
  font-weight: bold;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
  font-weight: bold;
}
.syntax-KEYWORD1 {
  color: #006699;
}
.syntax-KEYWORD2 {
  color: #009966;
}
.syntax-KEYWORD3 {
  color: #0099ff;
}
.syntax-KEYWORD4 {
  color: #66ccff;
}
.syntax-LABEL {
  color: #02b902;
  font-weight: bold;
}
.syntax-LITERAL1 {
  color: #ff00cc;
  font-weight: bold;
}
.syntax-LITERAL2 {
  color: #cc00cc;
  font-weight: bold;
}
.syntax-LITERAL3 {
  color: #9900cc;
  font-weight: bold;
}
.syntax-LITERAL4 {
  color: #6600cc;
  font-weight: bold;
}
.syntax-MARKUP {
  color: #0000ff;
  font-weight: bold;
}
.syntax-OPERATOR {
  color: #000000;
}
.syntax-NULL {
  color: #000000;
}
.syntax-COMMENT1 {
  color: #cc0000;
}
.syntax-COMMENT2 {
  color: #ff8400;
}
.syntax-COMMENT3 {
  color: #6600cc;
}
.syntax-COMMENT4 {
  color: #cc6600;
}
.syntax-DIGIT {
  color: #ff0000;
}
.syntax-FUNCTION {
  color: #9966ff;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
}
.syntax-KEYWORD1 {
  color: #006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #02b902;
}
.syntax-LITERAL1 {
  color: #ff00cc;
}
.syntax-LITERAL2 {
  color: #cc00cc;
}
.syntax-LITERAL3 {
  color: #9900cc;
}
.syntax-LITERAL4 {
  color: #6600cc;
}
.syntax-MARKUP {
  color: #0000ff;
}
.syntax-OPERATOR {
  color: #000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #000000;
}
.syntax-COMMENT1 {
  color: #cc0000;
}
.syntax-COMMENT2 {
  color: #ff8400;
}
.syntax-COMMENT3 {
  color: #6600cc;
}
.syntax-COMMENT4 {
  color: #cc6600;
}
.syntax-DIGIT {
  color: #ff0000;
}
.syntax-FUNCTION {
  color: #9966ff;
}
.syntax-INVALID {
  background: #ffffcc;
  color: #ff0066;
}
.syntax-KEYWORD1 {
  color: #006699;
  font-weight: bold;
}
.syntax-KEYWORD2 {
  color: #009966;
  font-weight: bold;
}
.syntax-KEYWORD3 {
  color: #0099ff;
  font-weight: bold;
}
.syntax-KEYWORD4 {
  color: #66ccff;
  font-weight: bold;
}
.syntax-LABEL {
  color: #02b902;
}
.syntax-LITERAL1 {
  color: #ff00cc;
}
.syntax-LITERAL2 {
  color: #cc00cc;
}
.syntax-LITERAL3 {
  color: #9900cc;
}
.syntax-LITERAL4 {
  color: #6600cc;
}
.syntax-MARKUP {
  color: #0000ff;
}
.syntax-OPERATOR {
  color: #000000;
  font-weight: bold;
}
.syntax-NULL {
  color: #ffffff;
}

.gutter {
  background: #dbdbdb;
  color: #000000;
  border-right: 2px solid black ;
  margin-right: 5px ;
}
.gutterH {
  background: #dbdbdb;
  color: #990066;
  border-right: 2px solid black ; 
  margin-right: 5px ;
}

--></style>
</head>
<body bgcolor="#ffffff">
<pre><span class="syntax0"><span class="gutter">   1 </span><span class="syntax-COMMENT1">(*  Title:      HOL/Library/Multiset.thy</span>
<span class="gutter">   2 </span><span class="syntax-COMMENT1">    Author:     Tobias Nipkow, Markus Wenzel, Lawrence C Paulson, Norbert Voelker</span>
<span class="gutter">   3 </span><span class="syntax-COMMENT1">    Author:     Andrei Popescu, TU Muenchen</span>
<span class="gutter">   4 </span><span class="syntax-COMMENT1">    Author:     Jasmin Blanchette, Inria, LORIA, MPII</span>
<span class="gutterH">   5 </span><span class="syntax-COMMENT1">    Author:     Dmitriy Traytel, TU Muenchen</span>
<span class="gutter">   6 </span><span class="syntax-COMMENT1">    Author:     Mathias Fleury, MPII</span>
<span class="gutter">   7 </span><span class="syntax-COMMENT1">*)</span>
<span class="gutter">   8 </span>
<span class="gutter">   9 </span><span class="syntax-KEYWORD1">section</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">  10 </span>
<span class="gutter">  11 </span><span class="syntax-KEYWORD1">theory</span> Multiset
<span class="gutter">  12 </span><span class="syntax-KEYWORD2">imports</span> Main
<span class="gutter">  13 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">  14 </span>
<span class="gutterH">  15 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">  16 </span>
<span class="gutter">  17 </span><span class="syntax-KEYWORD1">definition</span> <span class="syntax-LITERAL1">&quot;multiset = {f :: 'a &rArr; nat. finite {x. f x &gt; 0}}&quot;</span>
<span class="gutter">  18 </span>
<span class="gutter">  19 </span><span class="syntax-KEYWORD1">typedef</span> 'a multiset <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;multiset :: ('a &rArr; nat) set&quot;</span>
<span class="gutterH">  20 </span>  <span class="syntax-KEYWORD2">morphisms</span> count Abs_multiset
<span class="gutter">  21 </span>  <span class="syntax-KEYWORD1">unfolding</span> multiset_def
<span class="gutter">  22 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">  23 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;(&lambda;x. 0::nat) &isin; {f. finite {x. f x &gt; 0}}&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">  24 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">  25 </span>
<span class="gutter">  26 </span><span class="syntax-KEYWORD1">setup_lifting</span> type_definition_multiset
<span class="gutter">  27 </span>
<span class="gutter">  28 </span><span class="syntax-KEYWORD1">lemma</span> multiset_eq_iff<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = N &#10231; (&forall;a. count M a = count N a)&quot;</span>
<span class="gutter">  29 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> count_inject <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">  30 </span>
<span class="gutter">  31 </span><span class="syntax-KEYWORD1">lemma</span> multiset_eqI<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(&#8896;x. count A x = count B x) &#10233; A = B&quot;</span>
<span class="gutter">  32 </span>  <span class="syntax-KEYWORD1">using</span> multiset_eq_iff <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">  33 </span>
<span class="gutter">  34 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">@</span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">  35 </span>
<span class="gutter">  36 </span><span class="syntax-KEYWORD1">lemma</span> const0_in_multiset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(&lambda;a. 0) &isin; multiset&quot;</span>
<span class="gutter">  37 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">  38 </span>
<span class="gutter">  39 </span><span class="syntax-KEYWORD1">lemma</span> only1_in_multiset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(&lambda;b. if b = a then n else 0) &isin; multiset&quot;</span>
<span class="gutterH">  40 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">  41 </span>
<span class="gutter">  42 </span><span class="syntax-KEYWORD1">lemma</span> union_preserves_multiset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M &isin; multiset &#10233; N &isin; multiset &#10233; (&lambda;a. M a + N a) &isin; multiset&quot;</span>
<span class="gutter">  43 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">  44 </span>
<span class="gutterH">  45 </span><span class="syntax-KEYWORD1">lemma</span> diff_preserves_multiset<span class="syntax-OPERATOR">:</span>
<span class="gutter">  46 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;M &isin; multiset&quot;</span>
<span class="gutter">  47 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(&lambda;a. M a - N a) &isin; multiset&quot;</span>
<span class="gutter">  48 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">  49 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{x. N x &lt; M x} &sube; {x. 0 &lt; M x}&quot;</span>
<span class="gutterH">  50 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">  51 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">  52 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_def intro<span class="syntax-OPERATOR">:</span> finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutter">  53 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">  54 </span>
<span class="gutterH">  55 </span><span class="syntax-KEYWORD1">lemma</span> filter_preserves_multiset<span class="syntax-OPERATOR">:</span>
<span class="gutter">  56 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;M &isin; multiset&quot;</span>
<span class="gutter">  57 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(&lambda;x. if P x then M x else 0) &isin; multiset&quot;</span>
<span class="gutter">  58 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">  59 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{x. (P x &#10230; 0 &lt; M x) &and; P x} &sube; {x. 0 &lt; M x}&quot;</span>
<span class="gutterH">  60 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">  61 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">  62 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_def intro<span class="syntax-OPERATOR">:</span> finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutter">  63 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">  64 </span>
<span class="gutterH">  65 </span><span class="syntax-KEYWORD1">lemmas</span> in_multiset <span class="syntax-OPERATOR">=</span> const0_in_multiset only1_in_multiset
<span class="gutter">  66 </span>  union_preserves_multiset diff_preserves_multiset filter_preserves_multiset
<span class="gutter">  67 </span>
<span class="gutter">  68 </span>
<span class="gutter">  69 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">R</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">  70 </span>
<span class="gutter">  71 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">  72 </span>
<span class="gutter">  73 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>type<span class="syntax-OPERATOR">)</span> cancel_comm_monoid_add
<span class="gutter">  74 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutterH">  75 </span>
<span class="gutter">  76 </span><span class="syntax-KEYWORD1">lift_definition</span> zero_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;&lambda;a. 0&quot;</span>
<span class="gutter">  77 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule const0_in_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter">  78 </span>
<span class="gutter">  79 </span><span class="syntax-KEYWORD1">abbreviation</span> Mempty <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;{#}&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutterH">  80 </span>  <span class="syntax-LITERAL1">&quot;Mempty &equiv; 0&quot;</span>
<span class="gutter">  81 </span>
<span class="gutter">  82 </span><span class="syntax-KEYWORD1">lift_definition</span> plus_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;&lambda;M N. (&lambda;a. M a + N a)&quot;</span>
<span class="gutter">  83 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule union_preserves_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter">  84 </span>
<span class="gutterH">  85 </span><span class="syntax-KEYWORD1">lift_definition</span> minus_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;&lambda; M N. &lambda;a. M a - N a&quot;</span>
<span class="gutter">  86 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule diff_preserves_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter">  87 </span>
<span class="gutter">  88 </span><span class="syntax-KEYWORD1">instance</span>
<span class="gutter">  89 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>standard<span class="syntax-OPERATOR">;</span> transfer<span class="syntax-OPERATOR">;</span> simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">  90 </span>
<span class="gutter">  91 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">  92 </span>
<span class="gutter">  93 </span><span class="syntax-KEYWORD1">context</span>
<span class="gutter">  94 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutterH">  95 </span>
<span class="gutter">  96 </span><span class="syntax-KEYWORD2">qualified</span> <span class="syntax-KEYWORD1">definition</span> is_empty <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">  97 </span>  <span class="syntax-OPERATOR">[</span>code_abbrev<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;is_empty A &#10231; A = {#}&quot;</span>
<span class="gutter">  98 </span>
<span class="gutter">  99 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutterH"> 100 </span>
<span class="gutter"> 101 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_in_multiset<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 102 </span>  <span class="syntax-KEYWORD2">assumes</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 103 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">&lambda;</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 104 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def insert_Collect<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 105 </span>
<span class="gutter"> 106 </span><span class="syntax-KEYWORD1">lift_definition</span> add_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'a multiset &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">is</span>
<span class="gutter"> 107 </span>  <span class="syntax-LITERAL1">&quot;&lambda;a M b. if b = a then Suc (M b) else M b&quot;</span>
<span class="gutter"> 108 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule add_mset_in_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 109 </span>
<span class="gutterH"> 110 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutter"> 111 </span>  <span class="syntax-LITERAL1">&quot;_multiset&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;args &rArr; 'a multiset&quot;</span>    <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;{#(_)#}&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 112 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter"> 113 </span>  <span class="syntax-LITERAL1">&quot;{#x, xs#}&quot;</span> <span class="syntax-OPERATOR">==</span> <span class="syntax-LITERAL1">&quot;CONST add_mset x {#xs#}&quot;</span>
<span class="gutter"> 114 </span>  <span class="syntax-LITERAL1">&quot;{#x#}&quot;</span> <span class="syntax-OPERATOR">==</span> <span class="syntax-LITERAL1">&quot;CONST add_mset x {#}&quot;</span>
<span class="gutterH"> 115 </span>
<span class="gutter"> 116 </span><span class="syntax-KEYWORD1">lemma</span> count_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count {#} a = 0&quot;</span>
<span class="gutter"> 117 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> zero_multiset.rep_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 118 </span>
<span class="gutter"> 119 </span><span class="syntax-KEYWORD1">lemma</span> count_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 120 </span>  <span class="syntax-LITERAL1">&quot;count (add_mset b A) a = (if b = a then Suc (count A a) else count A a)&quot;</span>
<span class="gutter"> 121 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> add_mset.rep_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 122 </span>
<span class="gutter"> 123 </span><span class="syntax-KEYWORD1">lemma</span> count_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count {#b#} a = (if b = a then 1 else 0)&quot;</span>
<span class="gutter"> 124 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 125 </span>
<span class="gutter"> 126 </span><span class="syntax-KEYWORD1">lemma</span>
<span class="gutter"> 127 </span>  add_mset_not_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&ne;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 128 </span>  empty_not_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} &ne; add_mset a A&quot;</span>
<span class="gutter"> 129 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 130 </span>
<span class="gutter"> 131 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_add_mset_same_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 132 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A = add_mset a B &#10231; A = B&quot;</span>
<span class="gutter"> 133 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 134 </span>
<span class="gutterH"> 135 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_commute<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 136 </span>  <span class="syntax-LITERAL1">&quot;add_mset x (add_mset y M) = add_mset y (add_mset x M)&quot;</span>
<span class="gutter"> 137 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 138 </span>
<span class="gutter"> 139 </span>
<span class="gutterH"> 140 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 141 </span>
<span class="gutter"> 142 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">C</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 143 </span>
<span class="gutter"> 144 </span><span class="syntax-KEYWORD1">definition</span> set_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a set&quot;</span>
<span class="gutterH"> 145 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;set_mset M = {x. count M x &gt; 0}&quot;</span>
<span class="gutter"> 146 </span>
<span class="gutter"> 147 </span><span class="syntax-KEYWORD1">abbreviation</span> Melem <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'a multiset &rArr; bool&quot;</span>
<span class="gutter"> 148 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;Melem a M &equiv; a &isin; set_mset M&quot;</span>
<span class="gutter"> 149 </span>
<span class="gutterH"> 150 </span><span class="syntax-KEYWORD1">notation</span>
<span class="gutter"> 151 </span>  Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;op &isin;#&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 152 </span>  Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(_/ &isin;# _)&quot;</span> <span class="syntax-OPERATOR">[</span>51<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">]</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 153 </span>
<span class="gutter"> 154 </span><span class="syntax-KEYWORD1">notation</span>  <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 155 </span>  Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;op :#&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 156 </span>  Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(_/ :# _)&quot;</span> <span class="syntax-OPERATOR">[</span>51<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">]</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 157 </span>
<span class="gutter"> 158 </span><span class="syntax-KEYWORD1">abbreviation</span> not_Melem <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'a multiset &rArr; bool&quot;</span>
<span class="gutter"> 159 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;not_Melem a M &equiv; a &notin; set_mset M&quot;</span>
<span class="gutterH"> 160 </span>
<span class="gutter"> 161 </span><span class="syntax-KEYWORD1">notation</span>
<span class="gutter"> 162 </span>  not_Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;op &notin;#&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 163 </span>  not_Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(_/ &notin;# _)&quot;</span> <span class="syntax-OPERATOR">[</span>51<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">]</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 164 </span>
<span class="gutterH"> 165 </span><span class="syntax-KEYWORD1">notation</span>  <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 166 </span>  not_Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;op ~:#&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 167 </span>  not_Melem  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(_/ ~:# _)&quot;</span> <span class="syntax-OPERATOR">[</span>51<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">]</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 168 </span>
<span class="gutter"> 169 </span><span class="syntax-KEYWORD1">context</span>
<span class="gutterH"> 170 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter"> 171 </span>
<span class="gutter"> 172 </span><span class="syntax-KEYWORD2">qualified</span> <span class="syntax-KEYWORD1">abbreviation</span> Ball <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; ('a &rArr; bool) &rArr; bool&quot;</span>
<span class="gutter"> 173 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;Ball M &equiv; Set.Ball (set_mset M)&quot;</span>
<span class="gutter"> 174 </span>
<span class="gutterH"> 175 </span><span class="syntax-KEYWORD2">qualified</span> <span class="syntax-KEYWORD1">abbreviation</span> Bex <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; ('a &rArr; bool) &rArr; bool&quot;</span>
<span class="gutter"> 176 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;Bex M &equiv; Set.Bex (set_mset M)&quot;</span>
<span class="gutter"> 177 </span>
<span class="gutter"> 178 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter"> 179 </span>
<span class="gutterH"> 180 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutter"> 181 </span>  <span class="syntax-LITERAL1">&quot;_MBall&quot;</span>       <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a set &rArr; bool &rArr; bool&quot;</span>      <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&forall;_&isin;#_./ _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 0<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 182 </span>  <span class="syntax-LITERAL1">&quot;_MBex&quot;</span>        <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a set &rArr; bool &rArr; bool&quot;</span>      <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&exist;_&isin;#_./ _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 0<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 183 </span>
<span class="gutter"> 184 </span><span class="syntax-KEYWORD1">syntax</span>  <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 185 </span>  <span class="syntax-LITERAL1">&quot;_MBall&quot;</span>       <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a set &rArr; bool &rArr; bool&quot;</span>      <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&forall;_:#_./ _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 0<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 186 </span>  <span class="syntax-LITERAL1">&quot;_MBex&quot;</span>        <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a set &rArr; bool &rArr; bool&quot;</span>      <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&exist;_:#_./ _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 0<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 187 </span>
<span class="gutter"> 188 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter"> 189 </span>  <span class="syntax-LITERAL1">&quot;&forall;x&isin;#A. P&quot;</span> <span class="syntax-OPERATOR">&#8652;</span> <span class="syntax-LITERAL1">&quot;CONST Multiset.Ball A (&lambda;x. P)&quot;</span>
<span class="gutterH"> 190 </span>  <span class="syntax-LITERAL1">&quot;&exist;x&isin;#A. P&quot;</span> <span class="syntax-OPERATOR">&#8652;</span> <span class="syntax-LITERAL1">&quot;CONST Multiset.Bex A (&lambda;x. P)&quot;</span>
<span class="gutter"> 191 </span>
<span class="gutter"> 192 </span><span class="syntax-KEYWORD1">lemma</span> count_eq_zero_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 193 </span>  <span class="syntax-LITERAL1">&quot;count M x = 0 &#10231; x &notin;# M&quot;</span>
<span class="gutter"> 194 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 195 </span>
<span class="gutter"> 196 </span><span class="syntax-KEYWORD1">lemma</span> not_in_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 197 </span>  <span class="syntax-LITERAL1">&quot;x &notin;# M &#10231; count M x = 0&quot;</span>
<span class="gutter"> 198 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 199 </span>
<span class="gutterH"> 200 </span><span class="syntax-KEYWORD1">lemma</span> count_greater_zero_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 201 </span>  <span class="syntax-LITERAL1">&quot;count M x &gt; 0 &#10231; x &isin;# M&quot;</span>
<span class="gutter"> 202 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 203 </span>
<span class="gutter"> 204 </span><span class="syntax-KEYWORD1">lemma</span> count_inI<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 205 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;count M x = 0 &#10233; False&quot;</span>
<span class="gutter"> 206 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;x &isin;# M&quot;</span>
<span class="gutter"> 207 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 208 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;x &notin;# M&quot;</span>
<span class="gutter"> 209 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> False <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 210 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 211 </span>
<span class="gutter"> 212 </span><span class="syntax-KEYWORD1">lemma</span> in_countE<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 213 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;x &isin;# M&quot;</span>
<span class="gutter"> 214 </span>  <span class="syntax-KEYWORD2">obtains</span> n <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;count M x = Suc n&quot;</span>
<span class="gutterH"> 215 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 216 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count M x &gt; 0&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 217 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> n <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;count M x = Suc n&quot;</span>
<span class="gutter"> 218 </span>    <span class="syntax-KEYWORD1">using</span> gr0_conv_Suc <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter"> 219 </span>  <span class="syntax-KEYWORD1">with</span> that <span class="syntax-KEYWORD3">show</span> thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutterH"> 220 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 221 </span>
<span class="gutter"> 222 </span><span class="syntax-KEYWORD1">lemma</span> count_greater_eq_Suc_zero_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 223 </span>  <span class="syntax-LITERAL1">&quot;count M x &ge; Suc 0 &#10231; x &isin;# M&quot;</span>
<span class="gutter"> 224 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Suc_le_eq<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 225 </span>
<span class="gutter"> 226 </span><span class="syntax-KEYWORD1">lemma</span> count_greater_eq_one_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 227 </span>  <span class="syntax-LITERAL1">&quot;count M x &ge; 1 &#10231; x &isin;# M&quot;</span>
<span class="gutter"> 228 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 229 </span>
<span class="gutterH"> 230 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 231 </span>  <span class="syntax-LITERAL1">&quot;set_mset {#} = {}&quot;</span>
<span class="gutter"> 232 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 233 </span>
<span class="gutter"> 234 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_single<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 235 </span>  <span class="syntax-LITERAL1">&quot;set_mset {#b#} = {b}&quot;</span>
<span class="gutter"> 236 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 237 </span>
<span class="gutter"> 238 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_eq_empty_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 239 </span>  <span class="syntax-LITERAL1">&quot;set_mset M = {} &#10231; M = {#}&quot;</span>
<span class="gutterH"> 240 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 241 </span>
<span class="gutter"> 242 </span><span class="syntax-KEYWORD1">lemma</span> finite_set_mset <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 243 </span>  <span class="syntax-LITERAL1">&quot;finite (set_mset M)&quot;</span>
<span class="gutter"> 244 </span>  <span class="syntax-KEYWORD1">using</span> count <span class="syntax-OPERATOR">[</span>of M<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 245 </span>
<span class="gutter"> 246 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_add_mset_insert <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 247 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp del<span class="syntax-OPERATOR">:</span> count_greater_eq_Suc_zero_iff
<span class="gutter"> 248 </span>      simp<span class="syntax-OPERATOR">:</span> count_greater_eq_Suc_zero_iff<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> split<span class="syntax-OPERATOR">:</span> if_splits<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 249 </span>
<span class="gutterH"> 250 </span><span class="syntax-KEYWORD1">lemma</span> multiset_nonemptyE <span class="syntax-OPERATOR">[</span>elim<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 251 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {#}&quot;</span>
<span class="gutter"> 252 </span>  <span class="syntax-KEYWORD2">obtains</span> x <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;x &isin;# A&quot;</span>
<span class="gutter"> 253 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 254 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&exist;x. x &isin;# A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>insert assms<span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 255 </span>  <span class="syntax-KEYWORD1">with</span> that <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter"> 256 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 257 </span>
<span class="gutter"> 258 </span>
<span class="gutter"> 259 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">U</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 260 </span>
<span class="gutter"> 261 </span><span class="syntax-KEYWORD1">lemma</span> count_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 262 </span>  <span class="syntax-LITERAL1">&quot;count (M + N) a = count M a + count N a&quot;</span>
<span class="gutter"> 263 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> plus_multiset.rep_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 264 </span>
<span class="gutterH"> 265 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 266 </span>  <span class="syntax-LITERAL1">&quot;set_mset (M + N) = set_mset M &cup; set_mset N&quot;</span>
<span class="gutter"> 267 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> set_eq_iff count_greater_zero_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> count_union<span class="syntax-OPERATOR">)</span> simp
<span class="gutter"> 268 </span>
<span class="gutter"> 269 </span><span class="syntax-KEYWORD1">lemma</span> union_mset_add_mset_left <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 270 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A + B = add_mset a (A + B)&quot;</span>
<span class="gutter"> 271 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 272 </span>
<span class="gutter"> 273 </span><span class="syntax-KEYWORD1">lemma</span> union_mset_add_mset_right <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 274 </span>  <span class="syntax-LITERAL1">&quot;A + add_mset a B = add_mset a (A + B)&quot;</span>
<span class="gutterH"> 275 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 276 </span>
<span class="gutter"> 277 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_add_single<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">+</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 278 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>subst union_mset_add_mset_right<span class="syntax-OPERATOR">,</span> subst add.comm_neutral<span class="syntax-OPERATOR">)</span> standard
<span class="gutter"> 279 </span>
<span class="gutterH"> 280 </span>
<span class="gutter"> 281 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">D</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 282 </span>
<span class="gutter"> 283 </span><span class="syntax-KEYWORD1">instance</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>type<span class="syntax-OPERATOR">)</span> comm_monoid_diff
<span class="gutter"> 284 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>transfer<span class="syntax-OPERATOR">;</span> simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 285 </span>
<span class="gutter"> 286 </span><span class="syntax-KEYWORD1">lemma</span> count_diff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 287 </span>  <span class="syntax-LITERAL1">&quot;count (M - N) a = count M a - count N a&quot;</span>
<span class="gutter"> 288 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> minus_multiset.rep_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 289 </span>
<span class="gutterH"> 290 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_diff_bothsides<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 291 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 292 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 293 </span>
<span class="gutter"> 294 </span><span class="syntax-KEYWORD1">lemma</span> in_diff_count<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 295 </span>  <span class="syntax-LITERAL1">&quot;a &isin;# M - N &#10231; count N a &lt; count M a&quot;</span>
<span class="gutter"> 296 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 297 </span>
<span class="gutter"> 298 </span><span class="syntax-KEYWORD1">lemma</span> count_in_diffI<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 299 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;&#8896;n. count N x = n + count M x &#10233; False&quot;</span>
<span class="gutterH"> 300 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;x &isin;# M - N&quot;</span>
<span class="gutter"> 301 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 302 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;x &notin;# M - N&quot;</span>
<span class="gutter"> 303 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count N x = (count N x - count M x) + count M x&quot;</span>
<span class="gutter"> 304 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> in_diff_count not_less<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 305 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> False <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 306 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 307 </span>
<span class="gutter"> 308 </span><span class="syntax-KEYWORD1">lemma</span> in_diff_countE<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 309 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;x &isin;# M - N&quot;</span>
<span class="gutterH"> 310 </span>  <span class="syntax-KEYWORD2">obtains</span> n <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;count M x = Suc n + count N x&quot;</span>
<span class="gutter"> 311 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 312 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count M x - count N x &gt; 0&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> in_diff_count<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 313 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count M x &gt; count N x&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 314 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> n <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;count M x = Suc n + count N x&quot;</span>
<span class="gutterH"> 315 </span>    <span class="syntax-KEYWORD1">using</span> less_iff_Suc_add <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 316 </span>  <span class="syntax-KEYWORD1">with</span> that <span class="syntax-KEYWORD3">show</span> thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter"> 317 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 318 </span>
<span class="gutter"> 319 </span><span class="syntax-KEYWORD1">lemma</span> in_diffD<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 320 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;a &isin;# M - N&quot;</span>
<span class="gutter"> 321 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;a &isin;# M&quot;</span>
<span class="gutter"> 322 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 323 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;0 &le; count N a&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 324 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count N a &lt; count M a&quot;</span>
<span class="gutterH"> 325 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> in_diff_count<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 326 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 327 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 328 </span>
<span class="gutter"> 329 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 330 </span>  <span class="syntax-LITERAL1">&quot;set_mset (M - N) = {a. count N a &lt; count M a}&quot;</span>
<span class="gutter"> 331 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 332 </span>
<span class="gutter"> 333 </span><span class="syntax-KEYWORD1">lemma</span> diff_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M - {#} = M &and; {#} - M = {#}&quot;</span>
<span class="gutter"> 334 </span>  <span class="syntax-KEYWORD1">by</span> rule <span class="syntax-OPERATOR">(</span>fact Groups.diff_zero<span class="syntax-OPERATOR">,</span> fact Groups.zero_diff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 335 </span>
<span class="gutter"> 336 </span><span class="syntax-KEYWORD1">lemma</span> diff_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A - A = {#}&quot;</span>
<span class="gutter"> 337 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact Groups.diff_cancel<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 338 </span>
<span class="gutter"> 339 </span><span class="syntax-KEYWORD1">lemma</span> diff_union_cancelR<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M + N - N = (M::'a multiset)&quot;</span>
<span class="gutterH"> 340 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_diff_cancel_right'<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 341 </span>
<span class="gutter"> 342 </span><span class="syntax-KEYWORD1">lemma</span> diff_union_cancelL<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N + M - N = (M::'a multiset)&quot;</span>
<span class="gutter"> 343 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_diff_cancel_left'<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 344 </span>
<span class="gutterH"> 345 </span><span class="syntax-KEYWORD1">lemma</span> diff_right_commute<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 346 </span>  <span class="syntax-KEYWORD2">fixes</span> M N Q <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter"> 347 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;M - N - Q = M - Q - N&quot;</span>
<span class="gutter"> 348 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact diff_right_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 349 </span>
<span class="gutterH"> 350 </span><span class="syntax-KEYWORD1">lemma</span> diff_add<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 351 </span>  <span class="syntax-KEYWORD2">fixes</span> M N Q <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter"> 352 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;M - (N + Q) = M - N - Q&quot;</span>
<span class="gutter"> 353 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule sym<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>fact diff_diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 354 </span>
<span class="gutterH"> 355 </span><span class="syntax-KEYWORD1">lemma</span> insert_DiffM <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# M &#10233; add_mset x (M - {#x#}) = M&quot;</span>
<span class="gutter"> 356 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>clarsimp simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 357 </span>
<span class="gutter"> 358 </span><span class="syntax-KEYWORD1">lemma</span> insert_DiffM2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# M &#10233; (M - {#x#}) + {#x#} = M&quot;</span>
<span class="gutter"> 359 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 360 </span>
<span class="gutter"> 361 </span><span class="syntax-KEYWORD1">lemma</span> diff_union_swap<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;a &ne; b &#10233; add_mset b (M - {#a#}) = add_mset b M - {#a#}&quot;</span>
<span class="gutter"> 362 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 363 </span>
<span class="gutter"> 364 </span><span class="syntax-KEYWORD1">lemma</span> diff_add_mset_swap <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;b &notin;# A &#10233; add_mset b M - A = add_mset b (M - A)&quot;</span>
<span class="gutterH"> 365 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff simp<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 366 </span>
<span class="gutter"> 367 </span><span class="syntax-KEYWORD1">lemma</span> diff_union_swap2 <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;y &isin;# M &#10233; add_mset x M - {#y#} = add_mset x (M - {#y#})&quot;</span>
<span class="gutter"> 368 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_mset_diff_bothsides diff_union_swap diff_zero insert_DiffM<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 369 </span>
<span class="gutterH"> 370 </span><span class="syntax-KEYWORD1">lemma</span> diff_diff_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M::'a multiset) - N - P = M - (N + P)&quot;</span>
<span class="gutter"> 371 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule diff_diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 372 </span>
<span class="gutter"> 373 </span><span class="syntax-KEYWORD1">lemma</span> diff_union_single_conv<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 374 </span>  <span class="syntax-LITERAL1">&quot;a &isin;# J &#10233; I + J - {#a#} = I + (J - {#a#})&quot;</span>
<span class="gutterH"> 375 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff Suc_le_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 376 </span>
<span class="gutter"> 377 </span><span class="syntax-KEYWORD1">lemma</span> mset_add <span class="syntax-OPERATOR">[</span>elim<span class="syntax-OPERATOR">?</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 378 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;a &isin;# A&quot;</span>
<span class="gutter"> 379 </span>  <span class="syntax-KEYWORD2">obtains</span> B <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;A = add_mset a B&quot;</span>
<span class="gutterH"> 380 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 381 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;A = add_mset a (A - {#a#})&quot;</span>
<span class="gutter"> 382 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 383 </span>  <span class="syntax-KEYWORD1">with</span> that <span class="syntax-KEYWORD3">show</span> thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter"> 384 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH"> 385 </span>
<span class="gutter"> 386 </span><span class="syntax-KEYWORD1">lemma</span> union_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 387 </span>  <span class="syntax-LITERAL1">&quot;a &isin;# A + B &#10231; a &isin;# A &or; a &isin;# B&quot;</span>
<span class="gutter"> 388 </span>  <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 389 </span>
<span class="gutterH"> 390 </span>
<span class="gutter"> 391 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 392 </span>
<span class="gutter"> 393 </span><span class="syntax-KEYWORD1">lemma</span> single_eq_single <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#a#} = {#b#} &#10231; a = b&quot;</span>
<span class="gutter"> 394 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 395 </span>
<span class="gutter"> 396 </span><span class="syntax-KEYWORD1">lemma</span> union_eq_empty <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M + N = {#} &#10231; M = {#} &and; N = {#}&quot;</span>
<span class="gutter"> 397 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 398 </span>
<span class="gutter"> 399 </span><span class="syntax-KEYWORD1">lemma</span> empty_eq_union <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} = M + N &#10231; M = {#} &and; N = {#}&quot;</span>
<span class="gutterH"> 400 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 401 </span>
<span class="gutter"> 402 </span><span class="syntax-KEYWORD1">lemma</span> multi_self_add_other_not_self <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = add_mset x M &#10231; False&quot;</span>
<span class="gutter"> 403 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 404 </span>
<span class="gutterH"> 405 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_remove_trivial <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 406 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 407 </span>
<span class="gutter"> 408 </span><span class="syntax-KEYWORD1">lemma</span> diff_single_trivial<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; x &isin;# M &#10233; M - {#x#} = M&quot;</span>
<span class="gutter"> 409 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 410 </span>
<span class="gutter"> 411 </span><span class="syntax-KEYWORD1">lemma</span> diff_single_eq_union<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# M &#10233; M - {#x#} = N &#10231; M = add_mset x N&quot;</span>
<span class="gutter"> 412 </span>  <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 413 </span>
<span class="gutter"> 414 </span><span class="syntax-KEYWORD1">lemma</span> union_single_eq_diff<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x M = N &#10233; M = N - {#x#}&quot;</span>
<span class="gutterH"> 415 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ M<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_implies_diff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 416 </span>
<span class="gutter"> 417 </span><span class="syntax-KEYWORD1">lemma</span> union_single_eq_member<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x M = N &#10233; x &isin;# N&quot;</span>
<span class="gutter"> 418 </span>  <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 419 </span>
<span class="gutterH"> 420 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_remove_trivial_If<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 421 </span>  <span class="syntax-LITERAL1">&quot;add_mset a (N - {#a#}) = (if a &isin;# N then N else add_mset a N)&quot;</span>
<span class="gutter"> 422 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> diff_single_trivial<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 423 </span>
<span class="gutter"> 424 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_remove_trivial_eq<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&#10231;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 425 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> add_mset_remove_trivial_If<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 426 </span>
<span class="gutter"> 427 </span><span class="syntax-KEYWORD1">lemma</span> union_is_single<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 428 </span>  <span class="syntax-LITERAL1">&quot;M + N = {#a#} &#10231; M = {#a#} &and; N = {#} &or; M = {#} &and; N = {#a#}&quot;</span>
<span class="gutter"> 429 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?lhs = ?rhs&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 430 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter"> 431 </span>  <span class="syntax-KEYWORD3">show</span> ?lhs <span class="syntax-KEYWORD2">if</span> ?rhs <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 432 </span>  <span class="syntax-KEYWORD3">show</span> ?rhs <span class="syntax-KEYWORD2">if</span> ?lhs
<span class="gutter"> 433 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis Multiset.diff_cancel add.commute add_diff_cancel_left' diff_add_zero diff_single_trivial insert_DiffM that<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 434 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH"> 435 </span>
<span class="gutter"> 436 </span><span class="syntax-KEYWORD1">lemma</span> single_is_union<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#a#} = M + N &#10231; {#a#} = M &and; N = {#} &or; M = {#} &and; {#a#} = N&quot;</span>
<span class="gutter"> 437 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> eq_commute <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;{#a#}&quot;</span> <span class="syntax-LITERAL1">&quot;M + N&quot;</span><span class="syntax-OPERATOR">]</span> union_is_single<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 438 </span>
<span class="gutter"> 439 </span><span class="syntax-KEYWORD1">lemma</span> add_eq_conv_diff<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 440 </span>  <span class="syntax-LITERAL1">&quot;add_mset a M = add_mset b N &#10231; M = N &and; a = b &or; M = add_mset b (N - {#a#}) &and; N = add_mset a (M - {#b#})&quot;</span>
<span class="gutter"> 441 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?lhs &#10231; ?rhs&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 442 </span><span class="syntax-COMMENT1">(* shorter: by (simp add: multiset_eq_iff) fastforce *)</span>
<span class="gutter"> 443 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter"> 444 </span>  <span class="syntax-KEYWORD3">show</span> ?lhs <span class="syntax-KEYWORD2">if</span> ?rhs
<span class="gutterH"> 445 </span>    <span class="syntax-KEYWORD1">using</span> that
<span class="gutter"> 446 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> add_mset_commute<span class="syntax-OPERATOR">[</span>of a b<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 447 </span>  <span class="syntax-KEYWORD3">show</span> ?rhs <span class="syntax-KEYWORD2">if</span> ?lhs
<span class="gutter"> 448 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;a = b&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 449 </span>    <span class="syntax-KEYWORD3">case</span> True <span class="syntax-KEYWORD1">with</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 450 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter"> 451 </span>    <span class="syntax-KEYWORD3">case</span> False
<span class="gutter"> 452 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;a &isin;# add_mset b N&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule union_single_eq_member<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 453 </span>    <span class="syntax-KEYWORD1">with</span> False <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;a &isin;# N&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 454 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M = add_mset b N - {#a#}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule union_single_eq_diff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 455 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">note</span> False
<span class="gutter"> 456 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> diff_right_commute <span class="syntax-OPERATOR">[</span>of _ <span class="syntax-LITERAL1">&quot;{#a#}&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 457 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 458 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 459 </span>
<span class="gutterH"> 460 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_eq_single <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset b M = {#a#} &#10231; b = a &and; M = {#}&quot;</span>
<span class="gutter"> 461 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> add_eq_conv_diff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 462 </span>
<span class="gutter"> 463 </span><span class="syntax-KEYWORD1">lemma</span> single_eq_add_mset <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#a#} = add_mset b M &#10231; b = a &and; M = {#}&quot;</span>
<span class="gutter"> 464 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> add_eq_conv_diff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 465 </span>
<span class="gutter"> 466 </span><span class="syntax-KEYWORD1">lemma</span> insert_noteq_member<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 467 </span>  <span class="syntax-KEYWORD2">assumes</span> BC<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset b B = add_mset c C&quot;</span>
<span class="gutter"> 468 </span>   <span class="syntax-KEYWORD2">and</span> bnotc<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;b &ne; c&quot;</span>
<span class="gutter"> 469 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;c &isin;# B&quot;</span>
<span class="gutterH"> 470 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 471 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;c &isin;# add_mset c C&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 472 </span>  <span class="syntax-KEYWORD1">have</span> nc<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; c &isin;# {#b#}&quot;</span> <span class="syntax-KEYWORD1">using</span> bnotc <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 473 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;c &isin;# add_mset b B&quot;</span> <span class="syntax-KEYWORD1">using</span> BC <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 474 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;c &isin;# B&quot;</span> <span class="syntax-KEYWORD1">using</span> nc <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 475 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 476 </span>
<span class="gutter"> 477 </span><span class="syntax-KEYWORD1">lemma</span> add_eq_conv_ex<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 478 </span>  <span class="syntax-LITERAL1">&quot;(add_mset a M = add_mset b N) =</span>
<span class="gutter"> 479 </span><span class="syntax-LITERAL1">    (M = N &and; a = b &or; (&exist;K. M = add_mset b K &and; N = add_mset a K))&quot;</span>
<span class="gutterH"> 480 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> add_eq_conv_diff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 481 </span>
<span class="gutter"> 482 </span><span class="syntax-KEYWORD1">lemma</span> multi_member_split<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# M &#10233; &exist;A. M = add_mset x A&quot;</span>
<span class="gutter"> 483 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule exI <span class="syntax-OPERATOR">[</span><span class="syntax-KEYWORD2">where</span> x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;M - {#x#}&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span> simp
<span class="gutter"> 484 </span>
<span class="gutterH"> 485 </span><span class="syntax-KEYWORD1">lemma</span> multiset_add_sub_el_shuffle<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 486 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;c &isin;# B&quot;</span>
<span class="gutter"> 487 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;b &ne; c&quot;</span>
<span class="gutter"> 488 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;add_mset b (B - {#c#}) = add_mset b B - {#c#}&quot;</span>
<span class="gutter"> 489 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH"> 490 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">obtain</span> A <span class="syntax-KEYWORD2">where</span> B<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B = add_mset c A&quot;</span>
<span class="gutter"> 491 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> multi_member_split<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 492 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;add_mset b A = add_mset c (add_mset b A) - {#c#}&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 493 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;add_mset b A = add_mset b (add_mset c A) - {#c#}&quot;</span>
<span class="gutter"> 494 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&ne;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 495 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">using</span> B <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 496 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 497 </span>
<span class="gutter"> 498 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_eq_singleton_iff<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 499 </span>  <span class="syntax-LITERAL1">&quot;add_mset x M = {#y#} &#10231; M = {#} &and; x = y&quot;</span>
<span class="gutterH"> 500 </span>  <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter"> 501 </span>
<span class="gutter"> 502 </span>
<span class="gutter"> 503 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 504 </span>
<span class="gutterH"> 505 </span><span class="syntax-KEYWORD1">definition</span> subseteq_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&sube;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 506 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;A &sube;# B = (&forall;a. count A a &le; count B a)&quot;</span>
<span class="gutter"> 507 </span>
<span class="gutter"> 508 </span><span class="syntax-KEYWORD1">definition</span> subset_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&sub;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 509 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;A &sub;# B = (A &sube;# B &and; A &ne; B)&quot;</span>
<span class="gutterH"> 510 </span>
<span class="gutter"> 511 </span><span class="syntax-KEYWORD1">abbreviation</span> <span class="syntax-OPERATOR">(</span>input<span class="syntax-OPERATOR">)</span> supseteq_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&supe;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 512 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;supseteq_mset A B &equiv; B &sube;# A&quot;</span>
<span class="gutter"> 513 </span>
<span class="gutter"> 514 </span><span class="syntax-KEYWORD1">abbreviation</span> <span class="syntax-OPERATOR">(</span>input<span class="syntax-OPERATOR">)</span> supset_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&sup;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 515 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;supset_mset A B &equiv; B &sub;# A&quot;</span>
<span class="gutter"> 516 </span>
<span class="gutter"> 517 </span><span class="syntax-KEYWORD1">notation</span> <span class="syntax-OPERATOR">(</span>input<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 518 </span>  subseteq_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&le;#&quot;</span> 50<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 519 </span>  supseteq_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&ge;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 520 </span>
<span class="gutter"> 521 </span><span class="syntax-KEYWORD1">notation</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 522 </span>  subseteq_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&lt;=#&quot;</span> 50<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 523 </span>  subset_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&lt;#&quot;</span> 50<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter"> 524 </span>  supseteq_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&gt;=#&quot;</span> 50<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutterH"> 525 </span>  supset_mset  <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&gt;#&quot;</span> 50<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 526 </span>
<span class="gutter"> 527 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> ordered_ab_semigroup_add_imp_le <span class="syntax-LITERAL1">&quot;op +&quot;</span> <span class="syntax-LITERAL1">&quot;op -&quot;</span> <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span>
<span class="gutter"> 528 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subset_mset_def subseteq_mset_def multiset_eq_iff intro<span class="syntax-OPERATOR">:</span> order_trans antisym<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 529 </span>
<span class="gutterH"> 530 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> ordered_ab_semigroup_monoid_add_imp_le <span class="syntax-LITERAL1">&quot;op +&quot;</span> 0 <span class="syntax-LITERAL1">&quot;op -&quot;</span> <span class="syntax-LITERAL1">&quot;op &le;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &lt;#&quot;</span>
<span class="gutter"> 531 </span>  <span class="syntax-KEYWORD1">by</span> standard
<span class="gutter"> 532 </span>
<span class="gutter"> 533 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eqI<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 534 </span>  <span class="syntax-LITERAL1">&quot;(&#8896;a. count A a &le; count B a) &#10233; A &sube;# B&quot;</span>
<span class="gutterH"> 535 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 536 </span>
<span class="gutter"> 537 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_count<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 538 </span>  <span class="syntax-LITERAL1">&quot;A &sube;# B &#10233; count A a &le; count B a&quot;</span>
<span class="gutter"> 539 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 540 </span>
<span class="gutter"> 541 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_exists_conv<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) &sube;# B &#10231; (&exist;C. B = A + C)&quot;</span>
<span class="gutter"> 542 </span>  <span class="syntax-KEYWORD1">unfolding</span> subseteq_mset_def
<span class="gutter"> 543 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule iffI<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 544 </span>   <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule exI <span class="syntax-OPERATOR">[</span><span class="syntax-KEYWORD2">where</span> x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;B - A&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 545 </span>   <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> multiset_eq_iff <span class="syntax-OPERATOR">[</span>THEN iffD2<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 546 </span>  <span class="syntax-KEYWORD1">done</span>
<span class="gutter"> 547 </span>
<span class="gutter"> 548 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> ordered_cancel_comm_monoid_diff <span class="syntax-LITERAL1">&quot;op +&quot;</span> 0 <span class="syntax-LITERAL1">&quot;op &le;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &lt;#&quot;</span> <span class="syntax-LITERAL1">&quot;op -&quot;</span>
<span class="gutter"> 549 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp<span class="syntax-OPERATOR">,</span> fact mset_subset_eq_exists_conv<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 550 </span>
<span class="gutter"> 551 </span><span class="syntax-KEYWORD1">declare</span> subset_mset.add_diff_assoc<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span> subset_mset.add_diff_assoc2<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter"> 552 </span>
<span class="gutter"> 553 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_mono_add_right_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) + C &sube;# B + C &#10231; A &sube;# B&quot;</span>
<span class="gutter"> 554 </span>   <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.add_le_cancel_right<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 555 </span>
<span class="gutter"> 556 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_mono_add_left_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;C + (A::'a multiset) &sube;# C + B &#10231; A &sube;# B&quot;</span>
<span class="gutter"> 557 </span>   <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.add_le_cancel_left<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 558 </span>
<span class="gutter"> 559 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_mono_add<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) &sube;# B &#10233; C &sube;# D &#10233; A + C &sube;# B + D&quot;</span>
<span class="gutterH"> 560 </span>   <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.add_mono<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 561 </span>
<span class="gutter"> 562 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_add_left<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) &sube;# A + B&quot;</span>
<span class="gutter"> 563 </span>   <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 564 </span>
<span class="gutterH"> 565 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_add_right<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B &sube;# (A::'a multiset) + B&quot;</span>
<span class="gutter"> 566 </span>   <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 567 </span>
<span class="gutter"> 568 </span><span class="syntax-KEYWORD1">lemma</span> single_subset_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 569 </span>  <span class="syntax-LITERAL1">&quot;{#a#} &sube;# M &#10231; a &isin;# M&quot;</span>
<span class="gutterH"> 570 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def Suc_le_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 571 </span>
<span class="gutter"> 572 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;a &isin;# B &#10233; {#a#} &sube;# B&quot;</span>
<span class="gutter"> 573 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 574 </span>
<span class="gutterH"> 575 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_add_mset_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&sube;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&#10231;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&sube;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 576 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ A<span class="syntax-OPERATOR">]</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ B<span class="syntax-OPERATOR">]</span>
<span class="gutter"> 577 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eq_mono_add_right_cancel<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 578 </span>
<span class="gutter"> 579 </span><span class="syntax-KEYWORD1">lemma</span> multiset_diff_union_assoc<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 580 </span>  <span class="syntax-KEYWORD2">fixes</span> A B C D <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter"> 581 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;C &sube;# B &#10233; A + B - C = A + (B - C)&quot;</span>
<span class="gutter"> 582 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.diff_add_assoc<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 583 </span>
<span class="gutter"> 584 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_multiset_union_diff_commute<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 585 </span>  <span class="syntax-KEYWORD2">fixes</span> A B C D <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter"> 586 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;B &sube;# A &#10233; A - B + C = A + C - B&quot;</span>
<span class="gutter"> 587 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.add_diff_assoc2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 588 </span>
<span class="gutter"> 589 </span><span class="syntax-KEYWORD1">lemma</span> diff_subset_eq_self<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 590 </span>  <span class="syntax-LITERAL1">&quot;(M::'a multiset) - N &sube;# M&quot;</span>
<span class="gutter"> 591 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 592 </span>
<span class="gutter"> 593 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eqD<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 594 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &sube;# B&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;x &isin;# A&quot;</span>
<span class="gutterH"> 595 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;x &isin;# B&quot;</span>
<span class="gutter"> 596 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 597 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count A x &gt; 0&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 598 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&sube;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count A x &le; count B x&quot;</span>
<span class="gutter"> 599 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 600 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter"> 601 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 602 </span>
<span class="gutter"> 603 </span><span class="syntax-KEYWORD1">lemma</span> mset_subsetD<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 604 </span>  <span class="syntax-LITERAL1">&quot;A &sub;# B &#10233; x &isin;# A &#10233; x &isin;# B&quot;</span>
<span class="gutterH"> 605 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> mset_subset_eqD <span class="syntax-OPERATOR">[</span>of A<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 606 </span>
<span class="gutter"> 607 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_mono<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 608 </span>  <span class="syntax-LITERAL1">&quot;A &sube;# B &#10233; set_mset A &sube; set_mset B&quot;</span>
<span class="gutter"> 609 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis mset_subset_eqD subsetI<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 610 </span>
<span class="gutter"> 611 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_eq_insertD<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 612 </span>  <span class="syntax-LITERAL1">&quot;add_mset x A &sube;# B &#10233; x &isin;# B &and; A &sub;# B&quot;</span>
<span class="gutter"> 613 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule conjI<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 614 </span> <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_subset_eqD<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 615 </span> <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>clarsimp simp<span class="syntax-OPERATOR">:</span> subset_mset_def subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 616 </span> <span class="syntax-KEYWORD1">apply</span> safe
<span class="gutter"> 617 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>erule_tac x <span class="syntax-OPERATOR">=</span> a <span class="syntax-KEYWORD2">in</span> allE<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 618 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto split<span class="syntax-OPERATOR">:</span> if_split_asm<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 619 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutterH"> 620 </span>
<span class="gutter"> 621 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_insertD<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 622 </span>  <span class="syntax-LITERAL1">&quot;add_mset x A &sub;# B &#10233; x &isin;# B &and; A &sub;# B&quot;</span>
<span class="gutter"> 623 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eq_insertD<span class="syntax-OPERATOR">)</span> simp
<span class="gutter"> 624 </span>
<span class="gutterH"> 625 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_of_empty<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &sub;# {#} &#10231; False&quot;</span>
<span class="gutter"> 626 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> subset_mset.not_less_zero<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 627 </span>
<span class="gutter"> 628 </span><span class="syntax-KEYWORD1">lemma</span> empty_subset_add_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} &lt;# add_mset x M&quot;</span>
<span class="gutter"> 629 </span><span class="syntax-KEYWORD1">by</span><span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> subset_mset.gr_zeroI<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 630 </span>
<span class="gutter"> 631 </span><span class="syntax-KEYWORD1">lemma</span> empty_le<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} &sube;# A&quot;</span>
<span class="gutter"> 632 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.zero_le<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 633 </span>
<span class="gutter"> 634 </span><span class="syntax-KEYWORD1">lemma</span> insert_subset_eq_iff<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 635 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A &sube;# B &#10231; a &isin;# B &and; A &sube;# B - {#a#}&quot;</span>
<span class="gutter"> 636 </span>  <span class="syntax-KEYWORD1">using</span> le_diff_conv2 <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;Suc 0&quot;</span> <span class="syntax-LITERAL1">&quot;count B a&quot;</span> <span class="syntax-LITERAL1">&quot;count A a&quot;</span><span class="syntax-OPERATOR">]</span>
<span class="gutter"> 637 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def not_in_iff Suc_le_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 638 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 639 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 640 </span>  <span class="syntax-KEYWORD1">done</span>
<span class="gutter"> 641 </span>
<span class="gutter"> 642 </span><span class="syntax-KEYWORD1">lemma</span> insert_union_subset_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 643 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A &sub;# B &#10231; a &isin;# B &and; A &sub;# B - {#a#}&quot;</span>
<span class="gutter"> 644 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> insert_subset_eq_iff subset_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 645 </span>
<span class="gutter"> 646 </span><span class="syntax-KEYWORD1">lemma</span> subset_eq_diff_conv<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 647 </span>  <span class="syntax-LITERAL1">&quot;A - C &sube;# B &#10231; A &sube;# B + C&quot;</span>
<span class="gutter"> 648 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def le_diff_conv<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 649 </span>
<span class="gutterH"> 650 </span><span class="syntax-KEYWORD1">lemma</span> multi_psub_of_add_self <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &sub;# add_mset x A&quot;</span>
<span class="gutter"> 651 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subset_mset_def subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 652 </span>
<span class="gutter"> 653 </span><span class="syntax-KEYWORD1">lemma</span> multi_psub_self<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &sub;# A = False&quot;</span>
<span class="gutter"> 654 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 655 </span>
<span class="gutter"> 656 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x N &sub;# add_mset x M &#10231; N &sub;# M&quot;</span>
<span class="gutter"> 657 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ N<span class="syntax-OPERATOR">]</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ M<span class="syntax-OPERATOR">]</span>
<span class="gutter"> 658 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.add_less_cancel_right<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 659 </span>
<span class="gutterH"> 660 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_diff_self<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;c &isin;# B &#10233; B - {#c#} &sub;# B&quot;</span>
<span class="gutter"> 661 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subset_mset_def elim<span class="syntax-OPERATOR">:</span> mset_add<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 662 </span>
<span class="gutter"> 663 </span><span class="syntax-KEYWORD1">lemma</span> Diff_eq_empty_iff_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A - B = {#} &#10231; A &sube;# B&quot;</span>
<span class="gutter"> 664 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 665 </span>
<span class="gutter"> 666 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_subseteq_single_iff<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset a M &sube;# {#b#} &#10231; M = {#} &and; a = b&quot;</span>
<span class="gutter"> 667 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter"> 668 </span>  <span class="syntax-KEYWORD3">assume</span> A<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset a M &sube;# {#b#}&quot;</span>
<span class="gutter"> 669 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 670 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> mset_subset_eq_insertD<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 671 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;M={#} &and; a=b&quot;</span>
<span class="gutter"> 672 </span>    <span class="syntax-KEYWORD1">using</span> A <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_subset_eq_add_mset_cancel<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 673 </span><span class="syntax-KEYWORD1">qed</span> simp
<span class="gutter"> 674 </span>
<span class="gutterH"> 675 </span>
<span class="gutter"> 676 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 677 </span>
<span class="gutter"> 678 </span><span class="syntax-KEYWORD1">definition</span> inf_subset_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; 'a multiset&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&cap;#&quot;</span> 70<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 679 </span>  multiset_inter_def<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;inf_subset_mset A B = A - (A - B)&quot;</span>
<span class="gutterH"> 680 </span>
<span class="gutter"> 681 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> semilattice_inf inf_subset_mset <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span>
<span class="gutter"> 682 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter"> 683 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;m &le; n &#10233; m &le; q &#10233; m &le; n - (n - q)&quot;</span> <span class="syntax-KEYWORD2">for</span> m n q <span class="syntax-OPERATOR">::</span> nat
<span class="gutter"> 684 </span>    <span class="syntax-KEYWORD1">by</span> arith
<span class="gutterH"> 685 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;class.semilattice_inf op &cap;# op &sube;# op &sub;#&quot;</span>
<span class="gutter"> 686 </span>    <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_inter_def subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 687 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 688 </span>  <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 689 </span>
<span class="gutterH"> 690 </span><span class="syntax-KEYWORD1">definition</span> sup_subset_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; 'a multiset&quot;</span><span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&cup;#&quot;</span> 70<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 691 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;sup_subset_mset A B = A + (B - A)&quot;</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 692 </span>
<span class="gutter"> 693 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> semilattice_sup sup_subset_mset <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span>
<span class="gutter"> 694 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH"> 695 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;m &le; n &#10233; q &le; n &#10233; m + (q - m) &le; n&quot;</span> <span class="syntax-KEYWORD2">for</span> m n q <span class="syntax-OPERATOR">::</span> nat
<span class="gutter"> 696 </span>    <span class="syntax-KEYWORD1">by</span> arith
<span class="gutter"> 697 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;class.semilattice_sup op &cup;# op &sube;# op &sub;#&quot;</span>
<span class="gutter"> 698 </span>    <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> sup_subset_mset_def subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 699 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH"> 700 </span>  <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 701 </span>
<span class="gutter"> 702 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> bounded_lattice_bot <span class="syntax-LITERAL1">&quot;op &cap;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span>
<span class="gutter"> 703 </span>  <span class="syntax-LITERAL1">&quot;op &cup;#&quot;</span> <span class="syntax-LITERAL1">&quot;{#}&quot;</span>
<span class="gutter"> 704 </span>  <span class="syntax-KEYWORD1">by</span> standard auto
<span class="gutterH"> 705 </span>
<span class="gutter"> 706 </span>
<span class="gutter"> 707 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 708 </span>
<span class="gutter"> 709 </span><span class="syntax-KEYWORD1">lemma</span> multiset_inter_count <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 710 </span>  <span class="syntax-KEYWORD2">fixes</span> A B <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter"> 711 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;count (A &cap;# B) x = min (count A x) (count B x)&quot;</span>
<span class="gutter"> 712 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_inter_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 713 </span>
<span class="gutter"> 714 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_inter <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 715 </span>  <span class="syntax-LITERAL1">&quot;set_mset (A &cap;# B) = set_mset A &cap; set_mset B&quot;</span>
<span class="gutter"> 716 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> set_eq_iff count_greater_zero_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> multiset_inter_count<span class="syntax-OPERATOR">)</span> simp
<span class="gutter"> 717 </span>
<span class="gutter"> 718 </span><span class="syntax-KEYWORD1">lemma</span> diff_intersect_left_idem <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 719 </span>  <span class="syntax-LITERAL1">&quot;M - M &cap;# N = M - N&quot;</span>
<span class="gutterH"> 720 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff min_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 721 </span>
<span class="gutter"> 722 </span><span class="syntax-KEYWORD1">lemma</span> diff_intersect_right_idem <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 723 </span>  <span class="syntax-LITERAL1">&quot;M - N &cap;# M = M - N&quot;</span>
<span class="gutter"> 724 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff min_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 725 </span>
<span class="gutter"> 726 </span><span class="syntax-KEYWORD1">lemma</span> multiset_inter_single<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;a &ne; b &#10233; {#a#} &cap;# {#b#} = {#}&quot;</span>
<span class="gutter"> 727 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> auto
<span class="gutter"> 728 </span>
<span class="gutter"> 729 </span><span class="syntax-KEYWORD1">lemma</span> multiset_union_diff_commute<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 730 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;B &cap;# C = {#}&quot;</span>
<span class="gutter"> 731 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;A + B - C = A - C + B&quot;</span>
<span class="gutter"> 732 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 733 </span>  <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter"> 734 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;min (count B x) (count C x) = 0&quot;</span>
<span class="gutterH"> 735 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 736 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count B x = 0 &or; count C x = 0&quot;</span>
<span class="gutter"> 737 </span>    <span class="syntax-KEYWORD1">unfolding</span> min_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto split<span class="syntax-OPERATOR">:</span> if_splits<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 738 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count (A + B - C) x = count (A - C + B) x&quot;</span>
<span class="gutter"> 739 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH"> 740 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 741 </span>
<span class="gutter"> 742 </span><span class="syntax-KEYWORD1">lemma</span> disjunct_not_in<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 743 </span>  <span class="syntax-LITERAL1">&quot;A &cap;# B = {#} &#10231; (&forall;a. a &notin;# A &or; a &notin;# B)&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?P &#10231; ?Q&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter"> 744 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutterH"> 745 </span>  <span class="syntax-KEYWORD3">assume</span> ?P
<span class="gutter"> 746 </span>  <span class="syntax-KEYWORD3">show</span> ?Q
<span class="gutter"> 747 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter"> 748 </span>    <span class="syntax-KEYWORD3">fix</span> a
<span class="gutter"> 749 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;min (count A a) (count B a) = 0&quot;</span>
<span class="gutterH"> 750 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 751 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count A a = 0 &or; count B a = 0&quot;</span>
<span class="gutter"> 752 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;count A a &le; count B a&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> min_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 753 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;a &notin;# A &or; a &notin;# B&quot;</span>
<span class="gutter"> 754 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 755 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 756 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter"> 757 </span>  <span class="syntax-KEYWORD3">assume</span> ?Q
<span class="gutter"> 758 </span>  <span class="syntax-KEYWORD3">show</span> ?P
<span class="gutter"> 759 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 760 </span>    <span class="syntax-KEYWORD3">fix</span> a
<span class="gutter"> 761 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">Q</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count A a = 0 &or; count B a = 0&quot;</span>
<span class="gutter"> 762 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 763 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count (A &cap;# B) a = count {#} a&quot;</span>
<span class="gutter"> 764 </span>      <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH"> 765 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 766 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 767 </span>
<span class="gutter"> 768 </span><span class="syntax-KEYWORD1">lemma</span> inter_mset_empty_distrib_right<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &cap;# (B + C) = {#} &#10231; A &cap;# B = {#} &and; A &cap;# C = {#}&quot;</span>
<span class="gutter"> 769 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>meson disjunct_not_in union_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 770 </span>
<span class="gutter"> 771 </span><span class="syntax-KEYWORD1">lemma</span> inter_mset_empty_distrib_left<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A + B) &cap;# C = {#} &#10231; A &cap;# C = {#} &and; B &cap;# C = {#}&quot;</span>
<span class="gutter"> 772 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>meson disjunct_not_in union_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 773 </span>
<span class="gutter"> 774 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_inter_add_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 775 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A &cap;# add_mset a B = add_mset a (A &cap;# B)&quot;</span>
<span class="gutter"> 776 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_mset_add_single add_mset_diff_bothsides diff_subset_eq_self multiset_inter_def
<span class="gutter"> 777 </span>      subset_mset.diff_add_assoc2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 778 </span>
<span class="gutter"> 779 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_disjoint <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 780 </span>  <span class="syntax-LITERAL1">&quot;add_mset a A &cap;# B = {#} &#10231; a &notin;# B &and; A &cap;# B = {#}&quot;</span>
<span class="gutter"> 781 </span>  <span class="syntax-LITERAL1">&quot;{#} = add_mset a A &cap;# B &#10231; a &notin;# B &and; {#} = A &cap;# B&quot;</span>
<span class="gutter"> 782 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> disjunct_not_in<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 783 </span>
<span class="gutter"> 784 </span><span class="syntax-KEYWORD1">lemma</span> disjoint_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 785 </span>  <span class="syntax-LITERAL1">&quot;B &cap;# add_mset a A = {#} &#10231; a &notin;# B &and; B &cap;# A = {#}&quot;</span>
<span class="gutter"> 786 </span>  <span class="syntax-LITERAL1">&quot;{#} = A &cap;# add_mset b B &#10231; b &notin;# A &and; {#} = A &cap;# B&quot;</span>
<span class="gutter"> 787 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> disjunct_not_in<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 788 </span>
<span class="gutter"> 789 </span><span class="syntax-KEYWORD1">lemma</span> inter_add_left1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; x &isin;# N &#10233; (add_mset x M) &cap;# N = M &cap;# N&quot;</span>
<span class="gutterH"> 790 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 791 </span>
<span class="gutter"> 792 </span><span class="syntax-KEYWORD1">lemma</span> inter_add_left2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# N &#10233; (add_mset x M) &cap;# N = add_mset x (M &cap;# (N - {#x#}))&quot;</span>
<span class="gutter"> 793 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff elim<span class="syntax-OPERATOR">:</span> mset_add<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 794 </span>
<span class="gutterH"> 795 </span><span class="syntax-KEYWORD1">lemma</span> inter_add_right1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; x &isin;# N &#10233; N &cap;# (add_mset x M) = N &cap;# M&quot;</span>
<span class="gutter"> 796 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 797 </span>
<span class="gutter"> 798 </span><span class="syntax-KEYWORD1">lemma</span> inter_add_right2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# N &#10233; N &cap;# (add_mset x M) = add_mset x ((N - {#x#}) &cap;# M)&quot;</span>
<span class="gutter"> 799 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff elim<span class="syntax-OPERATOR">:</span> mset_add<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 800 </span>
<span class="gutter"> 801 </span><span class="syntax-KEYWORD1">lemma</span> disjunct_set_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 802 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;M &cap;# N = {#}&quot;</span>
<span class="gutter"> 803 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;set_mset (M - N) = set_mset M&quot;</span>
<span class="gutter"> 804 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule set_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 805 </span>  <span class="syntax-KEYWORD3">fix</span> a
<span class="gutter"> 806 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;a &notin;# M &or; a &notin;# N&quot;</span>
<span class="gutter"> 807 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> disjunct_not_in<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 808 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;a &isin;# M - N &#10231; a &isin;# M&quot;</span>
<span class="gutter"> 809 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> in_diffD<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> in_diff_count not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 810 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 811 </span>
<span class="gutter"> 812 </span><span class="syntax-KEYWORD1">lemma</span> at_most_one_mset_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 813 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;a &notin;# M - {#a#}&quot;</span>
<span class="gutter"> 814 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;set_mset (M - {#a#}) = set_mset M - {a}&quot;</span>
<span class="gutterH"> 815 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> not_in_iff in_diff_count set_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 816 </span>
<span class="gutter"> 817 </span><span class="syntax-KEYWORD1">lemma</span> more_than_one_mset_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 818 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;a &isin;# M - {#a#}&quot;</span>
<span class="gutter"> 819 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;set_mset (M - {#a#}) = set_mset M&quot;</span>
<span class="gutterH"> 820 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule set_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 821 </span>  <span class="syntax-KEYWORD3">fix</span> b
<span class="gutter"> 822 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;Suc 0 &lt; count M b &#10233; count M b &gt; 0&quot;</span> <span class="syntax-KEYWORD1">by</span> arith
<span class="gutter"> 823 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;b &isin;# M - {#a#} &#10231; b &isin;# M&quot;</span>
<span class="gutter"> 824 </span>    <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> in_diff_count<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 825 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter"> 826 </span>
<span class="gutter"> 827 </span><span class="syntax-KEYWORD1">lemma</span> inter_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 828 </span>  <span class="syntax-LITERAL1">&quot;a &isin;# A &cap;# B &#10231; a &isin;# A &and; a &isin;# B&quot;</span>
<span class="gutter"> 829 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 830 </span>
<span class="gutter"> 831 </span><span class="syntax-KEYWORD1">lemma</span> inter_union_distrib_left<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 832 </span>  <span class="syntax-LITERAL1">&quot;A &cap;# B + C = (A + C) &cap;# (B + C)&quot;</span>
<span class="gutter"> 833 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff min_add_distrib_left<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 834 </span>
<span class="gutterH"> 835 </span><span class="syntax-KEYWORD1">lemma</span> inter_union_distrib_right<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 836 </span>  <span class="syntax-LITERAL1">&quot;C + A &cap;# B = (C + A) &cap;# (C + B)&quot;</span>
<span class="gutter"> 837 </span>  <span class="syntax-KEYWORD1">using</span> inter_union_distrib_left <span class="syntax-OPERATOR">[</span>of A B C<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 838 </span>
<span class="gutter"> 839 </span><span class="syntax-KEYWORD1">lemma</span> inter_subset_eq_union<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 840 </span>  <span class="syntax-LITERAL1">&quot;A &cap;# B &sube;# A + B&quot;</span>
<span class="gutter"> 841 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 842 </span>
<span class="gutter"> 843 </span>
<span class="gutter"> 844 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 845 </span>
<span class="gutter"> 846 </span><span class="syntax-KEYWORD1">lemma</span> sup_subset_mset_count <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 847 </span>  <span class="syntax-LITERAL1">&quot;count (A &cup;# B) x = max (count A x) (count B x)&quot;</span>
<span class="gutter"> 848 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sup_subset_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 849 </span>
<span class="gutterH"> 850 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_sup <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 851 </span>  <span class="syntax-LITERAL1">&quot;set_mset (A &cup;# B) = set_mset A &cup; set_mset B&quot;</span>
<span class="gutter"> 852 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> set_eq_iff count_greater_zero_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> sup_subset_mset_count<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 853 </span>    <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> not_in_iff elim<span class="syntax-OPERATOR">:</span> mset_add<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 854 </span>
<span class="gutterH"> 855 </span><span class="syntax-KEYWORD1">lemma</span> sup_union_left1 <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; x &isin;# N &#10233; (add_mset x M) &cup;# N = add_mset x (M &cup;# N)&quot;</span>
<span class="gutter"> 856 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 857 </span>
<span class="gutter"> 858 </span><span class="syntax-KEYWORD1">lemma</span> sup_union_left2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# N &#10233; (add_mset x M) &cup;# N = add_mset x (M &cup;# (N - {#x#}))&quot;</span>
<span class="gutter"> 859 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 860 </span>
<span class="gutter"> 861 </span><span class="syntax-KEYWORD1">lemma</span> sup_union_right1 <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; x &isin;# N &#10233; N &cup;# (add_mset x M) = add_mset x (N &cup;# M)&quot;</span>
<span class="gutter"> 862 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 863 </span>
<span class="gutter"> 864 </span><span class="syntax-KEYWORD1">lemma</span> sup_union_right2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# N &#10233; N &cup;# (add_mset x M) = add_mset x ((N - {#x#}) &cup;# M)&quot;</span>
<span class="gutterH"> 865 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 866 </span>
<span class="gutter"> 867 </span><span class="syntax-KEYWORD1">lemma</span> sup_union_distrib_left<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 868 </span>  <span class="syntax-LITERAL1">&quot;A &cup;# B + C = (A + C) &cup;# (B + C)&quot;</span>
<span class="gutter"> 869 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff max_add_distrib_left<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 870 </span>
<span class="gutter"> 871 </span><span class="syntax-KEYWORD1">lemma</span> union_sup_distrib_right<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 872 </span>  <span class="syntax-LITERAL1">&quot;C + A &cup;# B = (C + A) &cup;# (C + B)&quot;</span>
<span class="gutter"> 873 </span>  <span class="syntax-KEYWORD1">using</span> sup_union_distrib_left <span class="syntax-OPERATOR">[</span>of A B C<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 874 </span>
<span class="gutterH"> 875 </span><span class="syntax-KEYWORD1">lemma</span> union_diff_inter_eq_sup<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 876 </span>  <span class="syntax-LITERAL1">&quot;A + B - A &cap;# B = A &cup;# B&quot;</span>
<span class="gutter"> 877 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 878 </span>
<span class="gutter"> 879 </span><span class="syntax-KEYWORD1">lemma</span> union_diff_sup_eq_inter<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 880 </span>  <span class="syntax-LITERAL1">&quot;A + B - A &cup;# B = A &cap;# B&quot;</span>
<span class="gutter"> 881 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 882 </span>
<span class="gutter"> 883 </span><span class="syntax-KEYWORD1">lemma</span> add_mset_union<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 884 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&cup;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&cup;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 885 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff max_def<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 886 </span>
<span class="gutter"> 887 </span>
<span class="gutter"> 888 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 889 </span>
<span class="gutterH"> 890 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> order <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span> <span class="syntax-KEYWORD1">by</span> unfold_locales
<span class="gutter"> 891 </span>
<span class="gutter"> 892 </span>
<span class="gutter"> 893 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">R</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 894 </span>
<span class="gutterH"> 895 </span><span class="syntax-KEYWORD1">definition</span> replicate_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;nat &rArr; 'a &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 896 </span>  <span class="syntax-LITERAL1">&quot;replicate_mset n x = (add_mset x ^^ n) {#}&quot;</span>
<span class="gutter"> 897 </span>
<span class="gutter"> 898 </span><span class="syntax-KEYWORD1">lemma</span> replicate_mset_0<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;replicate_mset 0 x = {#}&quot;</span>
<span class="gutter"> 899 </span>  <span class="syntax-KEYWORD1">unfolding</span> replicate_mset_def <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH"> 900 </span>
<span class="gutter"> 901 </span><span class="syntax-KEYWORD1">lemma</span> replicate_mset_Suc <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;replicate_mset (Suc n) x = add_mset x (replicate_mset n x)&quot;</span>
<span class="gutter"> 902 </span>  <span class="syntax-KEYWORD1">unfolding</span> replicate_mset_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> add.commute<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 903 </span>
<span class="gutter"> 904 </span><span class="syntax-KEYWORD1">lemma</span> count_replicate_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count (replicate_mset n x) y = (if y = x then n else 0)&quot;</span>
<span class="gutterH"> 905 </span>  <span class="syntax-KEYWORD1">unfolding</span> replicate_mset_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> auto
<span class="gutter"> 906 </span>
<span class="gutter"> 907 </span><span class="syntax-KEYWORD1">fun</span> repeat_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;nat &rArr; 'a multiset &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 908 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset 0 _ = {#}&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 909 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset (Suc n) A = A + repeat_mset n A&quot;</span>
<span class="gutterH"> 910 </span>
<span class="gutter"> 911 </span><span class="syntax-KEYWORD1">lemma</span> count_repeat_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count (repeat_mset i A) a = i * count A a&quot;</span>
<span class="gutter"> 912 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction i<span class="syntax-OPERATOR">)</span> auto
<span class="gutter"> 913 </span>
<span class="gutter"> 914 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_right <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;repeat_mset a (repeat_mset b A) = repeat_mset (a * b) A&quot;</span>
<span class="gutterH"> 915 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff left_diff_distrib'<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 916 </span>
<span class="gutter"> 917 </span><span class="syntax-KEYWORD1">lemma</span> left_diff_repeat_mset_distrib'<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 918 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff left_diff_distrib'<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 919 </span>
<span class="gutterH"> 920 </span><span class="syntax-KEYWORD1">lemma</span> left_add_mult_distrib_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 921 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset i u + (repeat_mset j u + k) = repeat_mset (i+j) u + k&quot;</span>
<span class="gutter"> 922 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff add_mult_distrib<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 923 </span>
<span class="gutter"> 924 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_distrib<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 925 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset (m + n) A = repeat_mset m A + repeat_mset n A&quot;</span>
<span class="gutter"> 926 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff Nat.add_mult_distrib<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 927 </span>
<span class="gutter"> 928 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_distrib2<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 929 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset n (A + B) = repeat_mset n A + repeat_mset n B&quot;</span>
<span class="gutterH"> 930 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff add_mult_distrib2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 931 </span>
<span class="gutter"> 932 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_replicate_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 933 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset n {#a#} = replicate_mset n a&quot;</span>
<span class="gutter"> 934 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 935 </span>
<span class="gutter"> 936 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_distrib_add_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter"> 937 </span>  <span class="syntax-LITERAL1">&quot;repeat_mset n (add_mset a A) = replicate_mset n a + repeat_mset n A&quot;</span>
<span class="gutter"> 938 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 939 </span>
<span class="gutterH"> 940 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_empty<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;repeat_mset n {#} = {#}&quot;</span>
<span class="gutter"> 941 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction n<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter"> 942 </span>
<span class="gutter"> 943 </span>
<span class="gutter"> 944 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH"> 945 </span>
<span class="gutter"> 946 </span><span class="syntax-KEYWORD1">lemma</span> mset_diff_add_eq1<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 947 </span>  <span class="syntax-LITERAL1">&quot;j &le; (i::nat) &#10233; ((repeat_mset i u + m) - (repeat_mset j u + n)) = ((repeat_mset (i-j) u + m) - n)&quot;</span>
<span class="gutter"> 948 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff nat_diff_add_eq1<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 949 </span>
<span class="gutterH"> 950 </span><span class="syntax-KEYWORD1">lemma</span> mset_diff_add_eq2<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 951 </span>  <span class="syntax-LITERAL1">&quot;i &le; (j::nat) &#10233; ((repeat_mset i u + m) - (repeat_mset j u + n)) = (m - (repeat_mset (j-i) u + n))&quot;</span>
<span class="gutter"> 952 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff nat_diff_add_eq2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 953 </span>
<span class="gutter"> 954 </span><span class="syntax-KEYWORD1">lemma</span> mset_eq_add_iff1<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 955 </span>   <span class="syntax-LITERAL1">&quot;j &le; (i::nat) &#10233; (repeat_mset i u + m = repeat_mset j u + n) = (repeat_mset (i-j) u + m = n)&quot;</span>
<span class="gutter"> 956 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff nat_eq_add_iff1<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 957 </span>
<span class="gutter"> 958 </span><span class="syntax-KEYWORD1">lemma</span> mset_eq_add_iff2<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 959 </span>   <span class="syntax-LITERAL1">&quot;i &le; (j::nat) &#10233; (repeat_mset i u + m = repeat_mset j u + n) = (m = repeat_mset (j-i) u + n)&quot;</span>
<span class="gutterH"> 960 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff nat_eq_add_iff2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 961 </span>
<span class="gutter"> 962 </span><span class="syntax-KEYWORD1">lemma</span> mset_subseteq_add_iff1<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 963 </span>  <span class="syntax-LITERAL1">&quot;j &le; (i::nat) &#10233; (repeat_mset i u + m &sube;# repeat_mset j u + n) = (repeat_mset (i-j) u + m &sube;# n)&quot;</span>
<span class="gutter"> 964 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def nat_le_add_iff1<span class="syntax-OPERATOR">)</span>
<span class="gutterH"> 965 </span>
<span class="gutter"> 966 </span><span class="syntax-KEYWORD1">lemma</span> mset_subseteq_add_iff2<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 967 </span>  <span class="syntax-LITERAL1">&quot;i &le; (j::nat) &#10233; (repeat_mset i u + m &sube;# repeat_mset j u + n) = (m &sube;# repeat_mset (j-i) u + n)&quot;</span>
<span class="gutter"> 968 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> subseteq_mset_def nat_le_add_iff2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 969 </span>
<span class="gutterH"> 970 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_add_iff1<span class="syntax-OPERATOR">:</span>
<span class="gutter"> 971 </span>  <span class="syntax-LITERAL1">&quot;j &le; (i::nat) &#10233; (repeat_mset i u + m &sub;# repeat_mset j u + n) = (repeat_mset (i-j) u + m &sub;# n)&quot;</span>
<span class="gutter"> 972 </span>  <span class="syntax-KEYWORD1">unfolding</span> subset_mset_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_eq_add_iff1 mset_subseteq_add_iff1<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 973 </span>
<span class="gutter"> 974 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_add_iff2<span class="syntax-OPERATOR">:</span>
<span class="gutterH"> 975 </span>  <span class="syntax-LITERAL1">&quot;i &le; (j::nat) &#10233; (repeat_mset i u + m &sub;# repeat_mset j u + n) = (m &sub;# repeat_mset (j-i) u + n)&quot;</span>
<span class="gutter"> 976 </span>  <span class="syntax-KEYWORD1">unfolding</span> subset_mset_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_eq_add_iff2 mset_subseteq_add_iff2<span class="syntax-OPERATOR">)</span>
<span class="gutter"> 977 </span>
<span class="gutter"> 978 </span><span class="syntax-KEYWORD1">ML_file</span> <span class="syntax-LITERAL1">&quot;multiset_simprocs_util.ML&quot;</span>
<span class="gutter"> 979 </span><span class="syntax-KEYWORD1">ML_file</span> <span class="syntax-LITERAL1">&quot;multiset_simprocs.ML&quot;</span>
<span class="gutterH"> 980 </span>
<span class="gutter"> 981 </span><span class="syntax-KEYWORD1">simproc_setup</span> mseteq_cancel_numerals
<span class="gutter"> 982 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(l::'a multiset) + m = n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;(l::'a multiset) = m + n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 983 </span>   <span class="syntax-LITERAL1">&quot;add_mset a m = n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m = add_mset a n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 984 </span>   <span class="syntax-LITERAL1">&quot;replicate_mset p a = n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m = replicate_mset p a&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 985 </span>   <span class="syntax-LITERAL1">&quot;repeat_mset p m = n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m = repeat_mset p m&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">=</span>
<span class="gutter"> 986 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4">&gt;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 987 </span>
<span class="gutter"> 988 </span><span class="syntax-KEYWORD1">simproc_setup</span> msetless_cancel_numerals
<span class="gutter"> 989 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(l::'a multiset) + m &sub;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;(l::'a multiset) &sub;# m + n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 990 </span>   <span class="syntax-LITERAL1">&quot;add_mset a m &sub;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sub;# add_mset a n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 991 </span>   <span class="syntax-LITERAL1">&quot;replicate_mset p r &sub;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sub;# replicate_mset p r&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 992 </span>   <span class="syntax-LITERAL1">&quot;repeat_mset p m &sub;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sub;# repeat_mset p m&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">=</span>
<span class="gutter"> 993 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4">&gt;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter"> 994 </span>
<span class="gutterH"> 995 </span><span class="syntax-KEYWORD1">simproc_setup</span> msetle_cancel_numerals
<span class="gutter"> 996 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(l::'a multiset) + m &sube;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;(l::'a multiset) &sube;# m + n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 997 </span>   <span class="syntax-LITERAL1">&quot;add_mset a m &sube;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sube;# add_mset a n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 998 </span>   <span class="syntax-LITERAL1">&quot;replicate_mset p r &sube;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sube;# replicate_mset p r&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 999 </span>   <span class="syntax-LITERAL1">&quot;repeat_mset p m &sube;# n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m &sube;# repeat_mset p m&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">=</span>
<span class="gutterH">1000 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4">&gt;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1001 </span>
<span class="gutter">1002 </span><span class="syntax-KEYWORD1">simproc_setup</span> msetdiff_cancel_numerals
<span class="gutter">1003 </span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;((l::'a multiset) + m) - n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;(l::'a multiset) - (m + n)&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">1004 </span>   <span class="syntax-LITERAL1">&quot;add_mset a m - n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m - add_mset a n&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH">1005 </span>   <span class="syntax-LITERAL1">&quot;replicate_mset p r - n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m - replicate_mset p r&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">1006 </span>   <span class="syntax-LITERAL1">&quot;repeat_mset p m - n&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;m - repeat_mset p m&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">=</span>
<span class="gutter">1007 </span>  <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4">&gt;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1008 </span>
<span class="gutter">1009 </span>
<span class="gutterH">1010 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">C</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1011 </span>
<span class="gutter">1012 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>type<span class="syntax-OPERATOR">)</span> Inf
<span class="gutter">1013 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">1014 </span>
<span class="gutterH">1015 </span><span class="syntax-KEYWORD1">lift_definition</span> Inf_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset set &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">is</span>
<span class="gutter">1016 </span>  <span class="syntax-LITERAL1">&quot;&lambda;A i. if A = {} then 0 else Inf ((&lambda;f. f i) ` A)&quot;</span>
<span class="gutter">1017 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1018 </span>  <span class="syntax-KEYWORD3">fix</span> A <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; nat) set&quot;</span> <span class="syntax-KEYWORD3">assume</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x. x &isin; A &#10233; x &isin; multiset&quot;</span>
<span class="gutter">1019 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite {i. (if A = {} then 0 else Inf ((&lambda;f. f i) ` A)) &gt; 0}&quot;</span> <span class="syntax-KEYWORD1">unfolding</span> multiset_def
<span class="gutterH">1020 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;A = {}&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1021 </span>    <span class="syntax-KEYWORD3">case</span> False
<span class="gutter">1022 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> f <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;f &isin; A&quot;</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">1023 </span>    <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;{i. Inf ((&lambda;f. f i) ` A) &gt; 0} &sube; {i. f i &gt; 0}&quot;</span>
<span class="gutter">1024 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> less_le_trans<span class="syntax-OPERATOR">[</span>OF _ cInf_lower<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1025 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> * <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite &hellip;&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1026 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite {i. Inf ((&lambda;f. f i) ` A) &gt; 0}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1027 </span>    <span class="syntax-KEYWORD1">with</span> False <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1028 </span>  <span class="syntax-KEYWORD1">qed</span> simp_all
<span class="gutter">1029 </span>  <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;(&lambda;i. if A = {} then 0 else INF f:A. f i) &isin; multiset&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1030 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1031 </span>
<span class="gutter">1032 </span><span class="syntax-KEYWORD1">instance</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">1033 </span>
<span class="gutter">1034 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutterH">1035 </span>
<span class="gutter">1036 </span><span class="syntax-KEYWORD1">lemma</span> Inf_multiset_empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;Inf {} = {#}&quot;</span>
<span class="gutter">1037 </span>  <span class="syntax-KEYWORD1">by</span> transfer simp_all
<span class="gutter">1038 </span>
<span class="gutter">1039 </span><span class="syntax-KEYWORD1">lemma</span> count_Inf_multiset_nonempty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &ne; {} &#10233; count (Inf A) x = Inf ((&lambda;X. count X x) ` A)&quot;</span>
<span class="gutterH">1040 </span>  <span class="syntax-KEYWORD1">by</span> transfer simp_all
<span class="gutter">1041 </span>
<span class="gutter">1042 </span>
<span class="gutter">1043 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>type<span class="syntax-OPERATOR">)</span> Sup
<span class="gutter">1044 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutterH">1045 </span>
<span class="gutter">1046 </span><span class="syntax-KEYWORD1">definition</span> Sup_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset set &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">1047 </span>  <span class="syntax-LITERAL1">&quot;Sup_multiset A = (if A &ne; {} &and; subset_mset.bdd_above A then</span>
<span class="gutter">1048 </span><span class="syntax-LITERAL1">           Abs_multiset (&lambda;i. Sup ((&lambda;X. count X i) ` A)) else {#})&quot;</span>
<span class="gutter">1049 </span>
<span class="gutterH">1050 </span><span class="syntax-KEYWORD1">lemma</span> Sup_multiset_empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;Sup {} = {#}&quot;</span>
<span class="gutter">1051 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Sup_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1052 </span>
<span class="gutter">1053 </span><span class="syntax-KEYWORD1">lemma</span> Sup_multiset_unbounded<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not;subset_mset.bdd_above A &#10233; Sup A = {#}&quot;</span>
<span class="gutter">1054 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Sup_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1055 </span>
<span class="gutter">1056 </span><span class="syntax-KEYWORD1">instance</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">1057 </span>
<span class="gutter">1058 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">1059 </span>
<span class="gutterH">1060 </span>
<span class="gutter">1061 </span><span class="syntax-KEYWORD1">lemma</span> bdd_above_multiset_imp_bdd_above_count<span class="syntax-OPERATOR">:</span>
<span class="gutter">1062 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above (A :: 'a multiset set)&quot;</span>
<span class="gutter">1063 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;bdd_above ((&lambda;X. count X x) ` A)&quot;</span>
<span class="gutter">1064 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">1065 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD3">obtain</span> Y <span class="syntax-KEYWORD2">where</span> Y<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&forall;X&isin;A. X &sube;# Y&quot;</span>
<span class="gutter">1066 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subset_mset.bdd_above_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1067 </span>  <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;count X x &le; count Y x&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> X
<span class="gutter">1068 </span>    <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> mset_subset_eq_count<span class="syntax-OPERATOR">)</span>
<span class="gutter">1069 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro bdd_aboveI<span class="syntax-OPERATOR">[</span>of _ <span class="syntax-LITERAL1">&quot;count Y x&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1070 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1071 </span>
<span class="gutter">1072 </span><span class="syntax-KEYWORD1">lemma</span> bdd_above_multiset_imp_finite_support<span class="syntax-OPERATOR">:</span>
<span class="gutter">1073 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above (A :: 'a multiset set)&quot;</span>
<span class="gutter">1074 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;finite (&#8899;X&isin;A. {x. count X x &gt; 0})&quot;</span>
<span class="gutterH">1075 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1076 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD3">obtain</span> Y <span class="syntax-KEYWORD2">where</span> Y<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&forall;X&isin;A. X &sube;# Y&quot;</span>
<span class="gutter">1077 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subset_mset.bdd_above_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1078 </span>  <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;count X x &le; count Y x&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> X x
<span class="gutter">1079 </span>    <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> mset_subset_eq_count<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1080 </span>  <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;(&#8899;X&isin;A. {x. count X x &gt; 0}) &sube; {x. count Y x &gt; 0}&quot;</span>
<span class="gutter">1081 </span>    <span class="syntax-KEYWORD1">by</span> safe <span class="syntax-OPERATOR">(</span>erule less_le_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">1082 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite &hellip;&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1083 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1084 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1085 </span>
<span class="gutter">1086 </span><span class="syntax-KEYWORD1">lemma</span> Sup_multiset_in_multiset<span class="syntax-OPERATOR">:</span>
<span class="gutter">1087 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1088 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;(&lambda;i. SUP X:A. count X i) &isin; multiset&quot;</span>
<span class="gutter">1089 </span>  <span class="syntax-KEYWORD1">unfolding</span> multiset_def
<span class="gutterH">1090 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1091 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{i. Sup ((&lambda;X. count X i) ` A) &gt; 0} &sube; (&#8899;X&isin;A. {i. 0 &lt; count X i})&quot;</span>
<span class="gutter">1092 </span>  <span class="syntax-KEYWORD1">proof</span> safe
<span class="gutter">1093 </span>    <span class="syntax-KEYWORD3">fix</span> i <span class="syntax-KEYWORD3">assume</span> pos<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(SUP X:A. count X i) &gt; 0&quot;</span>
<span class="gutter">1094 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;i &isin; (&#8899;X&isin;A. {i. 0 &lt; count X i})&quot;</span>
<span class="gutterH">1095 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span>
<span class="gutter">1096 </span>      <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;i &notin; (&#8899;X&isin;A. {i. 0 &lt; count X i})&quot;</span>
<span class="gutter">1097 </span>      <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;&forall;X&isin;A. count X i &le; 0&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1098 </span>      <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(SUP X:A. count X i) &le; 0&quot;</span>
<span class="gutter">1099 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro cSup_least bdd_above_multiset_imp_bdd_above_count<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1100 </span>      <span class="syntax-KEYWORD1">with</span> pos <span class="syntax-KEYWORD3">show</span> False <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1101 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1102 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1103 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite &hellip;&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule bdd_above_multiset_imp_finite_support<span class="syntax-OPERATOR">)</span>
<span class="gutter">1104 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;finite {i. Sup ((&lambda;X. count X i) ` A) &gt; 0}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1105 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1106 </span>
<span class="gutter">1107 </span><span class="syntax-KEYWORD1">lemma</span> count_Sup_multiset_nonempty<span class="syntax-OPERATOR">:</span>
<span class="gutter">1108 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1109 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;count (Sup A) x = (SUP X:A. count X x)&quot;</span>
<span class="gutterH">1110 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Sup_multiset_def Abs_multiset_inverse Sup_multiset_in_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1111 </span>
<span class="gutter">1112 </span>
<span class="gutter">1113 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> conditionally_complete_lattice Inf Sup <span class="syntax-LITERAL1">&quot;op &cap;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &cup;#&quot;</span>
<span class="gutter">1114 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutterH">1115 </span>  <span class="syntax-KEYWORD3">fix</span> X <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD2">and</span> A
<span class="gutter">1116 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span>
<span class="gutter">1117 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;Inf A &sube;# X&quot;</span>
<span class="gutter">1118 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1119 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutterH">1120 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1121 </span>    <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;count (Inf A) x = (INF X:A. count X x)&quot;</span>
<span class="gutter">1122 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> count_Inf_multiset_nonempty<span class="syntax-OPERATOR">)</span>
<span class="gutter">1123 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; &le; count X x&quot;</span>
<span class="gutter">1124 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro cInf_lower<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">1125 </span>    <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count (Inf A) x &le; count X x&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1126 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1127 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1128 </span>  <span class="syntax-KEYWORD3">fix</span> X <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD2">and</span> A
<span class="gutter">1129 </span>  <span class="syntax-KEYWORD3">assume</span> nonempty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD2">and</span> le<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;Y. Y &isin; A &#10233; X &sube;# Y&quot;</span>
<span class="gutterH">1130 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;X &sube;# Inf A&quot;</span>
<span class="gutter">1131 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1132 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter">1133 </span>    <span class="syntax-KEYWORD1">from</span> nonempty <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count X x &le; (INF X:A. count X x)&quot;</span>
<span class="gutter">1134 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro cInf_greatest<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> mset_subset_eq_count le<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1135 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> nonempty <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = count (Inf A) x&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> count_Inf_multiset_nonempty<span class="syntax-OPERATOR">)</span>
<span class="gutter">1136 </span>    <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count X x &le; count (Inf A) x&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1137 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1138 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1139 </span>  <span class="syntax-KEYWORD3">fix</span> X <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD2">and</span> A
<span class="gutterH">1140 </span>  <span class="syntax-KEYWORD3">assume</span> X<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">and</span> bdd<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1141 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;X &sube;# Sup A&quot;</span>
<span class="gutter">1142 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1143 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter">1144 </span>    <span class="syntax-KEYWORD1">from</span> X <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">1145 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count X x &le; (SUP X:A. count X x)&quot;</span>
<span class="gutter">1146 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro cSUP_upper X bdd_above_multiset_imp_bdd_above_count bdd<span class="syntax-OPERATOR">)</span>
<span class="gutter">1147 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> count_Sup_multiset_nonempty<span class="syntax-OPERATOR">[</span>OF <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&ne;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">&rsaquo;</span> bdd<span class="syntax-OPERATOR">]</span>
<span class="gutter">1148 </span>      <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(SUP X:A. count X x) = count (Sup A) x&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1149 </span>    <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count X x &le; count (Sup A) x&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutterH">1150 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1151 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1152 </span>  <span class="syntax-KEYWORD3">fix</span> X <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD2">and</span> A
<span class="gutter">1153 </span>  <span class="syntax-KEYWORD3">assume</span> nonempty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD2">and</span> ge<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;Y. Y &isin; A &#10233; Y &sube;# X&quot;</span>
<span class="gutter">1154 </span>  <span class="syntax-KEYWORD1">from</span> ge <span class="syntax-KEYWORD1">have</span> bdd<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule subset_mset.bdd_aboveI<span class="syntax-OPERATOR">[</span>of _ X<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1155 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;Sup A &sube;# X&quot;</span>
<span class="gutter">1156 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule mset_subset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1157 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter">1158 </span>    <span class="syntax-KEYWORD1">from</span> count_Sup_multiset_nonempty<span class="syntax-OPERATOR">[</span>OF <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&ne;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">&rsaquo;</span> bdd<span class="syntax-OPERATOR">]</span>
<span class="gutter">1159 </span>      <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count (Sup A) x = (SUP X:A. count X x)&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutterH">1160 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> nonempty <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; &le; count X x&quot;</span>
<span class="gutter">1161 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro cSup_least<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> mset_subset_eq_count ge<span class="syntax-OPERATOR">)</span>
<span class="gutter">1162 </span>    <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count (Sup A) x &le; count X x&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1163 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1164 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1165 </span>
<span class="gutter">1166 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_Inf<span class="syntax-OPERATOR">:</span>
<span class="gutter">1167 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span>
<span class="gutter">1168 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;set_mset (Inf A) = (&#8898;X&isin;A. set_mset X)&quot;</span>
<span class="gutter">1169 </span><span class="syntax-KEYWORD1">proof</span> safe
<span class="gutterH">1170 </span>  <span class="syntax-KEYWORD3">fix</span> x X <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;x &isin;# Inf A&quot;</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span>
<span class="gutter">1171 </span>  <span class="syntax-KEYWORD1">hence</span> nonempty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> Inf_multiset_empty<span class="syntax-OPERATOR">)</span>
<span class="gutter">1172 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{#x#} &sube;# Inf A&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1173 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; &sube;# X&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule subset_mset.cInf_lower<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1174 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;x &isin;# X&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1175 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1176 </span>  <span class="syntax-KEYWORD3">fix</span> x <span class="syntax-KEYWORD3">assume</span> x<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin; (&#8898;X&isin;A. set_mset X)&quot;</span>
<span class="gutter">1177 </span>  <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;{#x#} &sube;# X&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> X <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1178 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD2">and</span> this <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{#x#} &sube;# Inf A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule subset_mset.cInf_greatest<span class="syntax-OPERATOR">)</span>
<span class="gutter">1179 </span>  <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;x &isin;# Inf A&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1180 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1181 </span>
<span class="gutter">1182 </span><span class="syntax-KEYWORD1">lemma</span> in_Inf_multiset_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter">1183 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span>
<span class="gutter">1184 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;x &isin;# Inf A &#10231; (&forall;X&isin;A. x &isin;# X)&quot;</span>
<span class="gutterH">1185 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1186 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;set_mset (Inf A) = (&#8898;X&isin;A. set_mset X)&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule set_mset_Inf<span class="syntax-OPERATOR">)</span>
<span class="gutter">1187 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin; &hellip; &#10231; (&forall;X&isin;A. x &isin;# X)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1188 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1189 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1190 </span>
<span class="gutter">1191 </span><span class="syntax-KEYWORD1">lemma</span> in_Inf_multisetD<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# Inf A &#10233; X &isin; A &#10233; x &isin;# X&quot;</span>
<span class="gutter">1192 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>subst <span class="syntax-OPERATOR">(</span>asm<span class="syntax-OPERATOR">)</span> in_Inf_multiset_iff<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1193 </span>
<span class="gutter">1194 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_Sup<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1195 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1196 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;set_mset (Sup A) = (&#8899;X&isin;A. set_mset X)&quot;</span>
<span class="gutter">1197 </span><span class="syntax-KEYWORD1">proof</span> safe
<span class="gutter">1198 </span>  <span class="syntax-KEYWORD3">fix</span> x <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;x &isin;# Sup A&quot;</span>
<span class="gutter">1199 </span>  <span class="syntax-KEYWORD1">hence</span> nonempty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &ne; {}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> Sup_multiset_empty<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1200 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;x &isin; (&#8899;X&isin;A. set_mset X)&quot;</span>
<span class="gutter">1201 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span>
<span class="gutter">1202 </span>    <span class="syntax-KEYWORD3">assume</span> x<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &notin; (&#8899;X&isin;A. set_mset X)&quot;</span>
<span class="gutter">1203 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count X x &le; count (Sup A) x&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> X x
<span class="gutter">1204 </span>      <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro mset_subset_eq_count subset_mset.cSup_upper assms<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1205 </span>    <span class="syntax-KEYWORD1">with</span> x <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;X &sube;# Sup A - {#x#}&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> X
<span class="gutter">1206 </span>      <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subseteq_mset_def algebra_simps not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1207 </span>    <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;Sup A &sube;# Sup A - {#x#}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro subset_mset.cSup_least nonempty<span class="syntax-OPERATOR">)</span>
<span class="gutter">1208 </span>    <span class="syntax-KEYWORD1">with</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> False
<span class="gutter">1209 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subseteq_mset_def count_greater_zero_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span>
<span class="gutterH">1210 </span>               simp del<span class="syntax-OPERATOR">:</span> count_greater_zero_iff dest<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> spec<span class="syntax-OPERATOR">[</span>of _ x<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1211 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1212 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1213 </span>  <span class="syntax-KEYWORD3">fix</span> x X <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;x &isin; set_mset X&quot;</span> <span class="syntax-LITERAL1">&quot;X &isin; A&quot;</span>
<span class="gutter">1214 </span>  <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;{#x#} &sube;# X&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">1215 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;X &sube;# Sup A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro subset_mset.cSup_upper <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> assms<span class="syntax-OPERATOR">)</span>
<span class="gutter">1216 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;x &isin; set_mset (Sup A)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1217 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1218 </span>
<span class="gutter">1219 </span><span class="syntax-KEYWORD1">lemma</span> in_Sup_multiset_iff<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1220 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1221 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;x &isin;# Sup A &#10231; (&exist;X&isin;A. x &isin;# X)&quot;</span>
<span class="gutter">1222 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1223 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;set_mset (Sup A) = (&#8899;X&isin;A. set_mset X)&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule set_mset_Sup<span class="syntax-OPERATOR">)</span>
<span class="gutter">1224 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin; &hellip; &#10231; (&exist;X&isin;A. x &isin;# X)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1225 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1226 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1227 </span>
<span class="gutter">1228 </span><span class="syntax-KEYWORD1">lemma</span> in_Sup_multisetD<span class="syntax-OPERATOR">:</span>
<span class="gutter">1229 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;x &isin;# Sup A&quot;</span>
<span class="gutterH">1230 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;&exist;X&isin;A. x &isin;# X&quot;</span>
<span class="gutter">1231 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1232 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;subset_mset.bdd_above A&quot;</span>
<span class="gutter">1233 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule ccontr<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>insert assms<span class="syntax-OPERATOR">,</span> simp_all add<span class="syntax-OPERATOR">:</span> Sup_multiset_unbounded<span class="syntax-OPERATOR">)</span>
<span class="gutter">1234 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> in_Sup_multiset_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1235 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1236 </span>
<span class="gutter">1237 </span><span class="syntax-KEYWORD1">interpretation</span> subset_mset<span class="syntax-OPERATOR">:</span> distrib_lattice <span class="syntax-LITERAL1">&quot;op &cap;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sube;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &sub;#&quot;</span> <span class="syntax-LITERAL1">&quot;op &cup;#&quot;</span>
<span class="gutter">1238 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1239 </span>  <span class="syntax-KEYWORD3">fix</span> A B C <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutterH">1240 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;A &cup;# (B &cap;# C) = A &cup;# B &cap;# (A &cup;# C)&quot;</span>
<span class="gutter">1241 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro multiset_eqI<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1242 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1243 </span>
<span class="gutter">1244 </span>
<span class="gutterH">1245 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1246 </span>
<span class="gutter">1247 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1248 </span>
<span class="gutter">1249 </span><span class="syntax-KEYWORD1">lift_definition</span> filter_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; bool) &rArr; 'a multiset &rArr; 'a multiset&quot;</span>
<span class="gutterH">1250 </span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;&lambda;P M. &lambda;x. if P x then M x else 0&quot;</span>
<span class="gutter">1251 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule filter_preserves_multiset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1252 </span>
<span class="gutter">1253 </span><span class="syntax-KEYWORD1">syntax</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter">1254 </span>  <span class="syntax-LITERAL1">&quot;_MCollect&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a multiset &rArr; bool &rArr; 'a multiset&quot;</span>    <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(1{#_ :# _./ _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1255 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutter">1256 </span>  <span class="syntax-LITERAL1">&quot;_MCollect&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'a multiset &rArr; bool &rArr; 'a multiset&quot;</span>    <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(1{#_ &isin;# _./ _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1257 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter">1258 </span>  <span class="syntax-LITERAL1">&quot;{#x &isin;# M. P#}&quot;</span> <span class="syntax-OPERATOR">==</span> <span class="syntax-LITERAL1">&quot;CONST filter_mset (&lambda;x. P) M&quot;</span>
<span class="gutter">1259 </span>
<span class="gutterH">1260 </span><span class="syntax-KEYWORD1">lemma</span> count_filter_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1261 </span>  <span class="syntax-LITERAL1">&quot;count (filter_mset P M) a = (if P a then count M a else 0)&quot;</span>
<span class="gutter">1262 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> filter_mset.rep_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">1263 </span>
<span class="gutter">1264 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_filter <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">1265 </span>  <span class="syntax-LITERAL1">&quot;set_mset (filter_mset P M) = {a &isin; set_mset M. P a}&quot;</span>
<span class="gutter">1266 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> set_eq_iff count_greater_zero_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> count_filter_mset<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1267 </span>
<span class="gutter">1268 </span><span class="syntax-KEYWORD1">lemma</span> filter_empty_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P {#} = {#}&quot;</span>
<span class="gutter">1269 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutterH">1270 </span>
<span class="gutter">1271 </span><span class="syntax-KEYWORD1">lemma</span> filter_single_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P {#x#} = (if P x then {#x#} else {#})&quot;</span>
<span class="gutter">1272 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1273 </span>
<span class="gutter">1274 </span><span class="syntax-KEYWORD1">lemma</span> filter_union_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P (M + N) = filter_mset P M + filter_mset P N&quot;</span>
<span class="gutterH">1275 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1276 </span>
<span class="gutter">1277 </span><span class="syntax-KEYWORD1">lemma</span> filter_diff_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P (M - N) = filter_mset P M - filter_mset P N&quot;</span>
<span class="gutter">1278 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1279 </span>
<span class="gutterH">1280 </span><span class="syntax-KEYWORD1">lemma</span> filter_inter_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P (M &cap;# N) = filter_mset P M &cap;# filter_mset P N&quot;</span>
<span class="gutter">1281 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1282 </span>
<span class="gutter">1283 </span><span class="syntax-KEYWORD1">lemma</span> filter_sup_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P (A &cup;# B) = filter_mset P A &cup;# filter_mset P B&quot;</span>
<span class="gutter">1284 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> simp
<span class="gutterH">1285 </span>
<span class="gutter">1286 </span><span class="syntax-KEYWORD1">lemma</span> filter_mset_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1287 </span>   <span class="syntax-LITERAL1">&quot;filter_mset P (add_mset x A) =</span>
<span class="gutter">1288 </span><span class="syntax-LITERAL1">     (if P x then add_mset x (filter_mset P A) else filter_mset P A)&quot;</span>
<span class="gutter">1289 </span>   <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1290 </span>
<span class="gutter">1291 </span><span class="syntax-KEYWORD1">lemma</span> multiset_filter_subset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset f M &sube;# M&quot;</span>
<span class="gutter">1292 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_subset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1293 </span>
<span class="gutter">1294 </span><span class="syntax-KEYWORD1">lemma</span> multiset_filter_mono<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1295 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &sube;# B&quot;</span>
<span class="gutter">1296 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;filter_mset f A &sube;# filter_mset f B&quot;</span>
<span class="gutter">1297 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1298 </span>  <span class="syntax-KEYWORD1">from</span> assms<span class="syntax-OPERATOR">[</span>unfolded mset_subset_eq_exists_conv<span class="syntax-OPERATOR">]</span>
<span class="gutter">1299 </span>  <span class="syntax-KEYWORD3">obtain</span> C <span class="syntax-KEYWORD2">where</span> B<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B = A + C&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">1300 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">unfolding</span> B <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1301 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1302 </span>
<span class="gutter">1303 </span><span class="syntax-KEYWORD1">lemma</span> filter_mset_eq_conv<span class="syntax-OPERATOR">:</span>
<span class="gutter">1304 </span>  <span class="syntax-LITERAL1">&quot;filter_mset P M = N &#10231; N &sube;# M &and; (&forall;b&isin;#N. P b) &and; (&forall;a&isin;#M - N. &not; P a)&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?P &#10231; ?Q&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1305 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1306 </span>  <span class="syntax-KEYWORD3">assume</span> ?P <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?Q <span class="syntax-KEYWORD1">by</span> auto <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff in_diff_count<span class="syntax-OPERATOR">)</span>
<span class="gutter">1307 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1308 </span>  <span class="syntax-KEYWORD3">assume</span> ?Q
<span class="gutter">1309 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> Q <span class="syntax-KEYWORD2">where</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = N + Q&quot;</span>
<span class="gutterH">1310 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> mset_subset_eq_exists_conv<span class="syntax-OPERATOR">)</span>
<span class="gutter">1311 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> MN<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M - N = Q&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1312 </span>  <span class="syntax-KEYWORD3">show</span> ?P
<span class="gutter">1313 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1314 </span>    <span class="syntax-KEYWORD3">fix</span> a
<span class="gutterH">1315 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">Q</span><span class="syntax-COMMENT4">&rsaquo;</span> MN <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; P a &#10233; a &notin;# N&quot;</span> <span class="syntax-LITERAL1">&quot;P a &#10233; a &notin;# Q&quot;</span>
<span class="gutter">1316 </span>      <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1317 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;count (filter_mset P M) a = count N a&quot;</span>
<span class="gutter">1318 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;a &isin;# M&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1319 </span>      <span class="syntax-KEYWORD3">case</span> True
<span class="gutterH">1320 </span>      <span class="syntax-KEYWORD1">with</span> * <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">1321 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> not_in_iff M<span class="syntax-OPERATOR">)</span>
<span class="gutter">1322 </span>    <span class="syntax-KEYWORD1">next</span>
<span class="gutter">1323 </span>      <span class="syntax-KEYWORD3">case</span> False <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;count M a = 0&quot;</span>
<span class="gutter">1324 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1325 </span>      <span class="syntax-KEYWORD1">with</span> M <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1326 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1327 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1328 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1329 </span>
<span class="gutterH">1330 </span><span class="syntax-KEYWORD1">lemma</span> filter_filter_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset P (filter_mset Q M) = {#x &isin;# M. Q x &and; P x#}&quot;</span>
<span class="gutter">1331 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1332 </span>
<span class="gutter">1333 </span><span class="syntax-KEYWORD1">lemma</span>
<span class="gutter">1334 </span>  filter_mset_True<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#y &isin;# M. True#} = M&quot;</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutterH">1335 </span>  filter_mset_False<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#y &isin;# M. False#} = {#}&quot;</span>
<span class="gutter">1336 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1337 </span>
<span class="gutter">1338 </span>
<span class="gutter">1339 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">1340 </span>
<span class="gutter">1341 </span><span class="syntax-KEYWORD1">definition</span> wcount <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;wcount f M = (&lambda;x. count M x * Suc (f x))&quot;</span>
<span class="gutter">1342 </span>
<span class="gutter">1343 </span><span class="syntax-KEYWORD1">lemma</span> wcount_union<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;wcount f (M + N) a = wcount f M a + wcount f N a&quot;</span>
<span class="gutter">1344 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> wcount_def add_mult_distrib<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1345 </span>
<span class="gutter">1346 </span><span class="syntax-KEYWORD1">lemma</span> wcount_add_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">1347 </span>  <span class="syntax-LITERAL1">&quot;wcount f (add_mset x M) a = (if x = a then Suc (f a) else 0) + wcount f M a&quot;</span>
<span class="gutter">1348 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ M<span class="syntax-OPERATOR">]</span> wcount_union <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> wcount_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1349 </span>
<span class="gutterH">1350 </span><span class="syntax-KEYWORD1">definition</span> size_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; nat) &rArr; 'a multiset &rArr; nat&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">1351 </span>  <span class="syntax-LITERAL1">&quot;size_multiset f M = sum (wcount f M) (set_mset M)&quot;</span>
<span class="gutter">1352 </span>
<span class="gutter">1353 </span><span class="syntax-KEYWORD1">lemmas</span> size_multiset_eq <span class="syntax-OPERATOR">=</span> size_multiset_def<span class="syntax-OPERATOR">[</span>unfolded wcount_def<span class="syntax-OPERATOR">]</span>
<span class="gutter">1354 </span>
<span class="gutterH">1355 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>type<span class="syntax-OPERATOR">)</span> size
<span class="gutter">1356 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">1357 </span>
<span class="gutter">1358 </span><span class="syntax-KEYWORD1">definition</span> size_multiset <span class="syntax-KEYWORD2">where</span>
<span class="gutter">1359 </span>  size_multiset_overloaded_def<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size_multiset = Multiset.size_multiset (&lambda;_. 0)&quot;</span>
<span class="gutterH">1360 </span><span class="syntax-KEYWORD1">instance</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">1361 </span>
<span class="gutter">1362 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">1363 </span>
<span class="gutter">1364 </span><span class="syntax-KEYWORD1">lemmas</span> size_multiset_overloaded_eq <span class="syntax-OPERATOR">=</span>
<span class="gutterH">1365 </span>  size_multiset_overloaded_def<span class="syntax-OPERATOR">[</span>THEN fun_cong<span class="syntax-OPERATOR">,</span> unfolded size_multiset_eq<span class="syntax-OPERATOR">,</span> simplified<span class="syntax-OPERATOR">]</span>
<span class="gutter">1366 </span>
<span class="gutter">1367 </span><span class="syntax-KEYWORD1">lemma</span> size_multiset_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size_multiset f {#} = 0&quot;</span>
<span class="gutter">1368 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1369 </span>
<span class="gutterH">1370 </span><span class="syntax-KEYWORD1">lemma</span> size_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size {#} = 0&quot;</span>
<span class="gutter">1371 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1372 </span>
<span class="gutter">1373 </span><span class="syntax-KEYWORD1">lemma</span> size_multiset_single <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size_multiset f {#b#} = Suc (f b)&quot;</span>
<span class="gutter">1374 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_eq<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1375 </span>
<span class="gutter">1376 </span><span class="syntax-KEYWORD1">lemma</span> size_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size {#b#} = 1&quot;</span>
<span class="gutter">1377 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_def size_multiset_single<span class="syntax-OPERATOR">)</span>
<span class="gutter">1378 </span>
<span class="gutter">1379 </span><span class="syntax-KEYWORD1">lemma</span> sum_wcount_Int<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1380 </span>  <span class="syntax-LITERAL1">&quot;finite A &#10233; sum (wcount f N) (A &cap; set_mset N) = sum (wcount f N) A&quot;</span>
<span class="gutter">1381 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span>
<span class="gutter">1382 </span>    <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> Int_insert_left wcount_def count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1383 </span>
<span class="gutter">1384 </span><span class="syntax-KEYWORD1">lemma</span> size_multiset_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">1385 </span>  <span class="syntax-LITERAL1">&quot;size_multiset f (M + N::'a multiset) = size_multiset f M + size_multiset f N&quot;</span>
<span class="gutter">1386 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_def sum_Un_nat sum.distrib sum_wcount_Int wcount_union<span class="syntax-OPERATOR">)</span>
<span class="gutter">1387 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>subst Int_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">1388 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sum_wcount_Int<span class="syntax-OPERATOR">)</span>
<span class="gutter">1389 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutterH">1390 </span>
<span class="gutter">1391 </span><span class="syntax-KEYWORD1">lemma</span> size_multiset_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1392 </span>  <span class="syntax-LITERAL1">&quot;size_multiset f (add_mset a M) = Suc (f a) + size_multiset f M&quot;</span>
<span class="gutter">1393 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of _ M<span class="syntax-OPERATOR">]</span> size_multiset_union <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> size_multiset_single<span class="syntax-OPERATOR">)</span>
<span class="gutter">1394 </span>
<span class="gutterH">1395 </span><span class="syntax-KEYWORD1">lemma</span> size_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (add_mset a A) = Suc (size A)&quot;</span>
<span class="gutter">1396 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_def wcount_add_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1397 </span>
<span class="gutter">1398 </span><span class="syntax-KEYWORD1">lemma</span> size_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (M + N::'a multiset) = size M + size N&quot;</span>
<span class="gutter">1399 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1400 </span>
<span class="gutter">1401 </span><span class="syntax-KEYWORD1">lemma</span> size_multiset_eq_0_iff_empty <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1402 </span>  <span class="syntax-LITERAL1">&quot;size_multiset f M = 0 &#10231; M = {#}&quot;</span>
<span class="gutter">1403 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> size_multiset_eq count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1404 </span>
<span class="gutterH">1405 </span><span class="syntax-KEYWORD1">lemma</span> size_eq_0_iff_empty <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(size M = 0) = (M = {#})&quot;</span>
<span class="gutter">1406 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1407 </span>
<span class="gutter">1408 </span><span class="syntax-KEYWORD1">lemma</span> nonempty_has_size<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(S &ne; {#}) = (0 &lt; size S)&quot;</span>
<span class="gutter">1409 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis gr0I gr_implies_not0 size_empty size_eq_0_iff_empty<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1410 </span>
<span class="gutter">1411 </span><span class="syntax-KEYWORD1">lemma</span> size_eq_Suc_imp_elem<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size M = Suc n &#10233; &exist;a. a &isin;# M&quot;</span>
<span class="gutter">1412 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>unfold size_multiset_overloaded_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">1413 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>drule sum_SucD<span class="syntax-OPERATOR">)</span>
<span class="gutter">1414 </span><span class="syntax-KEYWORD1">apply</span> auto
<span class="gutterH">1415 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">1416 </span>
<span class="gutter">1417 </span><span class="syntax-KEYWORD1">lemma</span> size_eq_Suc_imp_eq_union<span class="syntax-OPERATOR">:</span>
<span class="gutter">1418 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;size M = Suc n&quot;</span>
<span class="gutter">1419 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;a N. M = add_mset a N&quot;</span>
<span class="gutterH">1420 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1421 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD3">obtain</span> a <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;a &isin;# M&quot;</span>
<span class="gutter">1422 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>erule size_eq_Suc_imp_elem <span class="syntax-OPERATOR">[</span>THEN exE<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1423 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M = add_mset a (M - {#a#})&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1424 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">1425 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1426 </span>
<span class="gutter">1427 </span><span class="syntax-KEYWORD1">lemma</span> size_mset_mono<span class="syntax-OPERATOR">:</span>
<span class="gutter">1428 </span>  <span class="syntax-KEYWORD2">fixes</span> A B <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter">1429 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &sube;# B&quot;</span>
<span class="gutterH">1430 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;size A &le; size B&quot;</span>
<span class="gutter">1431 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1432 </span>  <span class="syntax-KEYWORD1">from</span> assms<span class="syntax-OPERATOR">[</span>unfolded mset_subset_eq_exists_conv<span class="syntax-OPERATOR">]</span>
<span class="gutter">1433 </span>  <span class="syntax-KEYWORD3">obtain</span> C <span class="syntax-KEYWORD2">where</span> B<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B = A + C&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1434 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">unfolding</span> B <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct C<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1435 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1436 </span>
<span class="gutter">1437 </span><span class="syntax-KEYWORD1">lemma</span> size_filter_mset_lesseq<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (filter_mset f M) &le; size M&quot;</span>
<span class="gutter">1438 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule size_mset_mono<span class="syntax-OPERATOR">[</span>OF multiset_filter_subset<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1439 </span>
<span class="gutterH">1440 </span><span class="syntax-KEYWORD1">lemma</span> size_Diff_submset<span class="syntax-OPERATOR">:</span>
<span class="gutter">1441 </span>  <span class="syntax-LITERAL1">&quot;M &sube;# M' &#10233; size (M' - M) = size M' - size(M::'a multiset)&quot;</span>
<span class="gutter">1442 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_diff_cancel_left' size_union mset_subset_eq_exists_conv<span class="syntax-OPERATOR">)</span>
<span class="gutter">1443 </span>
<span class="gutter">1444 </span>
<span class="gutterH">1445 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1446 </span>
<span class="gutter">1447 </span><span class="syntax-KEYWORD1">theorem</span> multiset_induct <span class="syntax-OPERATOR">[</span>case_names empty add<span class="syntax-OPERATOR">,</span> induct type<span class="syntax-OPERATOR">:</span> multiset<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1448 </span>  <span class="syntax-KEYWORD2">assumes</span> empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;P {#}&quot;</span>
<span class="gutter">1449 </span>  <span class="syntax-KEYWORD2">assumes</span> add<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x M. P M &#10233; P (add_mset x M)&quot;</span>
<span class="gutterH">1450 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;P M&quot;</span>
<span class="gutter">1451 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct n <span class="syntax-OPERATOR">&equiv;</span> <span class="syntax-LITERAL1">&quot;size M&quot;</span> arbitrary<span class="syntax-OPERATOR">:</span> M<span class="syntax-OPERATOR">)</span>
<span class="gutter">1452 </span>  <span class="syntax-KEYWORD3">case</span> 0 <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;P M&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> empty<span class="syntax-OPERATOR">)</span>
<span class="gutter">1453 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1454 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Suc k<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1455 </span>  <span class="syntax-KEYWORD3">obtain</span> N x <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset x N&quot;</span>
<span class="gutter">1456 </span>    <span class="syntax-KEYWORD1">using</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span>
<span class="gutter">1457 </span>    <span class="syntax-KEYWORD1">using</span> size_eq_Suc_imp_eq_union <span class="syntax-KEYWORD1">by</span> fast
<span class="gutter">1458 </span>  <span class="syntax-KEYWORD1">with</span> Suc add <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;P M&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1459 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1460 </span>
<span class="gutter">1461 </span><span class="syntax-KEYWORD1">lemma</span> multi_nonempty_split<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M &ne; {#} &#10233; &exist;A a. M = add_mset a A&quot;</span>
<span class="gutter">1462 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1463 </span>
<span class="gutter">1464 </span><span class="syntax-KEYWORD1">lemma</span> multiset_cases <span class="syntax-OPERATOR">[</span>cases type<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">1465 </span>  <span class="syntax-KEYWORD2">obtains</span> <span class="syntax-OPERATOR">(</span>empty<span class="syntax-OPERATOR">)</span> <span class="syntax-LITERAL1">&quot;M = {#}&quot;</span>
<span class="gutter">1466 </span>    <span class="syntax-OPERATOR">|</span> <span class="syntax-OPERATOR">(</span>add<span class="syntax-OPERATOR">)</span> x N <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset x N&quot;</span>
<span class="gutter">1467 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1468 </span>
<span class="gutter">1469 </span><span class="syntax-KEYWORD1">lemma</span> multi_drop_mem_not_eq<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;c &isin;# B &#10233; B - {#c#} &ne; B&quot;</span>
<span class="gutterH">1470 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;B = {#}&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> multi_member_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">1471 </span>
<span class="gutter">1472 </span><span class="syntax-KEYWORD1">lemma</span> multiset_partition<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = {# x&isin;#M. P x #} + {# x&isin;#M. &not; P x #}&quot;</span>
<span class="gutter">1473 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>subst multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1474 </span><span class="syntax-KEYWORD1">apply</span> auto
<span class="gutterH">1475 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">1476 </span>
<span class="gutter">1477 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_size<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) &sub;# B &#10233; size A &lt; size B&quot;</span>
<span class="gutter">1478 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct A arbitrary<span class="syntax-OPERATOR">:</span> B<span class="syntax-OPERATOR">)</span>
<span class="gutter">1479 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>empty M<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1480 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M &ne; {#}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subset_mset.zero_less_iff_neq_zero<span class="syntax-OPERATOR">)</span>
<span class="gutter">1481 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> M' x <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset x M'&quot;</span>
<span class="gutter">1482 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> multi_nonempty_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">1483 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1484 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">1485 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>add x S T<span class="syntax-OPERATOR">)</span>
<span class="gutter">1486 </span>  <span class="syntax-KEYWORD1">have</span> IH<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;B. S &sub;# B &#10233; size S &lt; size B&quot;</span> <span class="syntax-KEYWORD1">by</span> fact
<span class="gutter">1487 </span>  <span class="syntax-KEYWORD1">have</span> SxsubT<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x S &sub;# T&quot;</span> <span class="syntax-KEYWORD1">by</span> fact
<span class="gutter">1488 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin;# T&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;S &sub;# T&quot;</span>
<span class="gutter">1489 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> mset_subset_insertD<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1490 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> T' <span class="syntax-KEYWORD2">where</span> T<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;T = add_mset x T'&quot;</span>
<span class="gutter">1491 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> multi_member_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">1492 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;S &sub;# T'&quot;</span> <span class="syntax-KEYWORD1">using</span> SxsubT
<span class="gutter">1493 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1494 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;size S &lt; size T'&quot;</span> <span class="syntax-KEYWORD1">using</span> IH <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1495 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">using</span> T <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1496 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1497 </span>
<span class="gutter">1498 </span><span class="syntax-KEYWORD1">lemma</span> size_1_singleton_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size M = 1 &#10233; &exist;a. M = {#a#}&quot;</span>
<span class="gutter">1499 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases M<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1500 </span>
<span class="gutter">1501 </span>
<span class="gutter">1502 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1503 </span>
<span class="gutter">1504 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">W</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">1505 </span>
<span class="gutter">1506 </span><span class="syntax-KEYWORD1">lemma</span> wf_subset_mset_rel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;wf {(M, N :: 'a multiset). M &sub;# N}&quot;</span>
<span class="gutter">1507 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule wf_measure <span class="syntax-OPERATOR">[</span>THEN wf_subset<span class="syntax-OPERATOR">,</span> <span class="syntax-KEYWORD2">where</span> f1<span class="syntax-OPERATOR">=</span>size<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1508 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>clarsimp simp<span class="syntax-OPERATOR">:</span> measure_def inv_image_def mset_subset_size<span class="syntax-OPERATOR">)</span>
<span class="gutter">1509 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutterH">1510 </span>
<span class="gutter">1511 </span><span class="syntax-KEYWORD1">lemma</span> full_multiset_induct <span class="syntax-OPERATOR">[</span>case_names less<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1512 </span><span class="syntax-KEYWORD2">assumes</span> ih<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;B. &forall;(A::'a multiset). A &sub;# B &#10230; P A &#10233; P B&quot;</span>
<span class="gutter">1513 </span><span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;P B&quot;</span>
<span class="gutter">1514 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule wf_subset_mset_rel <span class="syntax-OPERATOR">[</span>THEN wf_induct<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1515 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule ih<span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutter">1516 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">1517 </span>
<span class="gutter">1518 </span><span class="syntax-KEYWORD1">lemma</span> multi_subset_induct <span class="syntax-OPERATOR">[</span>consumes 2<span class="syntax-OPERATOR">,</span> case_names empty add<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1519 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;F &sube;# A&quot;</span>
<span class="gutterH">1520 </span>    <span class="syntax-KEYWORD2">and</span> empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;P {#}&quot;</span>
<span class="gutter">1521 </span>    <span class="syntax-KEYWORD2">and</span> insert<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;a F. a &isin;# A &#10233; P F &#10233; P (add_mset a F)&quot;</span>
<span class="gutter">1522 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;P F&quot;</span>
<span class="gutter">1523 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1524 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&sube;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">1525 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">1526 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct F<span class="syntax-OPERATOR">)</span>
<span class="gutter">1527 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;P {#}&quot;</span> <span class="syntax-KEYWORD1">by</span> fact
<span class="gutter">1528 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">1529 </span>    <span class="syntax-KEYWORD3">fix</span> x F
<span class="gutterH">1530 </span>    <span class="syntax-KEYWORD3">assume</span> P<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;F &sube;# A &#10233; P F&quot;</span> <span class="syntax-KEYWORD2">and</span> i<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x F &sube;# A&quot;</span>
<span class="gutter">1531 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;P (add_mset x F)&quot;</span>
<span class="gutter">1532 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule insert<span class="syntax-OPERATOR">)</span>
<span class="gutter">1533 </span>      <span class="syntax-KEYWORD1">from</span> i <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;x &isin;# A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> mset_subset_eq_insertD<span class="syntax-OPERATOR">)</span>
<span class="gutter">1534 </span>      <span class="syntax-KEYWORD1">from</span> i <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;F &sube;# A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> mset_subset_eq_insertD<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1535 </span>      <span class="syntax-KEYWORD1">with</span> P <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;P F&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">1536 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1537 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1538 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1539 </span>
<span class="gutterH">1540 </span>
<span class="gutter">1541 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1542 </span>
<span class="gutter">1543 </span><span class="syntax-KEYWORD1">definition</span> fold_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; 'b &rArr; 'b) &rArr; 'b &rArr; 'a multiset &rArr; 'b&quot;</span>
<span class="gutter">1544 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutterH">1545 </span>  <span class="syntax-LITERAL1">&quot;fold_mset f s M = Finite_Set.fold (&lambda;x. f x ^^ count M x) s (set_mset M)&quot;</span>
<span class="gutter">1546 </span>
<span class="gutter">1547 </span><span class="syntax-KEYWORD1">lemma</span> fold_mset_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;fold_mset f s {#} = s&quot;</span>
<span class="gutter">1548 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fold_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1549 </span>
<span class="gutterH">1550 </span><span class="syntax-KEYWORD1">context</span> comp_fun_commute
<span class="gutter">1551 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">1552 </span>
<span class="gutter">1553 </span><span class="syntax-KEYWORD1">lemma</span> fold_mset_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;fold_mset f s (add_mset x M) = f x (fold_mset f s M)&quot;</span>
<span class="gutter">1554 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">1555 </span>  <span class="syntax-KEYWORD1">interpret</span> mset<span class="syntax-OPERATOR">:</span> comp_fun_commute <span class="syntax-LITERAL1">&quot;&lambda;y. f y ^^ count M y&quot;</span>
<span class="gutter">1556 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_funpow<span class="syntax-OPERATOR">)</span>
<span class="gutter">1557 </span>  <span class="syntax-KEYWORD1">interpret</span> mset_union<span class="syntax-OPERATOR">:</span> comp_fun_commute <span class="syntax-LITERAL1">&quot;&lambda;y. f y ^^ count (add_mset x M) y&quot;</span>
<span class="gutter">1558 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_funpow<span class="syntax-OPERATOR">)</span>
<span class="gutter">1559 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutterH">1560 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;x &isin; set_mset M&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1561 </span>    <span class="syntax-KEYWORD3">case</span> False
<span class="gutter">1562 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count (add_mset x M) x = 1&quot;</span>
<span class="gutter">1563 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> not_in_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1564 </span>    <span class="syntax-KEYWORD1">from</span> False <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;Finite_Set.fold (&lambda;y. f y ^^ count (add_mset x M) y) s (set_mset M) =</span>
<span class="gutterH">1565 </span><span class="syntax-LITERAL1">      Finite_Set.fold (&lambda;y. f y ^^ count M y) s (set_mset M)&quot;</span>
<span class="gutter">1566 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> Finite_Set.fold_cong comp_fun_commute_funpow<span class="syntax-OPERATOR">)</span>
<span class="gutter">1567 </span>    <span class="syntax-KEYWORD1">with</span> False * <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">1568 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fold_mset_def del<span class="syntax-OPERATOR">:</span> count_add_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1569 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutterH">1570 </span>    <span class="syntax-KEYWORD3">case</span> True
<span class="gutter">1571 </span>    <span class="syntax-KEYWORD3">define</span> N <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;N = set_mset M - {x}&quot;</span>
<span class="gutter">1572 </span>    <span class="syntax-KEYWORD1">from</span> N_def True <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset M = insert x N&quot;</span> <span class="syntax-LITERAL1">&quot;x &notin; N&quot;</span> <span class="syntax-LITERAL1">&quot;finite N&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1573 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;Finite_Set.fold (&lambda;y. f y ^^ count (add_mset x M) y) s N =</span>
<span class="gutter">1574 </span><span class="syntax-LITERAL1">      Finite_Set.fold (&lambda;y. f y ^^ count M y) s N&quot;</span>
<span class="gutterH">1575 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> Finite_Set.fold_cong comp_fun_commute_funpow<span class="syntax-OPERATOR">)</span>
<span class="gutter">1576 </span>    <span class="syntax-KEYWORD1">with</span> * <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fold_mset_def del<span class="syntax-OPERATOR">:</span> count_add_mset<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">1577 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1578 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1579 </span>
<span class="gutterH">1580 </span><span class="syntax-KEYWORD1">corollary</span> fold_mset_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;fold_mset f s {#x#} = f x s&quot;</span>
<span class="gutter">1581 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1582 </span>
<span class="gutter">1583 </span><span class="syntax-KEYWORD1">lemma</span> fold_mset_fun_left_comm<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;f x (fold_mset f s M) = fold_mset f (f x s) M&quot;</span>
<span class="gutter">1584 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> fun_left_comm<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1585 </span>
<span class="gutter">1586 </span><span class="syntax-KEYWORD1">lemma</span> fold_mset_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;fold_mset f s (M + N) = fold_mset f (fold_mset f s M) N&quot;</span>
<span class="gutter">1587 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> fold_mset_fun_left_comm<span class="syntax-OPERATOR">)</span>
<span class="gutter">1588 </span>
<span class="gutter">1589 </span><span class="syntax-KEYWORD1">lemma</span> fold_mset_fusion<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1590 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;comp_fun_commute g&quot;</span>
<span class="gutter">1591 </span>    <span class="syntax-KEYWORD2">and</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x y. h (g x y) = f x (h y)&quot;</span>
<span class="gutter">1592 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;h (fold_mset g w A) = fold_mset f (h w) A&quot;</span>
<span class="gutter">1593 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1594 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute g <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact assms<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1595 </span>  <span class="syntax-KEYWORD1">from</span> * <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1596 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1597 </span>
<span class="gutter">1598 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">1599 </span>
<span class="gutterH">1600 </span><span class="syntax-KEYWORD1">lemma</span> union_fold_mset_add_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A + B = fold_mset add_mset A B&quot;</span>
<span class="gutter">1601 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1602 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute add_mset
<span class="gutter">1603 </span>    <span class="syntax-KEYWORD1">by</span> standard auto
<span class="gutter">1604 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutterH">1605 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction B<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1606 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1607 </span>
<span class="gutter">1608 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutter">1609 </span><span class="syntax-COMMENT4">  A note on code generation: When defining some function containing a</span>
<span class="gutterH">1610 </span><span class="syntax-COMMENT4">  subterm @{term &quot;fold_mset F&quot;}, code generation is not automatic. When</span>
<span class="gutter">1611 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">,</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span>
<span class="gutter">1612 </span><span class="syntax-COMMENT4">  would be code thms for @{const fold_mset} become thms like</span>
<span class="gutter">1613 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">@</span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&quot;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">&quot;</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span>
<span class="gutter">1614 </span><span class="syntax-COMMENT4">  contains defined symbols, i.e.\ is not a code thm. Hence a separate</span>
<span class="gutterH">1615 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">.</span>
<span class="gutter">1616 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1617 </span>
<span class="gutter">1618 </span>
<span class="gutter">1619 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">1620 </span>
<span class="gutter">1621 </span><span class="syntax-KEYWORD1">definition</span> image_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; 'b) &rArr; 'a multiset &rArr; 'b multiset&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">1622 </span>  <span class="syntax-LITERAL1">&quot;image_mset f = fold_mset (add_mset &#8728; f) {#}&quot;</span>
<span class="gutter">1623 </span>
<span class="gutter">1624 </span><span class="syntax-KEYWORD1">lemma</span> comp_fun_commute_mset_image<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;comp_fun_commute (add_mset &#8728; f)&quot;</span>
<span class="gutterH">1625 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1626 </span><span class="syntax-KEYWORD1">qed</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1627 </span>
<span class="gutter">1628 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset f {#} = {#}&quot;</span>
<span class="gutter">1629 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> image_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1630 </span>
<span class="gutter">1631 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset f {#x#} = {#f x#}&quot;</span>
<span class="gutter">1632 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1633 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute <span class="syntax-LITERAL1">&quot;add_mset &#8728; f&quot;</span>
<span class="gutter">1634 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_mset_image<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1635 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> image_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1636 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1637 </span>
<span class="gutter">1638 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset f (M + N) = image_mset f M + image_mset f N&quot;</span>
<span class="gutter">1639 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">1640 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute <span class="syntax-LITERAL1">&quot;add_mset &#8728; f&quot;</span>
<span class="gutter">1641 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_mset_image<span class="syntax-OPERATOR">)</span>
<span class="gutter">1642 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct N<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> image_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1643 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1644 </span>
<span class="gutterH">1645 </span><span class="syntax-KEYWORD1">corollary</span> image_mset_add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1646 </span>  <span class="syntax-LITERAL1">&quot;image_mset f (add_mset a M) = add_mset (f a) (image_mset f M)&quot;</span>
<span class="gutter">1647 </span>  <span class="syntax-KEYWORD1">unfolding</span> image_mset_union add_mset_add_single<span class="syntax-OPERATOR">[</span>of a M<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> image_mset_single<span class="syntax-OPERATOR">)</span>
<span class="gutter">1648 </span>
<span class="gutter">1649 </span><span class="syntax-KEYWORD1">lemma</span> set_image_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset (image_mset f M) = image f (set_mset M)&quot;</span>
<span class="gutterH">1650 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1651 </span>
<span class="gutter">1652 </span><span class="syntax-KEYWORD1">lemma</span> size_image_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (image_mset f M) = size M&quot;</span>
<span class="gutter">1653 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1654 </span>
<span class="gutterH">1655 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_is_empty_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset f M = {#} &#10231; M = {#}&quot;</span>
<span class="gutter">1656 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases M<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1657 </span>
<span class="gutter">1658 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_If<span class="syntax-OPERATOR">:</span>
<span class="gutter">1659 </span>  <span class="syntax-LITERAL1">&quot;image_mset (&lambda;x. if P x then f x else g x) A =</span>
<span class="gutterH">1660 </span><span class="syntax-LITERAL1">     image_mset f (filter_mset P A) + image_mset g (filter_mset (&lambda;x. &not;P x) A)&quot;</span>
<span class="gutter">1661 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1662 </span>
<span class="gutter">1663 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_Diff<span class="syntax-OPERATOR">:</span>
<span class="gutter">1664 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;B &sube;# A&quot;</span>
<span class="gutterH">1665 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;image_mset f (A - B) = image_mset f A - image_mset f B&quot;</span>
<span class="gutter">1666 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1667 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;image_mset f (A - B + B) = image_mset f (A - B) + image_mset f B&quot;</span>
<span class="gutter">1668 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1669 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;A - B + B = A&quot;</span>
<span class="gutterH">1670 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subset_mset.diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter">1671 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1672 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1673 </span>
<span class="gutter">1674 </span><span class="syntax-KEYWORD1">lemma</span> count_image_mset<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1675 </span>  <span class="syntax-LITERAL1">&quot;count (image_mset f A) x = (&sum;y&isin;f -` {x} &cap; set_mset A. count A y)&quot;</span>
<span class="gutter">1676 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span>
<span class="gutter">1677 </span>  <span class="syntax-KEYWORD3">case</span> empty
<span class="gutter">1678 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1679 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">1680 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>add x A<span class="syntax-OPERATOR">)</span>
<span class="gutter">1681 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(if x = y then Suc n else n) = n + (if x = y then 1 else 0)&quot;</span> <span class="syntax-KEYWORD2">for</span> n y
<span class="gutter">1682 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1683 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">1684 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> sum.distrib sum.delta' intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> sum.mono_neutral_left<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1685 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1686 </span>
<span class="gutter">1687 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_subseteq_mono<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &sube;# B &#10233; image_mset f A &sube;# image_mset f B&quot;</span>
<span class="gutter">1688 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis image_mset_union subset_mset.le_iff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter">1689 </span>
<span class="gutterH">1690 </span><span class="syntax-KEYWORD1">syntax</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter">1691 </span>  <span class="syntax-LITERAL1">&quot;_comprehension_mset&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b &rArr; 'b multiset &rArr; 'a multiset&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;({#_/. _ :# _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1692 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutter">1693 </span>  <span class="syntax-LITERAL1">&quot;_comprehension_mset&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b &rArr; 'b multiset &rArr; 'a multiset&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;({#_/. _ &isin;# _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1694 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutterH">1695 </span>  <span class="syntax-LITERAL1">&quot;{#e. x &isin;# M#}&quot;</span> <span class="syntax-OPERATOR">&#8652;</span> <span class="syntax-LITERAL1">&quot;CONST image_mset (&lambda;x. e) M&quot;</span>
<span class="gutter">1696 </span>
<span class="gutter">1697 </span><span class="syntax-KEYWORD1">syntax</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter">1698 </span>  <span class="syntax-LITERAL1">&quot;_comprehension_mset'&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b &rArr; 'b multiset &rArr; bool &rArr; 'a multiset&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;({#_/ | _ :# _./ _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1699 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutterH">1700 </span>  <span class="syntax-LITERAL1">&quot;_comprehension_mset'&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b &rArr; 'b multiset &rArr; bool &rArr; 'a multiset&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;({#_/ | _ &isin;# _./ _#})&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1701 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter">1702 </span>  <span class="syntax-LITERAL1">&quot;{#e | x&isin;#M. P#}&quot;</span> <span class="syntax-OPERATOR">&#8640;</span> <span class="syntax-LITERAL1">&quot;{#e. x &isin;# {# x&isin;#M. P#}#}&quot;</span>
<span class="gutter">1703 </span>
<span class="gutter">1704 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutterH">1705 </span><span class="syntax-COMMENT4">  This allows to write not just filters like @{term &quot;{#x&isin;#M. x&lt;c#}&quot;}</span>
<span class="gutter">1706 </span><span class="syntax-COMMENT4">  but also images like @{term &quot;{#x+x. x&isin;#M #}&quot;} and @{term [source]</span>
<span class="gutter">1707 </span><span class="syntax-COMMENT4">  &quot;{#x+x|x&isin;#M. x&lt;c#}&quot;}, where the latter is currently displayed as</span>
<span class="gutter">1708 </span><span class="syntax-COMMENT4">  @{term &quot;{#x+x|x&isin;#M. x&lt;c#}&quot;}.</span>
<span class="gutter">1709 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">1710 </span>
<span class="gutter">1711 </span><span class="syntax-KEYWORD1">lemma</span> in_image_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;y &isin;# {#f x. x &isin;# M#} &#10231; y &isin; f ` set_mset M&quot;</span>
<span class="gutter">1712 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis set_image_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1713 </span>
<span class="gutter">1714 </span><span class="syntax-KEYWORD1">functor</span> image_mset<span class="syntax-OPERATOR">:</span> image_mset
<span class="gutterH">1715 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1716 </span>  <span class="syntax-KEYWORD3">fix</span> f g <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;image_mset f &#8728; image_mset g = image_mset (f &#8728; g)&quot;</span>
<span class="gutter">1717 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1718 </span>    <span class="syntax-KEYWORD3">fix</span> A
<span class="gutter">1719 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;(image_mset f &#8728; image_mset g) A = image_mset (f &#8728; g) A&quot;</span>
<span class="gutterH">1720 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1721 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1722 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;image_mset id = id&quot;</span>
<span class="gutter">1723 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1724 </span>    <span class="syntax-KEYWORD3">fix</span> A
<span class="gutterH">1725 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;image_mset id A = id A&quot;</span>
<span class="gutter">1726 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1727 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1728 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1729 </span>
<span class="gutterH">1730 </span><span class="syntax-KEYWORD1">declare</span>
<span class="gutter">1731 </span>  image_mset.id <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">1732 </span>  image_mset.identity <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">1733 </span>
<span class="gutter">1734 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_id<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset id x = x&quot;</span>
<span class="gutterH">1735 </span>  <span class="syntax-KEYWORD1">unfolding</span> id_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1736 </span>
<span class="gutter">1737 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_cong<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(&#8896;x. x &isin;# M &#10233; f x = g x) &#10233; {#f x. x &isin;# M#} = {#g x. x &isin;# M#}&quot;</span>
<span class="gutter">1738 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1739 </span>
<span class="gutterH">1740 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_cong_pair<span class="syntax-OPERATOR">:</span>
<span class="gutter">1741 </span>  <span class="syntax-LITERAL1">&quot;(&forall;x y. (x, y) &isin;# M &#10230; f x y = g x y) &#10233; {#f x y. (x, y) &isin;# M#} = {#g x y. (x, y) &isin;# M#}&quot;</span>
<span class="gutter">1742 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis image_mset_cong split_cong<span class="syntax-OPERATOR">)</span>
<span class="gutter">1743 </span>
<span class="gutter">1744 </span>
<span class="gutterH">1745 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1746 </span>
<span class="gutter">1747 </span><span class="syntax-KEYWORD1">primrec</span> mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a list &rArr; 'a multiset&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">1748 </span>  <span class="syntax-LITERAL1">&quot;mset [] = {#}&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">1749 </span>  <span class="syntax-LITERAL1">&quot;mset (a # x) = add_mset a (mset x)&quot;</span>
<span class="gutterH">1750 </span>
<span class="gutter">1751 </span><span class="syntax-KEYWORD1">lemma</span> in_multiset_in_set<span class="syntax-OPERATOR">:</span>
<span class="gutter">1752 </span>  <span class="syntax-LITERAL1">&quot;x &isin;# mset xs &#10231; x &isin; set xs&quot;</span>
<span class="gutter">1753 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1754 </span>
<span class="gutterH">1755 </span><span class="syntax-KEYWORD1">lemma</span> count_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">1756 </span>  <span class="syntax-LITERAL1">&quot;count (mset xs) x = length (filter (&lambda;y. x = y) xs)&quot;</span>
<span class="gutter">1757 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1758 </span>
<span class="gutter">1759 </span><span class="syntax-KEYWORD1">lemma</span> mset_zero_iff<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(mset x = {#}) = (x = [])&quot;</span>
<span class="gutterH">1760 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct x<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1761 </span>
<span class="gutter">1762 </span><span class="syntax-KEYWORD1">lemma</span> mset_zero_iff_right<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;({#} = mset x) = (x = [])&quot;</span>
<span class="gutter">1763 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct x<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1764 </span>
<span class="gutterH">1765 </span><span class="syntax-KEYWORD1">lemma</span> mset_single_iff<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs = {#x#} &#10231; xs = [x]&quot;</span>
<span class="gutter">1766 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1767 </span>
<span class="gutter">1768 </span><span class="syntax-KEYWORD1">lemma</span> mset_single_iff_right<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#x#} = mset xs &#10231; xs = [x]&quot;</span>
<span class="gutter">1769 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1770 </span>
<span class="gutter">1771 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset (mset xs) = set xs&quot;</span>
<span class="gutter">1772 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1773 </span>
<span class="gutter">1774 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_comp_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset &#8728; mset = set&quot;</span>
<span class="gutterH">1775 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1776 </span>
<span class="gutter">1777 </span><span class="syntax-KEYWORD1">lemma</span> size_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (mset xs) = length xs&quot;</span>
<span class="gutter">1778 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1779 </span>
<span class="gutterH">1780 </span><span class="syntax-KEYWORD1">lemma</span> mset_append <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (xs @ ys) = mset xs + mset ys&quot;</span>
<span class="gutter">1781 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1782 </span>
<span class="gutter">1783 </span><span class="syntax-KEYWORD1">lemma</span> mset_filter<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (filter P xs) = {#x &isin;# mset xs. P x #}&quot;</span>
<span class="gutter">1784 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">1785 </span>
<span class="gutter">1786 </span><span class="syntax-KEYWORD1">lemma</span> mset_rev <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1787 </span>  <span class="syntax-LITERAL1">&quot;mset (rev xs) = mset xs&quot;</span>
<span class="gutter">1788 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1789 </span>
<span class="gutterH">1790 </span><span class="syntax-KEYWORD1">lemma</span> surj_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;surj mset&quot;</span>
<span class="gutter">1791 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>unfold surj_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1792 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule allI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1793 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule_tac M <span class="syntax-OPERATOR">=</span> y <span class="syntax-KEYWORD2">in</span> multiset_induct<span class="syntax-OPERATOR">)</span>
<span class="gutter">1794 </span> <span class="syntax-KEYWORD1">apply</span> auto
<span class="gutterH">1795 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;x # xa&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1796 </span><span class="syntax-KEYWORD1">apply</span> auto
<span class="gutter">1797 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">1798 </span>
<span class="gutter">1799 </span><span class="syntax-KEYWORD1">lemma</span> distinct_count_atmost_1<span class="syntax-OPERATOR">:</span>
<span class="gutterH">1800 </span>  <span class="syntax-LITERAL1">&quot;distinct x = (&forall;a. count (mset x) a = (if a &isin; set x then 1 else 0))&quot;</span>
<span class="gutter">1801 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct x<span class="syntax-OPERATOR">)</span>
<span class="gutter">1802 </span>  <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1803 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1804 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?lhs &#10231; ?rhs&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1805 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">1806 </span>    <span class="syntax-KEYWORD3">assume</span> ?lhs <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?rhs <span class="syntax-KEYWORD1">using</span> Cons <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1807 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">1808 </span>    <span class="syntax-KEYWORD3">assume</span> ?rhs <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &notin; set xs&quot;</span>
<span class="gutter">1809 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp split<span class="syntax-OPERATOR">:</span> if_splits<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1810 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(&forall;a. count (mset xs) a =</span>
<span class="gutter">1811 </span><span class="syntax-LITERAL1">       (if a &isin; set xs then 1 else 0))&quot;</span>
<span class="gutter">1812 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto split<span class="syntax-OPERATOR">:</span> if_splits simp add<span class="syntax-OPERATOR">:</span> count_eq_zero_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1813 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?lhs <span class="syntax-KEYWORD1">using</span> Cons <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1814 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1815 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1816 </span>
<span class="gutter">1817 </span><span class="syntax-KEYWORD1">lemma</span> mset_eq_setD<span class="syntax-OPERATOR">:</span>
<span class="gutter">1818 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutter">1819 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;set xs = set ys&quot;</span>
<span class="gutterH">1820 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1821 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;set_mset (mset xs) = set_mset (mset ys)&quot;</span>
<span class="gutter">1822 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1823 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1824 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">1825 </span>
<span class="gutter">1826 </span><span class="syntax-KEYWORD1">lemma</span> set_eq_iff_mset_eq_distinct<span class="syntax-OPERATOR">:</span>
<span class="gutter">1827 </span>  <span class="syntax-LITERAL1">&quot;distinct x &#10233; distinct y &#10233;</span>
<span class="gutter">1828 </span><span class="syntax-LITERAL1">    (set x = set y) = (mset x = mset y)&quot;</span>
<span class="gutter">1829 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff distinct_count_atmost_1<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1830 </span>
<span class="gutter">1831 </span><span class="syntax-KEYWORD1">lemma</span> set_eq_iff_mset_remdups_eq<span class="syntax-OPERATOR">:</span>
<span class="gutter">1832 </span>   <span class="syntax-LITERAL1">&quot;(set x = set y) = (mset (remdups x) = mset (remdups y))&quot;</span>
<span class="gutter">1833 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule iffI<span class="syntax-OPERATOR">)</span>
<span class="gutter">1834 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_eq_iff_mset_eq_distinct<span class="syntax-OPERATOR">[</span>THEN iffD1<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1835 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>drule distinct_remdups <span class="syntax-OPERATOR">[</span>THEN distinct_remdups
<span class="gutter">1836 </span>      <span class="syntax-OPERATOR">[</span>THEN set_eq_iff_mset_eq_distinct <span class="syntax-OPERATOR">[</span>THEN iffD2<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1837 </span><span class="syntax-KEYWORD1">apply</span> simp
<span class="gutter">1838 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">1839 </span>
<span class="gutterH">1840 </span><span class="syntax-KEYWORD1">lemma</span> mset_compl_union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset [x&larr;xs. P x] + mset [x&larr;xs. &not;P x] = mset xs&quot;</span>
<span class="gutter">1841 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1842 </span>
<span class="gutter">1843 </span><span class="syntax-KEYWORD1">lemma</span> nth_mem_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;i &lt; length ls &#10233; (ls ! i) &isin;# mset ls&quot;</span>
<span class="gutter">1844 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct ls arbitrary<span class="syntax-OPERATOR">:</span> i<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1845 </span>  <span class="syntax-KEYWORD3">case</span> Nil
<span class="gutter">1846 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1847 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1848 </span>  <span class="syntax-KEYWORD3">case</span> Cons
<span class="gutter">1849 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases i<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">1850 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1851 </span>
<span class="gutter">1852 </span><span class="syntax-KEYWORD1">lemma</span> mset_remove1<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (remove1 a xs) = mset xs - {#a#}&quot;</span>
<span class="gutter">1853 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1854 </span>
<span class="gutterH">1855 </span><span class="syntax-KEYWORD1">lemma</span> mset_eq_length<span class="syntax-OPERATOR">:</span>
<span class="gutter">1856 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutter">1857 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;length xs = length ys&quot;</span>
<span class="gutter">1858 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis size_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1859 </span>
<span class="gutterH">1860 </span><span class="syntax-KEYWORD1">lemma</span> mset_eq_length_filter<span class="syntax-OPERATOR">:</span>
<span class="gutter">1861 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutter">1862 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;length (filter (&lambda;x. z = x) xs) = length (filter (&lambda;y. z = y) ys)&quot;</span>
<span class="gutter">1863 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis count_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1864 </span>
<span class="gutterH">1865 </span><span class="syntax-KEYWORD1">lemma</span> fold_multiset_equiv<span class="syntax-OPERATOR">:</span>
<span class="gutter">1866 </span>  <span class="syntax-KEYWORD2">assumes</span> f<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x y. x &isin; set xs &#10233; y &isin; set xs &#10233; f x &#8728; f y = f y &#8728; f x&quot;</span>
<span class="gutter">1867 </span>    <span class="syntax-KEYWORD2">and</span> equiv<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutter">1868 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;List.fold f xs = List.fold f ys&quot;</span>
<span class="gutter">1869 </span>  <span class="syntax-KEYWORD1">using</span> f equiv <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span>
<span class="gutterH">1870 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">1871 </span>  <span class="syntax-KEYWORD3">case</span> Nil
<span class="gutter">1872 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1873 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">1874 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1875 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set ys = set (x # xs)&quot;</span>
<span class="gutter">1876 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> mset_eq_setD<span class="syntax-OPERATOR">)</span>
<span class="gutter">1877 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;x y. x &isin; set ys &#10233; y &isin; set ys &#10233; f x &#8728; f y = f y &#8728; f x&quot;</span>
<span class="gutter">1878 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule Cons.prems<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> *<span class="syntax-OPERATOR">)</span>
<span class="gutter">1879 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> * <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin; set ys&quot;</span>
<span class="gutterH">1880 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1881 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;List.fold f ys = List.fold f (remove1 x ys) &#8728; f x&quot;</span>
<span class="gutter">1882 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact fold_remove1_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">1883 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> Cons.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;List.fold f xs = List.fold f (remove1 x ys)&quot;</span>
<span class="gutter">1884 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> Cons.hyps<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1885 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1886 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1887 </span>
<span class="gutter">1888 </span><span class="syntax-KEYWORD1">lemma</span> mset_insort <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (insort x xs) = add_mset x (mset xs)&quot;</span>
<span class="gutter">1889 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">1890 </span>
<span class="gutter">1891 </span><span class="syntax-KEYWORD1">lemma</span> mset_map<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (map f xs) = image_mset f (mset xs)&quot;</span>
<span class="gutter">1892 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1893 </span>
<span class="gutter">1894 </span><span class="syntax-KEYWORD1">global_interpretation</span> mset_set<span class="syntax-OPERATOR">:</span> folding add_mset <span class="syntax-LITERAL1">&quot;{#}&quot;</span>
<span class="gutterH">1895 </span>  <span class="syntax-KEYWORD2">defines</span> mset_set <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;folding.F add_mset {#}&quot;</span>
<span class="gutter">1896 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">1897 </span>
<span class="gutter">1898 </span><span class="syntax-KEYWORD1">lemma</span> count_mset_set <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1899 </span>  <span class="syntax-LITERAL1">&quot;finite A &#10233; x &isin; A &#10233; count (mset_set A) x = 1&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;PROP ?P&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1900 </span>  <span class="syntax-LITERAL1">&quot;&not; finite A &#10233; count (mset_set A) x = 0&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;PROP ?Q&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1901 </span>  <span class="syntax-LITERAL1">&quot;x &notin; A &#10233; count (mset_set A) x = 0&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;PROP ?R&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1902 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1903 </span>  <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count (mset_set A) x = 0&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;x &notin; A&quot;</span> <span class="syntax-KEYWORD2">for</span> A
<span class="gutter">1904 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;finite A&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">1905 </span>    <span class="syntax-KEYWORD3">case</span> False <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1906 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">1907 </span>    <span class="syntax-KEYWORD3">case</span> True <span class="syntax-KEYWORD1">from</span> True <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&notin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1908 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1909 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;PROP ?P&quot;</span> <span class="syntax-LITERAL1">&quot;PROP ?Q&quot;</span> <span class="syntax-LITERAL1">&quot;PROP ?R&quot;</span>
<span class="gutterH">1910 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto elim<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> Set.set_insert<span class="syntax-OPERATOR">)</span>
<span class="gutter">1911 </span><span class="syntax-KEYWORD1">qed</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">O</span><span class="syntax-COMMENT4">D</span><span class="syntax-COMMENT4">O</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">@</span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">@</span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">1912 </span>
<span class="gutter">1913 </span><span class="syntax-KEYWORD1">lemma</span> elem_mset_set<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">,</span> intro<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;finite A &#10233; x &isin;# mset_set A &#10231; x &isin; A&quot;</span>
<span class="gutter">1914 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">1915 </span>
<span class="gutter">1916 </span><span class="syntax-KEYWORD1">lemma</span> mset_set_Union<span class="syntax-OPERATOR">:</span>
<span class="gutter">1917 </span>  <span class="syntax-LITERAL1">&quot;finite A &#10233; finite B &#10233; A &cap; B = {} &#10233; mset_set (A &cup; B) = mset_set A + mset_set B&quot;</span>
<span class="gutter">1918 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">1919 </span>
<span class="gutterH">1920 </span><span class="syntax-KEYWORD1">lemma</span> filter_mset_mset_set <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1921 </span>  <span class="syntax-LITERAL1">&quot;finite A &#10233; filter_mset P (mset_set A) = mset_set {x&isin;A. P x}&quot;</span>
<span class="gutter">1922 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induction A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span>
<span class="gutter">1923 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>insert x A<span class="syntax-OPERATOR">)</span>
<span class="gutter">1924 </span>  <span class="syntax-KEYWORD1">from</span> insert.hyps <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;filter_mset P (mset_set (insert x A)) =</span>
<span class="gutterH">1925 </span><span class="syntax-LITERAL1">      filter_mset P (mset_set A) + mset_set (if P x then {x} else {})&quot;</span>
<span class="gutter">1926 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">1927 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;filter_mset P (mset_set A) = mset_set {x&isin;A. P x}&quot;</span>
<span class="gutter">1928 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule insert.IH<span class="syntax-OPERATOR">)</span>
<span class="gutter">1929 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> insert.hyps
<span class="gutterH">1930 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; + mset_set (if P x then {x} else {}) =</span>
<span class="gutter">1931 </span><span class="syntax-LITERAL1">            mset_set ({x &isin; A. P x} &cup; (if P x then {x} else {}))&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;_ = mset_set ?A&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">1932 </span>     <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro mset_set_Union <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1933 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> insert.hyps <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;?A = {y&isin;insert x A. P y}&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">1934 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">.</span>
<span class="gutterH">1935 </span><span class="syntax-KEYWORD1">qed</span> simp_all
<span class="gutter">1936 </span>
<span class="gutter">1937 </span><span class="syntax-KEYWORD1">lemma</span> mset_set_Diff<span class="syntax-OPERATOR">:</span>
<span class="gutter">1938 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;finite A&quot;</span> <span class="syntax-LITERAL1">&quot;B &sube; A&quot;</span>
<span class="gutter">1939 </span>  <span class="syntax-KEYWORD2">shows</span>  <span class="syntax-LITERAL1">&quot;mset_set (A - B) = mset_set A - mset_set B&quot;</span>
<span class="gutterH">1940 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1941 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;mset_set ((A - B) &cup; B) = mset_set (A - B) + mset_set B&quot;</span>
<span class="gutter">1942 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro mset_set_Union<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto dest<span class="syntax-OPERATOR">:</span> finite_subset<span class="syntax-OPERATOR">)</span>
<span class="gutter">1943 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;A - B &cup; B = A&quot;</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">1944 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1945 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1946 </span>
<span class="gutter">1947 </span><span class="syntax-KEYWORD1">lemma</span> mset_set_set<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;distinct xs &#10233; mset_set (set xs) = mset xs&quot;</span>
<span class="gutter">1948 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1949 </span>
<span class="gutterH">1950 </span><span class="syntax-KEYWORD1">context</span> linorder
<span class="gutter">1951 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">1952 </span>
<span class="gutter">1953 </span><span class="syntax-KEYWORD1">definition</span> sorted_list_of_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a list&quot;</span>
<span class="gutter">1954 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutterH">1955 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset M = fold_mset insort [] M&quot;</span>
<span class="gutter">1956 </span>
<span class="gutter">1957 </span><span class="syntax-KEYWORD1">lemma</span> sorted_list_of_multiset_empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1958 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset {#} = []&quot;</span>
<span class="gutter">1959 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sorted_list_of_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1960 </span>
<span class="gutter">1961 </span><span class="syntax-KEYWORD1">lemma</span> sorted_list_of_multiset_singleton <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1962 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset {#x#} = [x]&quot;</span>
<span class="gutter">1963 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1964 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute insort <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_insort<span class="syntax-OPERATOR">)</span>
<span class="gutterH">1965 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sorted_list_of_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1966 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1967 </span>
<span class="gutter">1968 </span><span class="syntax-KEYWORD1">lemma</span> sorted_list_of_multiset_insert <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1969 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset (add_mset x M) = List.insort x (sorted_list_of_multiset M)&quot;</span>
<span class="gutterH">1970 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">1971 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute insort <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_fun_commute_insort<span class="syntax-OPERATOR">)</span>
<span class="gutter">1972 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sorted_list_of_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">1973 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">1974 </span>
<span class="gutterH">1975 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">1976 </span>
<span class="gutter">1977 </span><span class="syntax-KEYWORD1">lemma</span> mset_sorted_list_of_multiset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1978 </span>  <span class="syntax-LITERAL1">&quot;mset (sorted_list_of_multiset M) = M&quot;</span>
<span class="gutter">1979 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">1980 </span>
<span class="gutter">1981 </span><span class="syntax-KEYWORD1">lemma</span> sorted_list_of_multiset_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1982 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset (mset xs) = sort xs&quot;</span>
<span class="gutter">1983 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1984 </span>
<span class="gutterH">1985 </span><span class="syntax-KEYWORD1">lemma</span> finite_set_mset_mset_set<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1986 </span>  <span class="syntax-LITERAL1">&quot;finite A &#10233; set_mset (mset_set A) = A&quot;</span>
<span class="gutter">1987 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">1988 </span>
<span class="gutter">1989 </span><span class="syntax-KEYWORD1">lemma</span> mset_set_empty_iff<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset_set A = {#} &#10231; A = {} &or; infinite A&quot;</span>
<span class="gutterH">1990 </span>  <span class="syntax-KEYWORD1">using</span> finite_set_mset_mset_set <span class="syntax-KEYWORD1">by</span> fastforce
<span class="gutter">1991 </span>
<span class="gutter">1992 </span><span class="syntax-KEYWORD1">lemma</span> infinite_set_mset_mset_set<span class="syntax-OPERATOR">:</span>
<span class="gutter">1993 </span>  <span class="syntax-LITERAL1">&quot;&not; finite A &#10233; set_mset (mset_set A) = {}&quot;</span>
<span class="gutter">1994 </span><span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">1995 </span>
<span class="gutter">1996 </span><span class="syntax-KEYWORD1">lemma</span> set_sorted_list_of_multiset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">1997 </span>  <span class="syntax-LITERAL1">&quot;set (sorted_list_of_multiset M) = set_mset M&quot;</span>
<span class="gutter">1998 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> set_insort<span class="syntax-OPERATOR">)</span>
<span class="gutter">1999 </span>
<span class="gutterH">2000 </span><span class="syntax-KEYWORD1">lemma</span> sorted_list_of_mset_set <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2001 </span>  <span class="syntax-LITERAL1">&quot;sorted_list_of_multiset (mset_set A) = sorted_list_of_set A&quot;</span>
<span class="gutter">2002 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;finite A&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">,</span> simp_all<span class="syntax-OPERATOR">)</span>
<span class="gutter">2003 </span>
<span class="gutter">2004 </span><span class="syntax-KEYWORD1">lemma</span> mset_upt <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset [m..&lt;n] = mset_set {m..&lt;n}&quot;</span>
<span class="gutterH">2005 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction n<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> atLeastLessThanSuc<span class="syntax-OPERATOR">)</span>
<span class="gutter">2006 </span>
<span class="gutter">2007 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_map_of<span class="syntax-OPERATOR">:</span>
<span class="gutter">2008 </span>  <span class="syntax-LITERAL1">&quot;distinct (map fst xs) &#10233; {#the (map_of xs i). i &isin;# mset (map fst xs)#} = mset (map snd xs)&quot;</span>
<span class="gutter">2009 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induction xs<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2010 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs<span class="syntax-OPERATOR">)</span>
<span class="gutter">2011 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{#the (map_of (x # xs) i). i &isin;# mset (map fst (x # xs))#} =</span>
<span class="gutter">2012 </span><span class="syntax-LITERAL1">          add_mset (snd x) {#the (if i = fst x then Some (snd x) else map_of xs i).</span>
<span class="gutter">2013 </span><span class="syntax-LITERAL1">             i &isin;# mset (map fst xs)#}&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;_ = add_mset _ ?A&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2014 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> Cons.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;?A = {#the (map_of xs i). i :# mset (map fst xs)#}&quot;</span>
<span class="gutterH">2015 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases x<span class="syntax-OPERATOR">,</span> intro image_mset_cong<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> in_multiset_in_set<span class="syntax-OPERATOR">)</span>
<span class="gutter">2016 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">from</span> Cons.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = mset (map snd xs)&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro Cons.IH<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2017 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2018 </span><span class="syntax-KEYWORD1">qed</span> simp_all
<span class="gutter">2019 </span>
<span class="gutterH">2020 </span><span class="syntax-COMMENT1">(* Contributed by Lukas Bulwahn *)</span>
<span class="gutter">2021 </span><span class="syntax-KEYWORD1">lemma</span> image_mset_mset_set<span class="syntax-OPERATOR">:</span>
<span class="gutter">2022 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;inj_on f A&quot;</span>
<span class="gutter">2023 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;image_mset f (mset_set A) = mset_set (f ` A)&quot;</span>
<span class="gutter">2024 </span><span class="syntax-KEYWORD1">proof</span> cases
<span class="gutterH">2025 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;finite A&quot;</span>
<span class="gutter">2026 </span>  <span class="syntax-KEYWORD1">from</span> this <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2027 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2028 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2029 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;infinite A&quot;</span>
<span class="gutterH">2030 </span>  <span class="syntax-KEYWORD1">from</span> this <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;infinite (f ` A)&quot;</span>
<span class="gutter">2031 </span>    <span class="syntax-KEYWORD1">using</span> finite_imageD <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2032 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">`</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2033 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2034 </span>
<span class="gutterH">2035 </span>
<span class="gutter">2036 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2037 </span>
<span class="gutter">2038 </span><span class="syntax-KEYWORD1">lemma</span> in_replicate_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# replicate_mset n y &#10231; n &gt; 0 &and; x = y&quot;</span>
<span class="gutter">2039 </span>  <span class="syntax-KEYWORD1">unfolding</span> replicate_mset_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">2040 </span>
<span class="gutter">2041 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_replicate_mset_subset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset (replicate_mset n x) = (if n = 0 then {} else {x})&quot;</span>
<span class="gutter">2042 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto split<span class="syntax-OPERATOR">:</span> if_splits<span class="syntax-OPERATOR">)</span>
<span class="gutter">2043 </span>
<span class="gutter">2044 </span><span class="syntax-KEYWORD1">lemma</span> size_replicate_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (replicate_mset n M) = n&quot;</span>
<span class="gutterH">2045 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">,</span> simp_all<span class="syntax-OPERATOR">)</span>
<span class="gutter">2046 </span>
<span class="gutter">2047 </span><span class="syntax-KEYWORD1">lemma</span> count_le_replicate_mset_subset_eq<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;n &le; count M x &#10231; replicate_mset n x &sube;# M&quot;</span>
<span class="gutter">2048 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> mset_subset_eqI<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>metis count_replicate_mset subseteq_mset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2049 </span>
<span class="gutterH">2050 </span><span class="syntax-KEYWORD1">lemma</span> filter_eq_replicate_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#y &isin;# D. y = x#} = replicate_mset (count D x) x&quot;</span>
<span class="gutter">2051 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct D<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2052 </span>
<span class="gutter">2053 </span><span class="syntax-KEYWORD1">lemma</span> replicate_count_mset_eq_filter_eq<span class="syntax-OPERATOR">:</span>
<span class="gutter">2054 </span>  <span class="syntax-LITERAL1">&quot;replicate (count (mset xs) k) k = filter (HOL.eq k) xs&quot;</span>
<span class="gutterH">2055 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2056 </span>
<span class="gutter">2057 </span><span class="syntax-KEYWORD1">lemma</span> replicate_mset_eq_empty_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2058 </span>  <span class="syntax-LITERAL1">&quot;replicate_mset n a = {#} &#10231; n = 0&quot;</span>
<span class="gutter">2059 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">2060 </span>
<span class="gutter">2061 </span><span class="syntax-KEYWORD1">lemma</span> replicate_mset_eq_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2062 </span>  <span class="syntax-LITERAL1">&quot;replicate_mset m a = replicate_mset n b &#10231;</span>
<span class="gutter">2063 </span><span class="syntax-LITERAL1">    m = 0 &and; n = 0 &or; m = n &and; a = b&quot;</span>
<span class="gutter">2064 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2065 </span>
<span class="gutter">2066 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_cancel1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;repeat_mset a A = repeat_mset a B &#10231; A = B &or; a = 0&quot;</span>
<span class="gutter">2067 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">2068 </span>
<span class="gutter">2069 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_cancel2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;repeat_mset a A = repeat_mset b A &#10231; a = b &or; A = {#}&quot;</span>
<span class="gutterH">2070 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">2071 </span>
<span class="gutter">2072 </span><span class="syntax-KEYWORD1">lemma</span> repeat_mset_eq_empty_iff<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;repeat_mset n A = {#} &#10231; n = 0 &or; A = {#}&quot;</span>
<span class="gutter">2073 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases n<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2074 </span>
<span class="gutterH">2075 </span><span class="syntax-KEYWORD1">lemma</span> image_replicate_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2076 </span>  <span class="syntax-LITERAL1">&quot;image_mset f (replicate_mset n a) = replicate_mset n (f a)&quot;</span>
<span class="gutter">2077 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2078 </span>
<span class="gutter">2079 </span>
<span class="gutterH">2080 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2081 </span>
<span class="gutter">2082 </span><span class="syntax-KEYWORD1">locale</span> comm_monoid_mset <span class="syntax-OPERATOR">=</span> comm_monoid
<span class="gutter">2083 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2084 </span>
<span class="gutterH">2085 </span><span class="syntax-KEYWORD1">interpretation</span> comp_fun_commute f
<span class="gutter">2086 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff left_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">2087 </span>
<span class="gutter">2088 </span><span class="syntax-KEYWORD1">interpretation</span> comp<span class="syntax-OPERATOR">?</span><span class="syntax-OPERATOR">:</span> comp_fun_commute <span class="syntax-LITERAL1">&quot;f &#8728; g&quot;</span>
<span class="gutter">2089 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact comp_comp_fun_commute<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2090 </span>
<span class="gutter">2091 </span><span class="syntax-KEYWORD1">context</span>
<span class="gutter">2092 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2093 </span>
<span class="gutter">2094 </span><span class="syntax-KEYWORD1">definition</span> F <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a&quot;</span>
<span class="gutterH">2095 </span>  <span class="syntax-KEYWORD2">where</span> eq_fold<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">f</span><span class="syntax-LITERAL1">o</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">f</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2096 </span>
<span class="gutter">2097 </span><span class="syntax-KEYWORD1">lemma</span> empty <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2098 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> eq_fold<span class="syntax-OPERATOR">)</span>
<span class="gutter">2099 </span>
<span class="gutterH">2100 </span><span class="syntax-KEYWORD1">lemma</span> singleton <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;F {#x#} = x&quot;</span>
<span class="gutter">2101 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2102 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute
<span class="gutter">2103 </span>    <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff left_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">2104 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> eq_fold<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2105 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2106 </span>
<span class="gutter">2107 </span><span class="syntax-KEYWORD1">lemma</span> union <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">+</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2108 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2109 </span>  <span class="syntax-KEYWORD1">interpret</span> comp_fun_commute f
<span class="gutterH">2110 </span>    <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fun_eq_iff left_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">2111 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2112 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct N<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> left_commute eq_fold<span class="syntax-OPERATOR">)</span>
<span class="gutter">2113 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2114 </span>
<span class="gutterH">2115 </span><span class="syntax-KEYWORD1">lemma</span> add_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2116 </span>  <span class="syntax-KEYWORD1">unfolding</span> add_mset_add_single<span class="syntax-OPERATOR">[</span>of x N<span class="syntax-OPERATOR">]</span> union <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2117 </span>
<span class="gutter">2118 </span><span class="syntax-KEYWORD1">lemma</span> insert <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2119 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">d</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">2120 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> eq_fold<span class="syntax-OPERATOR">)</span>
<span class="gutter">2121 </span>
<span class="gutter">2122 </span><span class="syntax-KEYWORD1">lemma</span> remove<span class="syntax-OPERATOR">:</span>
<span class="gutter">2123 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;x &isin;# A&quot;</span>
<span class="gutter">2124 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">-</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">2125 </span>  <span class="syntax-KEYWORD1">using</span> multi_member_split<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2126 </span>
<span class="gutter">2127 </span><span class="syntax-KEYWORD1">lemma</span> neutral<span class="syntax-OPERATOR">:</span>
<span class="gutter">2128 </span>  <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">&forall;</span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#10233;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2129 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">2130 </span>
<span class="gutter">2131 </span><span class="syntax-KEYWORD1">lemma</span> neutral_const <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2132 </span>  <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">&lambda;</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2133 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> neutral<span class="syntax-OPERATOR">)</span>
<span class="gutter">2134 </span>
<span class="gutterH">2135 </span><span class="syntax-KEYWORD2">private</span> <span class="syntax-KEYWORD1">lemma</span> F_image_mset_product<span class="syntax-OPERATOR">:</span>
<span class="gutter">2136 </span>  <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">j</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">j</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">j</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span>
<span class="gutter">2137 </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">j</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">j</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2138 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction B<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> left_commute semigroup.assoc semigroup_axioms<span class="syntax-OPERATOR">)</span>
<span class="gutter">2139 </span>
<span class="gutterH">2140 </span><span class="syntax-KEYWORD1">lemma</span> commute<span class="syntax-OPERATOR">:</span>
<span class="gutter">2141 </span>  <span class="syntax-LITERAL1">&quot;F (image_mset (&lambda;i. F (image_mset (g i) B)) A) =</span>
<span class="gutter">2142 </span><span class="syntax-LITERAL1">    F (image_mset (&lambda;j. F (image_mset (&lambda;i. g i j) A)) B)&quot;</span>
<span class="gutter">2143 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">,</span> simp<span class="syntax-OPERATOR">)</span>
<span class="gutter">2144 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>induction B<span class="syntax-OPERATOR">,</span> auto simp add<span class="syntax-OPERATOR">:</span> F_image_mset_product ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2145 </span>  <span class="syntax-KEYWORD1">done</span>
<span class="gutter">2146 </span>
<span class="gutter">2147 </span><span class="syntax-KEYWORD1">lemma</span> distrib<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">&lambda;</span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1">.</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">h</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">x</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">h</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2148 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2149 </span>
<span class="gutterH">2150 </span><span class="syntax-KEYWORD1">lemma</span> union_disjoint<span class="syntax-OPERATOR">:</span>
<span class="gutter">2151 </span>  <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&cap;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">{</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1">}</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#10233;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&cup;</span><span class="syntax-LITERAL1">#</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">A</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-NULL">&#10073;</span><span class="syntax-LITERAL1">*</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">F</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">i</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">a</span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">_</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">s</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">g</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">B</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2152 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2153 </span>
<span class="gutter">2154 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutterH">2155 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">2156 </span>
<span class="gutter">2157 </span><span class="syntax-KEYWORD1">lemma</span> comp_fun_commute_plus_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;comp_fun_commute (op + :: 'a multiset &rArr; _ &rArr; _)&quot;</span>
<span class="gutter">2158 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> add_ac comp_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2159 </span>
<span class="gutterH">2160 </span><span class="syntax-KEYWORD1">declare</span> comp_fun_commute.fold_mset_add_mset<span class="syntax-OPERATOR">[</span>OF comp_fun_commute_plus_mset<span class="syntax-OPERATOR">,</span> simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">2161 </span>
<span class="gutter">2162 </span><span class="syntax-KEYWORD1">lemma</span> in_mset_fold_plus_iff<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# fold_mset (op +) M NN &#10231; x &isin;# M &or; (&exist;N. N &isin;# NN &and; x &isin;# N)&quot;</span>
<span class="gutter">2163 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct NN<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2164 </span>
<span class="gutterH">2165 </span><span class="syntax-KEYWORD1">context</span> comm_monoid_add
<span class="gutter">2166 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2167 </span>
<span class="gutter">2168 </span><span class="syntax-KEYWORD1">sublocale</span> sum_mset<span class="syntax-OPERATOR">:</span> comm_monoid_mset plus 0
<span class="gutter">2169 </span>  <span class="syntax-KEYWORD2">defines</span> sum_mset <span class="syntax-OPERATOR">=</span> sum_mset.F <span class="syntax-KEYWORD1">..</span>
<span class="gutterH">2170 </span>
<span class="gutter">2171 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> semiring_1<span class="syntax-OPERATOR">)</span> sum_mset_replicate_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2172 </span>  <span class="syntax-LITERAL1">&quot;sum_mset (replicate_mset n a) = of_nat n * a&quot;</span>
<span class="gutter">2173 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> algebra_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2174 </span>
<span class="gutterH">2175 </span><span class="syntax-KEYWORD1">lemma</span> sum_unfold_sum_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">2176 </span>  <span class="syntax-LITERAL1">&quot;sum f A = sum_mset (image_mset f (mset_set A))&quot;</span>
<span class="gutter">2177 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;finite A&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">,</span> simp_all<span class="syntax-OPERATOR">)</span>
<span class="gutter">2178 </span>
<span class="gutter">2179 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_delta<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;sum_mset (image_mset (&lambda;x. if x = y then c else 0) A) = c * count A y&quot;</span>
<span class="gutterH">2180 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2181 </span>
<span class="gutter">2182 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_delta'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;sum_mset (image_mset (&lambda;x. if y = x then c else 0) A) = c * count A y&quot;</span>
<span class="gutter">2183 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2184 </span>
<span class="gutterH">2185 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">2186 </span>
<span class="gutter">2187 </span><span class="syntax-KEYWORD1">lemma</span> of_nat_sum_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2188 </span>  <span class="syntax-LITERAL1">&quot;of_nat (sum_mset M) = sum_mset (image_mset of_nat M)&quot;</span>
<span class="gutter">2189 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction M<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">2190 </span>
<span class="gutter">2191 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_0_iff <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2192 </span>  <span class="syntax-LITERAL1">&quot;sum_mset M = (0::'a::canonically_ordered_monoid_add)</span>
<span class="gutter">2193 </span><span class="syntax-LITERAL1">   &#10231; (&forall;x &isin; set_mset M. x = 0)&quot;</span>
<span class="gutter">2194 </span><span class="syntax-KEYWORD1">by</span><span class="syntax-OPERATOR">(</span>induction M<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">2195 </span>
<span class="gutter">2196 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2197 </span>  <span class="syntax-KEYWORD2">fixes</span> M N <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a :: ordered_cancel_comm_monoid_diff) multiset&quot;</span>
<span class="gutter">2198 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;N &sube;# M &#10233; sum_mset (M - N) = sum_mset M - sum_mset N&quot;</span>
<span class="gutter">2199 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_diff_cancel_right' sum_mset.union subset_mset.diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2200 </span>
<span class="gutter">2201 </span><span class="syntax-KEYWORD1">lemma</span> size_eq_sum_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size M = sum_mset (image_mset (&lambda;_. 1) M)&quot;</span>
<span class="gutter">2202 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span>
<span class="gutter">2203 </span>  <span class="syntax-KEYWORD3">case</span> empty <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2204 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">2205 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>add x M<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">2206 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;x &isin; set_mset M&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2207 </span>      <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> size_multiset_overloaded_eq not_in_iff sum.If_cases Diff_eq<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span>
<span class="gutter">2208 </span>        sum.remove<span class="syntax-OPERATOR">)</span>
<span class="gutter">2209 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2210 </span>
<span class="gutter">2211 </span><span class="syntax-KEYWORD1">lemma</span> size_mset_set <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size (mset_set A) = card A&quot;</span>
<span class="gutter">2212 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> size_eq_sum_mset card_eq_sum sum_unfold_sum_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">2213 </span>
<span class="gutter">2214 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_sum_list<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;sum_mset (mset xs) = sum_list xs&quot;</span>
<span class="gutterH">2215 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2216 </span>
<span class="gutter">2217 </span><span class="syntax-KEYWORD1">syntax</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutter">2218 </span>  <span class="syntax-LITERAL1">&quot;_sum_mset_image&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'b set &rArr; 'a &rArr; 'a::comm_monoid_add&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3SUM _:#_. _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter">2219 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutterH">2220 </span>  <span class="syntax-LITERAL1">&quot;_sum_mset_image&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'b set &rArr; 'a &rArr; 'a::comm_monoid_add&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&sum;_&isin;#_. _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter">2221 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter">2222 </span>  <span class="syntax-LITERAL1">&quot;&sum;i &isin;# A. b&quot;</span> <span class="syntax-OPERATOR">&#8652;</span> <span class="syntax-LITERAL1">&quot;CONST sum_mset (CONST image_mset (&lambda;i. b) A)&quot;</span>
<span class="gutter">2223 </span>
<span class="gutter">2224 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_distrib_left<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2225 </span>  <span class="syntax-KEYWORD2">fixes</span> f <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b::semiring_0&quot;</span>
<span class="gutter">2226 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;c * (&sum;x &isin;# M. f x) = (&sum;x &isin;# M. c * f(x))&quot;</span>
<span class="gutter">2227 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction M<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> distrib_left<span class="syntax-OPERATOR">)</span>
<span class="gutter">2228 </span>
<span class="gutter">2229 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_distrib_right<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2230 </span>  <span class="syntax-KEYWORD2">fixes</span> f <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a &rArr; 'b::semiring_0&quot;</span>
<span class="gutter">2231 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(&sum;b &isin;# B. f b) * a = (&sum;b &isin;# B. f b * a)&quot;</span>
<span class="gutter">2232 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction B<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> distrib_right<span class="syntax-OPERATOR">)</span>
<span class="gutter">2233 </span>
<span class="gutter">2234 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_constant <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">2235 </span>  <span class="syntax-KEYWORD2">fixes</span> y <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'b::semiring_1&quot;</span>
<span class="gutter">2236 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">&sum;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">*</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2237 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> algebra_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2238 </span>
<span class="gutter">2239 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> ordered_comm_monoid_add<span class="syntax-OPERATOR">)</span> sum_mset_mono<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2240 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;&#8896;i. i &isin;# K &#10233; f i &le; g i&quot;</span>
<span class="gutter">2241 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sum_mset (image_mset f K) &le; sum_mset (image_mset g K)&quot;</span>
<span class="gutter">2242 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction K<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> local.add_mono<span class="syntax-OPERATOR">)</span>
<span class="gutter">2243 </span>
<span class="gutter">2244 </span><span class="syntax-KEYWORD1">lemma</span> sum_mset_product<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2245 </span>  <span class="syntax-KEYWORD2">fixes</span> f <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a::{comm_monoid_add,times} &rArr; 'b::semiring_0&quot;</span>
<span class="gutter">2246 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(&sum;i &isin;# A. f i) * (&sum;i &isin;# B. g i) = (&sum;i&isin;#A. &sum;j&isin;#B. f i * g j)&quot;</span>
<span class="gutter">2247 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>subst sum_mset.commute<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> sum_mset_distrib_left sum_mset_distrib_right<span class="syntax-OPERATOR">)</span>
<span class="gutter">2248 </span>
<span class="gutter">2249 </span><span class="syntax-KEYWORD1">abbreviation</span> Union_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset multiset &rArr; 'a multiset&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;&#8899;#_&quot;</span> <span class="syntax-OPERATOR">[</span>900<span class="syntax-OPERATOR">]</span> 900<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2250 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;&#8899;# MM &equiv; sum_mset MM&quot;</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">-</span>
<span class="gutter">2251 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">&#10758;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2252 </span>
<span class="gutter">2253 </span><span class="syntax-KEYWORD1">lemma</span> set_mset_Union_mset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset (&#8899;# MM) = (&#8899;M &isin; set_mset MM. set_mset M)&quot;</span>
<span class="gutter">2254 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct MM<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">2255 </span>
<span class="gutter">2256 </span><span class="syntax-KEYWORD1">lemma</span> in_Union_mset_iff<span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# &#8899;# MM &#10231; (&exist;M. M &isin;# MM &and; x &isin;# M)&quot;</span>
<span class="gutter">2257 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct MM<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2258 </span>
<span class="gutter">2259 </span><span class="syntax-KEYWORD1">lemma</span> count_sum<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2260 </span>  <span class="syntax-LITERAL1">&quot;count (sum f A) x = sum (&lambda;a. count (f a) x) A&quot;</span>
<span class="gutter">2261 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> infinite_finite_induct<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2262 </span>
<span class="gutter">2263 </span><span class="syntax-KEYWORD1">lemma</span> sum_eq_empty_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2264 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;finite A&quot;</span>
<span class="gutterH">2265 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sum f A = {#} &#10231; (&forall;a&isin;A. f a = {#})&quot;</span>
<span class="gutter">2266 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> induct simp_all
<span class="gutter">2267 </span>
<span class="gutter">2268 </span><span class="syntax-KEYWORD1">lemma</span> Union_mset_empty_conv<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8899;# M = {#} &#10231; (&forall;i&isin;#M. i = {#})&quot;</span>
<span class="gutter">2269 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction M<span class="syntax-OPERATOR">)</span> auto
<span class="gutterH">2270 </span>
<span class="gutter">2271 </span><span class="syntax-KEYWORD1">context</span> comm_monoid_mult
<span class="gutter">2272 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2273 </span>
<span class="gutter">2274 </span><span class="syntax-KEYWORD1">sublocale</span> prod_mset<span class="syntax-OPERATOR">:</span> comm_monoid_mset times 1
<span class="gutterH">2275 </span>  <span class="syntax-KEYWORD2">defines</span> prod_mset <span class="syntax-OPERATOR">=</span> prod_mset.F <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2276 </span>
<span class="gutter">2277 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_empty<span class="syntax-OPERATOR">:</span>
<span class="gutter">2278 </span>  <span class="syntax-LITERAL1">&quot;prod_mset {#} = 1&quot;</span>
<span class="gutter">2279 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact prod_mset.empty<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2280 </span>
<span class="gutter">2281 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_singleton<span class="syntax-OPERATOR">:</span>
<span class="gutter">2282 </span>  <span class="syntax-LITERAL1">&quot;prod_mset {#x#} = x&quot;</span>
<span class="gutter">2283 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact prod_mset.singleton<span class="syntax-OPERATOR">)</span>
<span class="gutter">2284 </span>
<span class="gutterH">2285 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_Un<span class="syntax-OPERATOR">:</span>
<span class="gutter">2286 </span>  <span class="syntax-LITERAL1">&quot;prod_mset (A + B) = prod_mset A * prod_mset B&quot;</span>
<span class="gutter">2287 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact prod_mset.union<span class="syntax-OPERATOR">)</span>
<span class="gutter">2288 </span>
<span class="gutter">2289 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_replicate_mset <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">2290 </span>  <span class="syntax-LITERAL1">&quot;prod_mset (replicate_mset n a) = a ^ n&quot;</span>
<span class="gutter">2291 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct n<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2292 </span>
<span class="gutter">2293 </span><span class="syntax-KEYWORD1">lemma</span> prod_unfold_prod_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">2294 </span>  <span class="syntax-LITERAL1">&quot;prod f A = prod_mset (image_mset f (mset_set A))&quot;</span>
<span class="gutterH">2295 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;finite A&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">,</span> simp_all<span class="syntax-OPERATOR">)</span>
<span class="gutter">2296 </span>
<span class="gutter">2297 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_multiplicity<span class="syntax-OPERATOR">:</span>
<span class="gutter">2298 </span>  <span class="syntax-LITERAL1">&quot;prod_mset M = prod (&lambda;x. x ^ count M x) (set_mset M)&quot;</span>
<span class="gutter">2299 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> fold_mset_def prod.eq_fold prod_mset.eq_fold funpow_times_power comp_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2300 </span>
<span class="gutter">2301 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_delta<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;prod_mset (image_mset (&lambda;x. if x = y then c else 1) A) = c ^ count A y&quot;</span>
<span class="gutter">2302 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2303 </span>
<span class="gutter">2304 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_delta'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;prod_mset (image_mset (&lambda;x. if y = x then c else 1) A) = c ^ count A y&quot;</span>
<span class="gutterH">2305 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induction A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2306 </span>
<span class="gutter">2307 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">2308 </span>
<span class="gutter">2309 </span><span class="syntax-KEYWORD1">syntax</span> <span class="syntax-OPERATOR">(</span>ASCII<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2310 </span>  <span class="syntax-LITERAL1">&quot;_prod_mset_image&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'b set &rArr; 'a &rArr; 'a::comm_monoid_mult&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3PROD _:#_. _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter">2311 </span><span class="syntax-KEYWORD1">syntax</span>
<span class="gutter">2312 </span>  <span class="syntax-LITERAL1">&quot;_prod_mset_image&quot;</span> <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;pttrn &rArr; 'b set &rArr; 'a &rArr; 'a::comm_monoid_mult&quot;</span>  <span class="syntax-OPERATOR">(</span><span class="syntax-LITERAL1">&quot;(3&prod;_&isin;#_. _)&quot;</span> <span class="syntax-OPERATOR">[</span>0<span class="syntax-OPERATOR">,</span> 51<span class="syntax-OPERATOR">,</span> 10<span class="syntax-OPERATOR">]</span> 10<span class="syntax-OPERATOR">)</span>
<span class="gutter">2313 </span><span class="syntax-KEYWORD1">translations</span>
<span class="gutter">2314 </span>  <span class="syntax-LITERAL1">&quot;&prod;i &isin;# A. b&quot;</span> <span class="syntax-OPERATOR">&#8652;</span> <span class="syntax-LITERAL1">&quot;CONST prod_mset (CONST image_mset (&lambda;i. b) A)&quot;</span>
<span class="gutterH">2315 </span>
<span class="gutter">2316 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> comm_monoid_mult<span class="syntax-OPERATOR">)</span> prod_mset_subset_imp_dvd<span class="syntax-OPERATOR">:</span>
<span class="gutter">2317 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;A &sube;# B&quot;</span>
<span class="gutter">2318 </span>  <span class="syntax-KEYWORD2">shows</span>   <span class="syntax-LITERAL1">&quot;prod_mset A dvd prod_mset B&quot;</span>
<span class="gutter">2319 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">2320 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;B = (B - A) + A&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> subset_mset.diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter">2321 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;prod_mset &hellip; = prod_mset (B - A) * prod_mset A&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2322 </span>  <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;prod_mset A dvd &hellip;&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2323 </span>  <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter">2324 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2325 </span>
<span class="gutter">2326 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> comm_monoid_mult<span class="syntax-OPERATOR">)</span> dvd_prod_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">2327 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;x &isin;# A&quot;</span>
<span class="gutter">2328 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;x dvd prod_mset A&quot;</span>
<span class="gutter">2329 </span>  <span class="syntax-KEYWORD1">using</span> assms prod_mset_subset_imp_dvd <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;{#x#}&quot;</span> A<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">2330 </span>
<span class="gutter">2331 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> semidom<span class="syntax-OPERATOR">)</span> prod_mset_zero_iff <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2332 </span>  <span class="syntax-LITERAL1">&quot;prod_mset A = 0 &#10231; 0 &isin;# A&quot;</span>
<span class="gutter">2333 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2334 </span>
<span class="gutterH">2335 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> semidom_divide<span class="syntax-OPERATOR">)</span> prod_mset_diff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2336 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;B &sube;# A&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;0 &notin;# B&quot;</span>
<span class="gutter">2337 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;prod_mset (A - B) = prod_mset A div prod_mset B&quot;</span>
<span class="gutter">2338 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2339 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD3">obtain</span> C <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;A = B + C&quot;</span>
<span class="gutterH">2340 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis subset_mset.add_diff_inverse<span class="syntax-OPERATOR">)</span>
<span class="gutter">2341 </span>  <span class="syntax-KEYWORD1">with</span> assms <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2342 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2343 </span>
<span class="gutter">2344 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> semidom_divide<span class="syntax-OPERATOR">)</span> prod_mset_minus<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2345 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;a &isin;# A&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;a &ne; 0&quot;</span>
<span class="gutter">2346 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;prod_mset (A - {#a#}) = prod_mset A div a&quot;</span>
<span class="gutter">2347 </span>  <span class="syntax-KEYWORD1">using</span> assms prod_mset_diff <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;{#a#}&quot;</span> A<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2348 </span>
<span class="gutter">2349 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> algebraic_semidom<span class="syntax-OPERATOR">)</span> is_unit_prod_mset_iff<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2350 </span>  <span class="syntax-LITERAL1">&quot;is_unit (prod_mset A) &#10231; (&forall;x &isin;# A. is_unit x)&quot;</span>
<span class="gutter">2351 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> is_unit_mult_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">2352 </span>
<span class="gutter">2353 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> normalization_semidom<span class="syntax-OPERATOR">)</span> normalize_prod_mset<span class="syntax-OPERATOR">:</span>
<span class="gutter">2354 </span>  <span class="syntax-LITERAL1">&quot;normalize (prod_mset A) = prod_mset (image_mset normalize A)&quot;</span>
<span class="gutterH">2355 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> normalize_mult<span class="syntax-OPERATOR">)</span>
<span class="gutter">2356 </span>
<span class="gutter">2357 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> normalization_semidom<span class="syntax-OPERATOR">)</span> normalized_prod_msetI<span class="syntax-OPERATOR">:</span>
<span class="gutter">2358 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;&#8896;a. a &isin;# A &#10233; normalize a = a&quot;</span>
<span class="gutter">2359 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;normalize (prod_mset A) = prod_mset A&quot;</span>
<span class="gutterH">2360 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2361 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;image_mset normalize A = A&quot;</span>
<span class="gutter">2362 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct A<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2363 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> normalize_prod_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">2364 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2365 </span>
<span class="gutter">2366 </span><span class="syntax-KEYWORD1">lemma</span> prod_mset_prod_list<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;prod_mset (mset xs) = prod_list xs&quot;</span>
<span class="gutter">2367 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2368 </span>
<span class="gutter">2369 </span>
<span class="gutterH">2370 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2371 </span>
<span class="gutter">2372 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">L</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2373 </span>
<span class="gutter">2374 </span><span class="syntax-KEYWORD1">context</span> linorder
<span class="gutterH">2375 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2376 </span>
<span class="gutter">2377 </span><span class="syntax-KEYWORD1">lemma</span> mset_insort <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2378 </span>  <span class="syntax-LITERAL1">&quot;mset (insort_key k x xs) = add_mset x (mset xs)&quot;</span>
<span class="gutter">2379 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutterH">2380 </span>
<span class="gutter">2381 </span><span class="syntax-KEYWORD1">lemma</span> mset_sort <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2382 </span>  <span class="syntax-LITERAL1">&quot;mset (sort_key k xs) = mset xs&quot;</span>
<span class="gutter">2383 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">2384 </span>
<span class="gutterH">2385 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutter">2386 </span><span class="syntax-COMMENT4">  This lemma shows which properties suffice to show that a function</span>
<span class="gutter">2387 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">.</span>
<span class="gutter">2388 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2389 </span>
<span class="gutterH">2390 </span><span class="syntax-KEYWORD1">lemma</span> properties_for_sort_key<span class="syntax-OPERATOR">:</span>
<span class="gutter">2391 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;mset ys = mset xs&quot;</span>
<span class="gutter">2392 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;&#8896;k. k &isin; set ys &#10233; filter (&lambda;x. f k = f x) ys = filter (&lambda;x. f k = f x) xs&quot;</span>
<span class="gutter">2393 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;sorted (map f ys)&quot;</span>
<span class="gutter">2394 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sort_key f xs = ys&quot;</span>
<span class="gutterH">2395 </span>  <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">2396 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">2397 </span>  <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2398 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2399 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2400 </span>  <span class="syntax-KEYWORD1">from</span> Cons.prems<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">have</span>
<span class="gutter">2401 </span>    <span class="syntax-LITERAL1">&quot;&forall;k &isin; set ys. filter (&lambda;x. f k = f x) (remove1 x ys) = filter (&lambda;x. f k = f x) xs&quot;</span>
<span class="gutter">2402 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> filter_remove1<span class="syntax-OPERATOR">)</span>
<span class="gutter">2403 </span>  <span class="syntax-KEYWORD1">with</span> Cons.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;sort_key f xs = remove1 x ys&quot;</span>
<span class="gutter">2404 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> Cons.hyps simp add<span class="syntax-OPERATOR">:</span> sorted_map_remove1<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2405 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> Cons.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin;# mset ys&quot;</span>
<span class="gutter">2406 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2407 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x &isin; set ys&quot;</span>
<span class="gutter">2408 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2409 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">using</span> Cons.prems <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> insort_key_remove1<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2410 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2411 </span>
<span class="gutter">2412 </span><span class="syntax-KEYWORD1">lemma</span> properties_for_sort<span class="syntax-OPERATOR">:</span>
<span class="gutter">2413 </span>  <span class="syntax-KEYWORD2">assumes</span> multiset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset ys = mset xs&quot;</span>
<span class="gutter">2414 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;sorted ys&quot;</span>
<span class="gutterH">2415 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sort xs = ys&quot;</span>
<span class="gutter">2416 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule properties_for_sort_key<span class="syntax-OPERATOR">)</span>
<span class="gutter">2417 </span>  <span class="syntax-KEYWORD1">from</span> multiset <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;mset ys = mset xs&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">2418 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;sorted (map (&lambda;x. x) ys)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2419 </span>  <span class="syntax-KEYWORD1">from</span> multiset <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;length (filter (&lambda;y. k = y) ys) = length (filter (&lambda;x. k = x) xs)&quot;</span> <span class="syntax-KEYWORD2">for</span> k
<span class="gutterH">2420 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule mset_eq_length_filter<span class="syntax-OPERATOR">)</span>
<span class="gutter">2421 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;replicate (length (filter (&lambda;y. k = y) ys)) k =</span>
<span class="gutter">2422 </span><span class="syntax-LITERAL1">    replicate (length (filter (&lambda;x. k = x) xs)) k&quot;</span> <span class="syntax-KEYWORD2">for</span> k
<span class="gutter">2423 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2424 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;k &isin; set ys &#10233; filter (&lambda;y. k = y) ys = filter (&lambda;x. k = x) xs&quot;</span> <span class="syntax-KEYWORD2">for</span> k
<span class="gutterH">2425 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> replicate_length_filter<span class="syntax-OPERATOR">)</span>
<span class="gutter">2426 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2427 </span>
<span class="gutter">2428 </span><span class="syntax-KEYWORD1">lemma</span> sort_key_inj_key_eq<span class="syntax-OPERATOR">:</span>
<span class="gutter">2429 </span>  <span class="syntax-KEYWORD2">assumes</span> mset_equal<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutterH">2430 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;inj_on f (set xs)&quot;</span>
<span class="gutter">2431 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;sorted (map f ys)&quot;</span>
<span class="gutter">2432 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sort_key f xs = ys&quot;</span>
<span class="gutter">2433 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule properties_for_sort_key<span class="syntax-OPERATOR">)</span>
<span class="gutter">2434 </span>  <span class="syntax-KEYWORD1">from</span> mset_equal
<span class="gutterH">2435 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;mset ys = mset xs&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2436 </span>  <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2437 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;sorted (map f ys)&quot;</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">2438 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;[x&larr;ys . f k = f x] = [x&larr;xs . f k = f x]&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;k &isin; set ys&quot;</span> <span class="syntax-KEYWORD2">for</span> k
<span class="gutter">2439 </span>  <span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">2440 </span>    <span class="syntax-KEYWORD1">from</span> mset_equal
<span class="gutter">2441 </span>    <span class="syntax-KEYWORD1">have</span> set_equal<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set xs = set ys&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule mset_eq_setD<span class="syntax-OPERATOR">)</span>
<span class="gutter">2442 </span>    <span class="syntax-KEYWORD1">with</span> that <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;insert k (set ys) = set ys&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2443 </span>    <span class="syntax-KEYWORD1">with</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> inj<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;inj_on f (insert k (set ys))&quot;</span>
<span class="gutter">2444 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> set_equal<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2445 </span>    <span class="syntax-KEYWORD1">from</span> inj <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;[x&larr;ys . f k = f x] = filter (HOL.eq k) ys&quot;</span>
<span class="gutter">2446 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> inj_on_filter_key_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">2447 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = replicate (count (mset ys) k) k&quot;</span>
<span class="gutter">2448 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> replicate_count_mset_eq_filter_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">2449 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = replicate (count (mset xs) k) k&quot;</span>
<span class="gutterH">2450 </span>      <span class="syntax-KEYWORD1">using</span> mset_equal <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2451 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = filter (HOL.eq k) xs&quot;</span>
<span class="gutter">2452 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> replicate_count_mset_eq_filter_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">2453 </span>    <span class="syntax-KEYWORD1">also</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&hellip; = [x&larr;xs . f k = f x]&quot;</span>
<span class="gutter">2454 </span>      <span class="syntax-KEYWORD1">using</span> inj <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> inj_on_filter_key_eq <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> simp add<span class="syntax-OPERATOR">:</span> set_equal<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2455 </span>    <span class="syntax-KEYWORD1">finally</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">.</span>
<span class="gutter">2456 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2457 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2458 </span>
<span class="gutter">2459 </span><span class="syntax-KEYWORD1">lemma</span> sort_key_eq_sort_key<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2460 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;mset xs = mset ys&quot;</span>
<span class="gutter">2461 </span>    <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;inj_on f (set xs)&quot;</span>
<span class="gutter">2462 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;sort_key f xs = sort_key f ys&quot;</span>
<span class="gutter">2463 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule sort_key_inj_key_eq<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> assms<span class="syntax-OPERATOR">)</span>
<span class="gutter">2464 </span>
<span class="gutterH">2465 </span><span class="syntax-KEYWORD1">lemma</span> sort_key_by_quicksort<span class="syntax-OPERATOR">:</span>
<span class="gutter">2466 </span>  <span class="syntax-LITERAL1">&quot;sort_key f xs = sort_key f [x&larr;xs. f x &lt; f (xs ! (length xs div 2))]</span>
<span class="gutter">2467 </span><span class="syntax-LITERAL1">    @ [x&larr;xs. f x = f (xs ! (length xs div 2))]</span>
<span class="gutter">2468 </span><span class="syntax-LITERAL1">    @ sort_key f [x&larr;xs. f x &gt; f (xs ! (length xs div 2))]&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;sort_key f ?lhs = ?rhs&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2469 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule properties_for_sort_key<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2470 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;mset ?rhs = mset ?lhs&quot;</span>
<span class="gutter">2471 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_eqI<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> mset_filter<span class="syntax-OPERATOR">)</span>
<span class="gutter">2472 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;sorted (map f ?rhs)&quot;</span>
<span class="gutter">2473 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> sorted_append intro<span class="syntax-OPERATOR">:</span> sorted_map_same<span class="syntax-OPERATOR">)</span>
<span class="gutter">2474 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">2475 </span>  <span class="syntax-KEYWORD3">fix</span> l
<span class="gutter">2476 </span>  <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;l &isin; set ?rhs&quot;</span>
<span class="gutter">2477 </span>  <span class="syntax-KEYWORD1">let</span> ?pivot <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;f (xs ! (length xs div 2))&quot;</span>
<span class="gutter">2478 </span>  <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x. f l = f x &#10231; f x = f l&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2479 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;[x &larr; sort_key f xs . f x = f l] = [x &larr; xs. f x = f l]&quot;</span>
<span class="gutterH">2480 </span>    <span class="syntax-KEYWORD1">unfolding</span> filter_sort <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule properties_for_sort_key<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> sorted_map_same<span class="syntax-OPERATOR">)</span>
<span class="gutter">2481 </span>  <span class="syntax-KEYWORD1">with</span> * <span class="syntax-KEYWORD1">have</span> **<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;[x &larr; sort_key f xs . f l = f x] = [x &larr; xs. f l = f x]&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2482 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;x P. P (f x) ?pivot &and; f l = f x &#10231; P (f l) ?pivot &and; f l = f x&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2483 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;P. [x &larr; sort_key f xs . P (f x) ?pivot &and; f l = f x] =</span>
<span class="gutter">2484 </span><span class="syntax-LITERAL1">    [x &larr; sort_key f xs. P (f l) ?pivot &and; f l = f x]&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">2485 </span>  <span class="syntax-KEYWORD1">note</span> *** <span class="syntax-OPERATOR">=</span> this <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;op &lt;&quot;</span><span class="syntax-OPERATOR">]</span> this <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;op &gt;&quot;</span><span class="syntax-OPERATOR">]</span> this <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;op =&quot;</span><span class="syntax-OPERATOR">]</span>
<span class="gutter">2486 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;[x &larr; ?rhs. f l = f x] = [x &larr; ?lhs. f l = f x]&quot;</span>
<span class="gutter">2487 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;f l&quot;</span> ?pivot rule<span class="syntax-OPERATOR">:</span> linorder_cases<span class="syntax-OPERATOR">)</span>
<span class="gutter">2488 </span>    <span class="syntax-KEYWORD3">case</span> less
<span class="gutter">2489 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;f l &ne; ?pivot&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;&not; f l &gt; ?pivot&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">2490 </span>    <span class="syntax-KEYWORD1">with</span> less <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2491 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> filter_sort <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> ** ***<span class="syntax-OPERATOR">)</span>
<span class="gutter">2492 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2493 </span>    <span class="syntax-KEYWORD3">case</span> equal <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2494 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> * less_le<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2495 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2496 </span>    <span class="syntax-KEYWORD3">case</span> greater
<span class="gutter">2497 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;f l &ne; ?pivot&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;&not; f l &lt; ?pivot&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2498 </span>    <span class="syntax-KEYWORD1">with</span> greater <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2499 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> filter_sort <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> ** ***<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2500 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2501 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2502 </span>
<span class="gutter">2503 </span><span class="syntax-KEYWORD1">lemma</span> sort_by_quicksort<span class="syntax-OPERATOR">:</span>
<span class="gutter">2504 </span>  <span class="syntax-LITERAL1">&quot;sort xs = sort [x&larr;xs. x &lt; xs ! (length xs div 2)]</span>
<span class="gutterH">2505 </span><span class="syntax-LITERAL1">    @ [x&larr;xs. x = xs ! (length xs div 2)]</span>
<span class="gutter">2506 </span><span class="syntax-LITERAL1">    @ sort [x&larr;xs. x &gt; xs ! (length xs div 2)]&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;sort ?lhs = ?rhs&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2507 </span>  <span class="syntax-KEYWORD1">using</span> sort_key_by_quicksort <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;&lambda;x. x&quot;</span><span class="syntax-OPERATOR">,</span> symmetric<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2508 </span>
<span class="gutter">2509 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">A</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">2510 </span>
<span class="gutter">2511 </span><span class="syntax-KEYWORD1">definition</span> part <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('b &rArr; 'a) &rArr; 'a &rArr; 'b list &rArr; 'b list &times; 'b list &times; 'b list&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">2512 </span>  <span class="syntax-LITERAL1">&quot;part f pivot xs = ([x &larr; xs. f x &lt; pivot], [x &larr; xs. f x = pivot], [x &larr; xs. pivot &lt; f x])&quot;</span>
<span class="gutter">2513 </span>
<span class="gutter">2514 </span><span class="syntax-KEYWORD1">lemma</span> part_code <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">2515 </span>  <span class="syntax-LITERAL1">&quot;part f pivot [] = ([], [], [])&quot;</span>
<span class="gutter">2516 </span>  <span class="syntax-LITERAL1">&quot;part f pivot (x # xs) = (let (lts, eqs, gts) = part f pivot xs; x' = f x in</span>
<span class="gutter">2517 </span><span class="syntax-LITERAL1">     if x' &lt; pivot then (x # lts, eqs, gts)</span>
<span class="gutter">2518 </span><span class="syntax-LITERAL1">     else if x' &gt; pivot then (lts, eqs, x # gts)</span>
<span class="gutter">2519 </span><span class="syntax-LITERAL1">     else (lts, x # eqs, gts))&quot;</span>
<span class="gutterH">2520 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> part_def Let_def split_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2521 </span>
<span class="gutter">2522 </span><span class="syntax-KEYWORD1">lemma</span> sort_key_by_quicksort_code <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2523 </span>  <span class="syntax-LITERAL1">&quot;sort_key f xs =</span>
<span class="gutter">2524 </span><span class="syntax-LITERAL1">    (case xs of</span>
<span class="gutterH">2525 </span><span class="syntax-LITERAL1">      [] &rArr; []</span>
<span class="gutter">2526 </span><span class="syntax-LITERAL1">    | [x] &rArr; xs</span>
<span class="gutter">2527 </span><span class="syntax-LITERAL1">    | [x, y] &rArr; (if f x &le; f y then xs else [y, x])</span>
<span class="gutter">2528 </span><span class="syntax-LITERAL1">    | _ &rArr;</span>
<span class="gutter">2529 </span><span class="syntax-LITERAL1">        let (lts, eqs, gts) = part f (f (xs ! (length xs div 2))) xs</span>
<span class="gutterH">2530 </span><span class="syntax-LITERAL1">        in sort_key f lts @ eqs @ sort_key f gts)&quot;</span>
<span class="gutter">2531 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases xs<span class="syntax-OPERATOR">)</span>
<span class="gutter">2532 </span>  <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2533 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2534 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons _ ys<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">note</span> hyps <span class="syntax-OPERATOR">=</span> Cons <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutterH">2535 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">2536 </span>    <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">with</span> hyps <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2537 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2538 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons _ zs<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">note</span> hyps <span class="syntax-OPERATOR">=</span> hyps Cons <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2539 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases zs<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2540 </span>      <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">with</span> hyps <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2541 </span>    <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2542 </span>      <span class="syntax-KEYWORD3">case</span> Cons
<span class="gutter">2543 </span>      <span class="syntax-KEYWORD1">from</span> sort_key_by_quicksort <span class="syntax-OPERATOR">[</span>of f xs<span class="syntax-OPERATOR">]</span>
<span class="gutter">2544 </span>      <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;sort_key f xs = (let (lts, eqs, gts) = part f (f (xs ! (length xs div 2))) xs</span>
<span class="gutterH">2545 </span><span class="syntax-LITERAL1">        in sort_key f lts @ eqs @ sort_key f gts)&quot;</span>
<span class="gutter">2546 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> split_def Let_def part_def fst_conv snd_conv<span class="syntax-OPERATOR">)</span>
<span class="gutter">2547 </span>      <span class="syntax-KEYWORD1">with</span> hyps Cons <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> list.cases<span class="syntax-OPERATOR">)</span>
<span class="gutter">2548 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2549 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2550 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2551 </span>
<span class="gutter">2552 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">2553 </span>
<span class="gutter">2554 </span><span class="syntax-KEYWORD1">hide_const</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">open</span><span class="syntax-OPERATOR">)</span> part
<span class="gutterH">2555 </span>
<span class="gutter">2556 </span><span class="syntax-KEYWORD1">lemma</span> mset_remdups_subset_eq<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (remdups xs) &sube;# mset xs&quot;</span>
<span class="gutter">2557 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> subset_mset.order_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">2558 </span>
<span class="gutter">2559 </span><span class="syntax-KEYWORD1">lemma</span> mset_update<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2560 </span>  <span class="syntax-LITERAL1">&quot;i &lt; length ls &#10233; mset (ls[i := v]) = add_mset v (mset ls - {#ls ! i#})&quot;</span>
<span class="gutter">2561 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct ls arbitrary<span class="syntax-OPERATOR">:</span> i<span class="syntax-OPERATOR">)</span>
<span class="gutter">2562 </span>  <span class="syntax-KEYWORD3">case</span> Nil <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2563 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2564 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2565 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">2566 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases i<span class="syntax-OPERATOR">)</span>
<span class="gutter">2567 </span>    <span class="syntax-KEYWORD3">case</span> 0 <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2568 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2569 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Suc i'<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2570 </span>    <span class="syntax-KEYWORD1">with</span> Cons <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2571 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">!</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">'</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-OPERATOR">)</span> auto
<span class="gutter">2572 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2573 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2574 </span>
<span class="gutterH">2575 </span><span class="syntax-KEYWORD1">lemma</span> mset_swap<span class="syntax-OPERATOR">:</span>
<span class="gutter">2576 </span>  <span class="syntax-LITERAL1">&quot;i &lt; length ls &#10233; j &lt; length ls &#10233;</span>
<span class="gutter">2577 </span><span class="syntax-LITERAL1">    mset (ls[j := ls ! i, i := ls ! j]) = mset ls&quot;</span>
<span class="gutter">2578 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;i = j&quot;</span><span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> mset_update nth_mem_mset<span class="syntax-OPERATOR">)</span>
<span class="gutter">2579 </span>
<span class="gutterH">2580 </span>
<span class="gutter">2581 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2582 </span>
<span class="gutter">2583 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">W</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2584 </span>
<span class="gutterH">2585 </span><span class="syntax-KEYWORD1">definition</span> mult1 <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &times; 'a) set &rArr; ('a multiset &times; 'a multiset) set&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">2586 </span>  <span class="syntax-LITERAL1">&quot;mult1 r = {(N, M). &exist;a M0 K. M = add_mset a M0 &and; N = M0 + K &and;</span>
<span class="gutter">2587 </span><span class="syntax-LITERAL1">      (&forall;b. b &isin;# K &#10230; (b, a) &isin; r)}&quot;</span>
<span class="gutter">2588 </span>
<span class="gutter">2589 </span><span class="syntax-KEYWORD1">definition</span> mult <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &times; 'a) set &rArr; ('a multiset &times; 'a multiset) set&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutterH">2590 </span>  <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">r</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1">1</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">r</span><span class="syntax-LITERAL1">)</span><span class="syntax-NULL">&#8679;</span><span class="syntax-LITERAL1">+</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">2591 </span>
<span class="gutter">2592 </span><span class="syntax-KEYWORD1">lemma</span> mult1I<span class="syntax-OPERATOR">:</span>
<span class="gutter">2593 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M0&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;N = M0 + K&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;&#8896;b. b &isin;# K &#10233; (b, a) &isin; r&quot;</span>
<span class="gutter">2594 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(N, M) &isin; mult1 r&quot;</span>
<span class="gutterH">2595 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">unfolding</span> mult1_def <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2596 </span>
<span class="gutter">2597 </span><span class="syntax-KEYWORD1">lemma</span> mult1E<span class="syntax-OPERATOR">:</span>
<span class="gutter">2598 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;(N, M) &isin; mult1 r&quot;</span>
<span class="gutter">2599 </span>  <span class="syntax-KEYWORD2">obtains</span> a M0 K <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M0&quot;</span> <span class="syntax-LITERAL1">&quot;N = M0 + K&quot;</span> <span class="syntax-LITERAL1">&quot;&#8896;b. b &isin;# K &#10233; (b, a) &isin; r&quot;</span>
<span class="gutterH">2600 </span>  <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">unfolding</span> mult1_def <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2601 </span>
<span class="gutter">2602 </span><span class="syntax-KEYWORD1">lemma</span> mono_mult1<span class="syntax-OPERATOR">:</span>
<span class="gutter">2603 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;r &sube; r'&quot;</span> <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;mult1 r &sube; mult1 r'&quot;</span>
<span class="gutter">2604 </span><span class="syntax-KEYWORD1">unfolding</span> mult1_def <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">2605 </span>
<span class="gutter">2606 </span><span class="syntax-KEYWORD1">lemma</span> mono_mult<span class="syntax-OPERATOR">:</span>
<span class="gutter">2607 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;r &sube; r'&quot;</span> <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;mult r &sube; mult r'&quot;</span>
<span class="gutter">2608 </span><span class="syntax-KEYWORD1">unfolding</span> mult_def <span class="syntax-KEYWORD1">using</span> mono_mult1<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">]</span> trancl_mono <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2609 </span>
<span class="gutterH">2610 </span><span class="syntax-KEYWORD1">lemma</span> not_less_empty <span class="syntax-OPERATOR">[</span>iff<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M, {#}) &notin; mult1 r&quot;</span>
<span class="gutter">2611 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mult1_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2612 </span>
<span class="gutter">2613 </span><span class="syntax-KEYWORD1">lemma</span> less_add<span class="syntax-OPERATOR">:</span>
<span class="gutter">2614 </span>  <span class="syntax-KEYWORD2">assumes</span> mult1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(N, add_mset a M0) &isin; mult1 r&quot;</span>
<span class="gutterH">2615 </span>  <span class="syntax-KEYWORD2">shows</span>
<span class="gutter">2616 </span>    <span class="syntax-LITERAL1">&quot;(&exist;M. (M, M0) &isin; mult1 r &and; N = add_mset a M) &or;</span>
<span class="gutter">2617 </span><span class="syntax-LITERAL1">     (&exist;K. (&forall;b. b &isin;# K &#10230; (b, a) &isin; r) &and; N = M0 + K)&quot;</span>
<span class="gutter">2618 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2619 </span>  <span class="syntax-KEYWORD1">let</span> ?r <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;&lambda;K a. &forall;b. b &isin;# K &#10230; (b, a) &isin; r&quot;</span>
<span class="gutterH">2620 </span>  <span class="syntax-KEYWORD1">let</span> ?R <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;&lambda;N M. &exist;a M0 K. M = add_mset a M0 &and; N = M0 + K &and; ?r K a&quot;</span>
<span class="gutter">2621 </span>  <span class="syntax-KEYWORD3">obtain</span> a' M0' K <span class="syntax-KEYWORD2">where</span> M0<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset a M0 = add_mset a' M0'&quot;</span>
<span class="gutter">2622 </span>    <span class="syntax-KEYWORD2">and</span> N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = M0' + K&quot;</span>
<span class="gutter">2623 </span>    <span class="syntax-KEYWORD2">and</span> r<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;?r K a'&quot;</span>
<span class="gutter">2624 </span>    <span class="syntax-KEYWORD1">using</span> mult1 <span class="syntax-KEYWORD1">unfolding</span> mult1_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">2625 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?case1 &or; ?case2&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2626 </span>  <span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2627 </span>    <span class="syntax-KEYWORD1">from</span> M0 <span class="syntax-KEYWORD1">consider</span> <span class="syntax-LITERAL1">&quot;M0 = M0'&quot;</span> <span class="syntax-LITERAL1">&quot;a = a'&quot;</span>
<span class="gutter">2628 </span>      <span class="syntax-OPERATOR">|</span> K' <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M0 = add_mset a' K'&quot;</span> <span class="syntax-LITERAL1">&quot;M0' = add_mset a K'&quot;</span>
<span class="gutter">2629 </span>      <span class="syntax-KEYWORD1">by</span> atomize_elim <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> add_eq_conv_ex<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2630 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2631 </span>    <span class="syntax-KEYWORD1">proof</span> cases
<span class="gutter">2632 </span>      <span class="syntax-KEYWORD3">case</span> 1
<span class="gutter">2633 </span>      <span class="syntax-KEYWORD1">with</span> N r <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;?r K a &and; N = M0 + K&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2634 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> ?case2 <span class="syntax-KEYWORD1">..</span>
<span class="gutterH">2635 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2636 </span>    <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2637 </span>      <span class="syntax-KEYWORD3">case</span> 2
<span class="gutter">2638 </span>      <span class="syntax-KEYWORD1">from</span> N 2<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">have</span> n<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = add_mset a (K' + K)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2639 </span>      <span class="syntax-KEYWORD1">with</span> r 2<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;?R (K' + K) M0&quot;</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">2640 </span>      <span class="syntax-KEYWORD1">with</span> n <span class="syntax-KEYWORD1">have</span> ?case1 <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mult1_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2641 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2642 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2643 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2644 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2645 </span>
<span class="gutter">2646 </span><span class="syntax-KEYWORD1">lemma</span> all_accessible<span class="syntax-OPERATOR">:</span>
<span class="gutter">2647 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;wf r&quot;</span>
<span class="gutter">2648 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&forall;M. M &isin; Wellfounded.acc (mult1 r)&quot;</span>
<span class="gutter">2649 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutterH">2650 </span>  <span class="syntax-KEYWORD1">let</span> ?R <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;mult1 r&quot;</span>
<span class="gutter">2651 </span>  <span class="syntax-KEYWORD1">let</span> ?W <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;Wellfounded.acc ?R&quot;</span>
<span class="gutter">2652 </span>  <span class="syntax-KEYWORD1">{</span>
<span class="gutter">2653 </span>    <span class="syntax-KEYWORD3">fix</span> M M0 a
<span class="gutter">2654 </span>    <span class="syntax-KEYWORD3">assume</span> M0<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M0 &isin; ?W&quot;</span>
<span class="gutterH">2655 </span>      <span class="syntax-KEYWORD2">and</span> wf_hyp<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;b. (b, a) &isin; r &#10233; (&forall;M &isin; ?W. add_mset b M &isin; ?W)&quot;</span>
<span class="gutter">2656 </span>      <span class="syntax-KEYWORD2">and</span> acc_hyp<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&forall;M. (M, M0) &isin; ?R &#10230; add_mset a M &isin; ?W&quot;</span>
<span class="gutter">2657 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;add_mset a M0 &isin; ?W&quot;</span>
<span class="gutter">2658 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule accI <span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;add_mset a M0&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2659 </span>      <span class="syntax-KEYWORD3">fix</span> N
<span class="gutterH">2660 </span>      <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;(N, add_mset a M0) &isin; ?R&quot;</span>
<span class="gutter">2661 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">consider</span> M <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;(M, M0) &isin; ?R&quot;</span> <span class="syntax-LITERAL1">&quot;N = add_mset a M&quot;</span>
<span class="gutter">2662 </span>        <span class="syntax-OPERATOR">|</span> K <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;&forall;b. b &isin;# K &#10230; (b, a) &isin; r&quot;</span> <span class="syntax-LITERAL1">&quot;N = M0 + K&quot;</span>
<span class="gutter">2663 </span>        <span class="syntax-KEYWORD1">by</span> atomize_elim <span class="syntax-OPERATOR">(</span>rule less_add<span class="syntax-OPERATOR">)</span>
<span class="gutter">2664 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;N &isin; ?W&quot;</span>
<span class="gutterH">2665 </span>      <span class="syntax-KEYWORD1">proof</span> cases
<span class="gutter">2666 </span>        <span class="syntax-KEYWORD3">case</span> 1
<span class="gutter">2667 </span>        <span class="syntax-KEYWORD1">from</span> acc_hyp <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(M, M0) &isin; ?R &#10230; add_mset a M &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2668 </span>        <span class="syntax-KEYWORD1">from</span> this <span class="syntax-KEYWORD2">and</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">,</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">0</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">R</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;add_mset a M &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2669 </span>        <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;N &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">=</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">2670 </span>      <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2671 </span>        <span class="syntax-KEYWORD3">case</span> 2
<span class="gutter">2672 </span>        <span class="syntax-KEYWORD1">from</span> this<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M0 + K &isin; ?W&quot;</span>
<span class="gutter">2673 </span>        <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct K<span class="syntax-OPERATOR">)</span>
<span class="gutter">2674 </span>          <span class="syntax-KEYWORD3">case</span> empty
<span class="gutterH">2675 </span>          <span class="syntax-KEYWORD1">from</span> M0 <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;M0 + {#} &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2676 </span>        <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2677 </span>          <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>add x K<span class="syntax-OPERATOR">)</span>
<span class="gutter">2678 </span>          <span class="syntax-KEYWORD1">from</span> add.prems <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(x, a) &isin; r&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2679 </span>          <span class="syntax-KEYWORD1">with</span> wf_hyp <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&forall;M &isin; ?W. add_mset x M &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">2680 </span>          <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> add <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M0 + K &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2681 </span>          <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;add_mset x (M0 + K) &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">2682 </span>          <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;M0 + (add_mset x K) &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2683 </span>        <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2684 </span>        <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;N &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp only<span class="syntax-OPERATOR">:</span> 2<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">2685 </span>      <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2686 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2687 </span>  <span class="syntax-KEYWORD1">}</span> <span class="syntax-KEYWORD1">note</span> tedious_reasoning <span class="syntax-OPERATOR">=</span> this
<span class="gutter">2688 </span>
<span class="gutter">2689 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;M &isin; ?W&quot;</span> <span class="syntax-KEYWORD2">for</span> M
<span class="gutterH">2690 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct M<span class="syntax-OPERATOR">)</span>
<span class="gutter">2691 </span>    <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;{#} &isin; ?W&quot;</span>
<span class="gutter">2692 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>rule accI<span class="syntax-OPERATOR">)</span>
<span class="gutter">2693 </span>      <span class="syntax-KEYWORD3">fix</span> b <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;(b, {#}) &isin; ?R&quot;</span>
<span class="gutter">2694 </span>      <span class="syntax-KEYWORD1">with</span> not_less_empty <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;b &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">by</span> contradiction
<span class="gutterH">2695 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2696 </span>
<span class="gutter">2697 </span>    <span class="syntax-KEYWORD3">fix</span> M a <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;M &isin; ?W&quot;</span>
<span class="gutter">2698 </span>    <span class="syntax-KEYWORD1">from</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&forall;M &isin; ?W. add_mset a M &isin; ?W&quot;</span>
<span class="gutter">2699 </span>    <span class="syntax-KEYWORD1">proof</span> induct
<span class="gutterH">2700 </span>      <span class="syntax-KEYWORD3">fix</span> a
<span class="gutter">2701 </span>      <span class="syntax-KEYWORD3">assume</span> r<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;b. (b, a) &isin; r &#10233; (&forall;M &isin; ?W. add_mset b M &isin; ?W)&quot;</span>
<span class="gutter">2702 </span>      <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;&forall;M &isin; ?W. add_mset a M &isin; ?W&quot;</span>
<span class="gutter">2703 </span>      <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">2704 </span>        <span class="syntax-KEYWORD3">fix</span> M <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;M &isin; ?W&quot;</span>
<span class="gutterH">2705 </span>        <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;add_mset a M &isin; ?W&quot;</span>
<span class="gutter">2706 </span>          <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule acc_induct<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>rule tedious_reasoning <span class="syntax-OPERATOR">[</span>OF _ r<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2707 </span>      <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2708 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2709 </span>    <span class="syntax-KEYWORD1">from</span> this <span class="syntax-KEYWORD2">and</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&isin;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">?</span><span class="syntax-COMMENT4">W</span><span class="syntax-COMMENT4">&rsaquo;</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;add_mset a M &isin; ?W&quot;</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutterH">2710 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2711 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2712 </span>
<span class="gutter">2713 </span><span class="syntax-KEYWORD1">theorem</span> wf_mult1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;wf r &#10233; wf (mult1 r)&quot;</span>
<span class="gutter">2714 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule acc_wfI<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>rule all_accessible<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2715 </span>
<span class="gutter">2716 </span><span class="syntax-KEYWORD1">theorem</span> wf_mult<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;wf r &#10233; wf (mult r)&quot;</span>
<span class="gutter">2717 </span><span class="syntax-KEYWORD1">unfolding</span> mult_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule wf_trancl<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>rule wf_mult1<span class="syntax-OPERATOR">)</span>
<span class="gutter">2718 </span>
<span class="gutter">2719 </span>
<span class="gutterH">2720 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">C</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2721 </span>
<span class="gutter">2722 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">O</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2723 </span><span class="syntax-KEYWORD1">lemma</span> mult_implies_one_step<span class="syntax-OPERATOR">:</span>
<span class="gutter">2724 </span>  <span class="syntax-KEYWORD2">assumes</span>
<span class="gutterH">2725 </span>    trans<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;trans r&quot;</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter">2726 </span>    MN<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M, N) &isin; mult r&quot;</span>
<span class="gutter">2727 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;I J K. N = I + J &and; M = I + K &and; J &ne; {#} &and; (&forall;k &isin; set_mset K. &exist;j &isin; set_mset J. (k, j) &isin; r)&quot;</span>
<span class="gutter">2728 </span>  <span class="syntax-KEYWORD1">using</span> MN <span class="syntax-KEYWORD1">unfolding</span> mult_def mult1_def
<span class="gutter">2729 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induction rule<span class="syntax-OPERATOR">:</span> converse_trancl_induct<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2730 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>base y<span class="syntax-OPERATOR">)</span>
<span class="gutter">2731 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> force
<span class="gutter">2732 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2733 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>step y z<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">note</span> yz <span class="syntax-OPERATOR">=</span> this<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span> zN <span class="syntax-OPERATOR">=</span> this<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span> N_decomp <span class="syntax-OPERATOR">=</span> this<span class="syntax-OPERATOR">(</span>3<span class="syntax-OPERATOR">)</span>
<span class="gutter">2734 </span>  <span class="syntax-KEYWORD3">obtain</span> I J K <span class="syntax-KEYWORD2">where</span>
<span class="gutterH">2735 </span>    N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = I + J&quot;</span> <span class="syntax-LITERAL1">&quot;z = I + K&quot;</span> <span class="syntax-LITERAL1">&quot;J &ne; {#}&quot;</span> <span class="syntax-LITERAL1">&quot;&forall;k&isin;#K. &exist;j&isin;#J. (k, j) &isin; r&quot;</span>
<span class="gutter">2736 </span>    <span class="syntax-KEYWORD1">using</span> N_decomp <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2737 </span>  <span class="syntax-KEYWORD3">obtain</span> a M0 K' <span class="syntax-KEYWORD2">where</span>
<span class="gutter">2738 </span>    z<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;z = add_mset a M0&quot;</span> <span class="syntax-KEYWORD2">and</span> y<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;y = M0 + K'&quot;</span> <span class="syntax-KEYWORD2">and</span> K<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&forall;b. b &isin;# K' &#10230; (b, a) &isin; r&quot;</span>
<span class="gutter">2739 </span>    <span class="syntax-KEYWORD1">using</span> yz <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">2740 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">2741 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;a &isin;# K&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2742 </span>    <span class="syntax-KEYWORD3">case</span> True
<span class="gutter">2743 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&exist;j&isin;#J. (k, j) &isin; r&quot;</span> <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;k &isin;# K'&quot;</span> <span class="syntax-KEYWORD2">for</span> k
<span class="gutter">2744 </span>      <span class="syntax-KEYWORD1">using</span> K N trans True <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>meson that transE<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2745 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2746 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> I <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">,</span> rule_tac x <span class="syntax-OPERATOR">=</span> J <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">,</span> rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;(K - {#a#}) + K'&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">)</span>
<span class="gutter">2747 </span>        <span class="syntax-OPERATOR">(</span>use z y N <span class="syntax-KEYWORD2">in</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">2</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">D</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2748 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2749 </span>    <span class="syntax-KEYWORD3">case</span> False
<span class="gutterH">2750 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;a &isin;# I&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis N<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> union_iff union_single_eq_member z<span class="syntax-OPERATOR">)</span>
<span class="gutter">2751 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;M0 = I + K - {#a#}&quot;</span>
<span class="gutter">2752 </span>      <span class="syntax-KEYWORD1">using</span> N<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> z <span class="syntax-KEYWORD1">by</span> force
<span class="gutter">2753 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2754 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;I - {#a#}&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">,</span> rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;add_mset a J&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">,</span>
<span class="gutterH">2755 </span>          rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;K + K'&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">)</span>
<span class="gutter">2756 </span>        <span class="syntax-OPERATOR">(</span>use z y N False K <span class="syntax-KEYWORD2">in</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2757 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2758 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2759 </span>
<span class="gutterH">2760 </span><span class="syntax-KEYWORD1">lemma</span> one_step_implies_mult<span class="syntax-OPERATOR">:</span>
<span class="gutter">2761 </span>  <span class="syntax-KEYWORD2">assumes</span>
<span class="gutter">2762 </span>    <span class="syntax-LITERAL1">&quot;J &ne; {#}&quot;</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutter">2763 </span>    <span class="syntax-LITERAL1">&quot;&forall;k &isin; set_mset K. &exist;j &isin; set_mset J. (k, j) &isin; r&quot;</span>
<span class="gutter">2764 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(I + K, I + J) &isin; mult r&quot;</span>
<span class="gutterH">2765 </span>  <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">2766 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induction <span class="syntax-LITERAL1">&quot;size J&quot;</span> arbitrary<span class="syntax-OPERATOR">:</span> I J K<span class="syntax-OPERATOR">)</span>
<span class="gutter">2767 </span>  <span class="syntax-KEYWORD3">case</span> 0
<span class="gutter">2768 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2769 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">2770 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Suc n<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">note</span> IH <span class="syntax-OPERATOR">=</span> this<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">and</span> size_J <span class="syntax-OPERATOR">=</span> this<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">[</span>THEN sym<span class="syntax-OPERATOR">]</span>
<span class="gutter">2771 </span>  <span class="syntax-KEYWORD3">obtain</span> J' a <span class="syntax-KEYWORD2">where</span> J<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;J = add_mset a J'&quot;</span>
<span class="gutter">2772 </span>    <span class="syntax-KEYWORD1">using</span> size_J <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> size_eq_Suc_imp_eq_union<span class="syntax-OPERATOR">)</span>
<span class="gutter">2773 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">2774 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;J' = {#}&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">2775 </span>    <span class="syntax-KEYWORD3">case</span> True
<span class="gutter">2776 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2777 </span>      <span class="syntax-KEYWORD1">using</span> J Suc <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fastforce simp add<span class="syntax-OPERATOR">:</span> mult_def mult1_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2778 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2779 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> False
<span class="gutterH">2780 </span>    <span class="syntax-KEYWORD1">have</span> K<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K = {#x &isin;# K. (x, a) &isin; r#} + {#x &isin;# K. (x, a) &notin; r#}&quot;</span>
<span class="gutter">2781 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule multiset_partition<span class="syntax-OPERATOR">)</span>
<span class="gutter">2782 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(I + K, (I + {# x &isin;# K. (x, a) &isin; r #}) + J') &isin; mult r&quot;</span>
<span class="gutter">2783 </span>      <span class="syntax-KEYWORD1">using</span> IH<span class="syntax-OPERATOR">[</span>of J' <span class="syntax-LITERAL1">&quot;{# x &isin;# K. (x, a) &notin; r#}&quot;</span> <span class="syntax-LITERAL1">&quot;I + {# x &isin;# K. (x, a) &isin; r#}&quot;</span><span class="syntax-OPERATOR">]</span>
<span class="gutter">2784 </span>        J Suc.prems K size_J <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2785 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(I + {#x &isin;# K. (x, a) &isin; r#} + J', I + J) &isin; mult r&quot;</span>
<span class="gutter">2786 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fastforce simp<span class="syntax-OPERATOR">:</span> J mult1_def mult_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2787 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2788 </span>      <span class="syntax-KEYWORD1">unfolding</span> mult_def <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2789 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2790 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2791 </span>
<span class="gutter">2792 </span>
<span class="gutter">2793 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2794 </span>
<span class="gutterH">2795 </span><span class="syntax-KEYWORD1">lemma</span> mult_cancel<span class="syntax-OPERATOR">:</span>
<span class="gutter">2796 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;trans s&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;irrefl s&quot;</span>
<span class="gutter">2797 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(X + Z, Y + Z) &isin; mult s &#10231; (X, Y) &isin; mult s&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?L &#10231; ?R&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2798 </span><span class="syntax-KEYWORD1">proof</span>
<span class="gutter">2799 </span>  <span class="syntax-KEYWORD3">assume</span> ?L <span class="syntax-KEYWORD3">thus</span> ?R
<span class="gutterH">2800 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct Z<span class="syntax-OPERATOR">)</span>
<span class="gutter">2801 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>add z Z<span class="syntax-OPERATOR">)</span>
<span class="gutter">2802 </span>    <span class="syntax-KEYWORD3">obtain</span> X' Y' Z' <span class="syntax-KEYWORD2">where</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset z X + Z = Z' + X'&quot;</span> <span class="syntax-LITERAL1">&quot;add_mset z Y + Z = Z' + Y'&quot;</span> <span class="syntax-LITERAL1">&quot;Y' &ne; {#}&quot;</span>
<span class="gutter">2803 </span>      <span class="syntax-LITERAL1">&quot;&forall;x &isin; set_mset X'. &exist;y &isin; set_mset Y'. (x, y) &isin; s&quot;</span>
<span class="gutter">2804 </span>      <span class="syntax-KEYWORD1">using</span> mult_implies_one_step<span class="syntax-OPERATOR">[</span>OF <span class="syntax-LITERAL2">`trans s`</span> add<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">2805 </span>    <span class="syntax-KEYWORD1">consider</span> Z2 <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;Z' = add_mset z Z2&quot;</span> <span class="syntax-OPERATOR">|</span> X2 Y2 <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;X' = add_mset z X2&quot;</span> <span class="syntax-LITERAL1">&quot;Y' = add_mset z Y2&quot;</span>
<span class="gutter">2806 </span>      <span class="syntax-KEYWORD1">using</span> *<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">,</span>2<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_mset_remove_trivial_If insert_iff set_mset_add_mset_insert union_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">2807 </span>    <span class="syntax-KEYWORD3">thus</span> ?case
<span class="gutter">2808 </span>    <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases<span class="syntax-OPERATOR">)</span>
<span class="gutter">2809 </span>      <span class="syntax-KEYWORD3">case</span> 1 <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> * one_step_implies_mult<span class="syntax-OPERATOR">[</span>of Y' X' s Z2<span class="syntax-OPERATOR">]</span>
<span class="gutterH">2810 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> add.commute<span class="syntax-OPERATOR">[</span>of _ <span class="syntax-LITERAL1">&quot;{#_#}&quot;</span><span class="syntax-OPERATOR">]</span> add.assoc intro<span class="syntax-OPERATOR">:</span> add<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2811 </span>    <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2812 </span>      <span class="syntax-KEYWORD3">case</span> 2 <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> y <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;y &isin; set_mset Y2&quot;</span> <span class="syntax-LITERAL1">&quot;(z, y) &isin; s&quot;</span> <span class="syntax-KEYWORD1">using</span> *<span class="syntax-OPERATOR">(</span>4<span class="syntax-OPERATOR">)</span> <span class="syntax-LITERAL2">`irrefl s`</span>
<span class="gutter">2813 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> irrefl_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2814 </span>      <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> this transD<span class="syntax-OPERATOR">[</span>OF <span class="syntax-LITERAL2">`trans s`</span> _ this<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">]</span>
<span class="gutterH">2815 </span>      <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;x' &isin; set_mset X2 &#10233; &exist;y &isin; set_mset Y2. (x', y) &isin; s&quot;</span> <span class="syntax-KEYWORD2">for</span> x'
<span class="gutter">2816 </span>        <span class="syntax-KEYWORD1">using</span> 2 *<span class="syntax-OPERATOR">(</span>4<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">[</span>rule_format<span class="syntax-OPERATOR">,</span> of x'<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2817 </span>      <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">using</span>  * one_step_implies_mult<span class="syntax-OPERATOR">[</span>of Y2 X2 s Z'<span class="syntax-OPERATOR">]</span> 2
<span class="gutter">2818 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>force simp<span class="syntax-OPERATOR">:</span> add.commute<span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;{#_#}&quot;</span><span class="syntax-OPERATOR">]</span> add.assoc<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> intro<span class="syntax-OPERATOR">:</span> add<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2819 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2820 </span>  <span class="syntax-KEYWORD1">qed</span> auto
<span class="gutter">2821 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">2822 </span>  <span class="syntax-KEYWORD3">assume</span> ?R <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> I J K
<span class="gutter">2823 </span>    <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;Y = I + J&quot;</span> <span class="syntax-LITERAL1">&quot;X = I + K&quot;</span> <span class="syntax-LITERAL1">&quot;J &ne; {#}&quot;</span> <span class="syntax-LITERAL1">&quot;&forall;k &isin; set_mset K. &exist;j &isin; set_mset J. (k, j) &isin; s&quot;</span>
<span class="gutter">2824 </span>    <span class="syntax-KEYWORD1">using</span> mult_implies_one_step<span class="syntax-OPERATOR">[</span>OF <span class="syntax-LITERAL2">`trans s`</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">2825 </span>  <span class="syntax-KEYWORD3">thus</span> ?L <span class="syntax-KEYWORD1">using</span> one_step_implies_mult<span class="syntax-OPERATOR">[</span>of J K s <span class="syntax-LITERAL1">&quot;I + Z&quot;</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">2826 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2827 </span>
<span class="gutter">2828 </span><span class="syntax-KEYWORD1">lemma</span> mult_cancel_max<span class="syntax-OPERATOR">:</span>
<span class="gutter">2829 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;trans s&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;irrefl s&quot;</span>
<span class="gutterH">2830 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;(X, Y) &isin; mult s &#10231; (X - X &cap;# Y, Y - X &cap;# Y) &isin; mult s&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?L &#10231; ?R&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2831 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2832 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;X - X &cap;# Y + X &cap;# Y = X&quot;</span> <span class="syntax-LITERAL1">&quot;Y - X &cap;# Y + X &cap;# Y = Y&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> count_inject<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2833 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> mult_cancel<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">,</span> of <span class="syntax-LITERAL1">&quot;X - X &cap;# Y&quot;</span>  <span class="syntax-LITERAL1">&quot;X &cap;# Y&quot;</span> <span class="syntax-LITERAL1">&quot;Y - X &cap;# Y&quot;</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2834 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2835 </span>
<span class="gutter">2836 </span>
<span class="gutter">2837 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">Q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2838 </span>
<span class="gutter">2839 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutterH">2840 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">,</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span>
<span class="gutter">2841 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">x</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">.</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span>
<span class="gutter">2842 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&cap;</span><span class="syntax-COMMENT4">#</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span>
<span class="gutter">2843 </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">(</span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">)</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">q</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">&rsaquo;</span><span class="syntax-COMMENT4">.</span>
<span class="gutter">2844 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">2845 </span>
<span class="gutter">2846 </span><span class="syntax-KEYWORD1">definition</span> multp <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; 'a &rArr; bool) &rArr; 'a multiset &rArr; 'a multiset &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">2847 </span>  <span class="syntax-LITERAL1">&quot;multp P N M =</span>
<span class="gutter">2848 </span><span class="syntax-LITERAL1">    (let Z = M &cap;# N; X = M - Z in</span>
<span class="gutter">2849 </span><span class="syntax-LITERAL1">    X &ne; {#} &and; (let Y = N - Z in (&forall;y &isin; set_mset Y. &exist;x &isin; set_mset X. P y x)))&quot;</span>
<span class="gutterH">2850 </span>
<span class="gutter">2851 </span><span class="syntax-KEYWORD1">definition</span> multeqp <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; 'a &rArr; bool) &rArr; 'a multiset &rArr; 'a multiset &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">2852 </span>  <span class="syntax-LITERAL1">&quot;multeqp P N M =</span>
<span class="gutter">2853 </span><span class="syntax-LITERAL1">    (let Z = M &cap;# N; X = M - Z; Y = N - Z in</span>
<span class="gutter">2854 </span><span class="syntax-LITERAL1">    (&forall;y &isin; set_mset Y. &exist;x &isin; set_mset X. P y x))&quot;</span>
<span class="gutterH">2855 </span>
<span class="gutter">2856 </span><span class="syntax-KEYWORD1">lemma</span> multp_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2857 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;irrefl R&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;trans R&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;x y. P x y &#10231; (x, y) &isin; R&quot;</span>
<span class="gutter">2858 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;multp P N M &#10231; (N, M) &isin; mult R&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">is</span> <span class="syntax-LITERAL1">&quot;?L &#10231; ?R&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2859 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">2860 </span>  <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M &cap;# N + (N - M &cap;# N) = N&quot;</span> <span class="syntax-LITERAL1">&quot;M &cap;# N + (M - M &cap;# N) = M&quot;</span>
<span class="gutter">2861 </span>    <span class="syntax-LITERAL1">&quot;(M - M &cap;# N) &cap;# (N - M &cap;# N) = {#}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> count_inject<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2862 </span>  <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">2863 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">2864 </span>    <span class="syntax-KEYWORD3">assume</span> ?L <span class="syntax-KEYWORD3">thus</span> ?R
<span class="gutterH">2865 </span>      <span class="syntax-KEYWORD1">using</span> one_step_implies_mult<span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;M - M &cap;# N&quot;</span> <span class="syntax-LITERAL1">&quot;N - M &cap;# N&quot;</span> R <span class="syntax-LITERAL1">&quot;M &cap;# N&quot;</span><span class="syntax-OPERATOR">]</span> *
<span class="gutter">2866 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multp_def Let_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2867 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">2868 </span>    <span class="syntax-KEYWORD1">{</span> <span class="syntax-KEYWORD3">fix</span> I J K <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span> <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;(I + J) &cap;# (I + K) = {#}&quot;</span>
<span class="gutter">2869 </span>      <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;I = {#}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis inter_union_distrib_right union_eq_empty<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2870 </span>    <span class="syntax-KEYWORD1">}</span> <span class="syntax-KEYWORD1">note</span> <span class="syntax-OPERATOR">[</span>dest<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">]</span> <span class="syntax-OPERATOR">=</span> this
<span class="gutter">2871 </span>    <span class="syntax-KEYWORD3">assume</span> ?R <span class="syntax-KEYWORD3">thus</span> ?L
<span class="gutter">2872 </span>      <span class="syntax-KEYWORD1">using</span> mult_implies_one_step<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">,</span> of <span class="syntax-LITERAL1">&quot;N - M &cap;# N&quot;</span> <span class="syntax-LITERAL1">&quot;M - M &cap;# N&quot;</span><span class="syntax-OPERATOR">]</span>
<span class="gutter">2873 </span>        mult_cancel_max<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">,</span>1<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">,</span> of <span class="syntax-LITERAL1">&quot;N&quot;</span> <span class="syntax-LITERAL1">&quot;M&quot;</span><span class="syntax-OPERATOR">]</span> * <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multp_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2874 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2875 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2876 </span>
<span class="gutter">2877 </span><span class="syntax-KEYWORD1">lemma</span> multeqp_iff<span class="syntax-OPERATOR">:</span>
<span class="gutter">2878 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;irrefl R&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;trans R&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;&#8896;x y. P x y &#10231; (x, y) &isin; R&quot;</span>
<span class="gutter">2879 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1">e</span><span class="syntax-LITERAL1">q</span><span class="syntax-LITERAL1">p</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">P</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&#10231;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">N</span><span class="syntax-LITERAL1">,</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">M</span><span class="syntax-LITERAL1">)</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">&isin;</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">(</span><span class="syntax-LITERAL1">m</span><span class="syntax-LITERAL1">u</span><span class="syntax-LITERAL1">l</span><span class="syntax-LITERAL1">t</span><span class="syntax-LITERAL1"> </span><span class="syntax-LITERAL1">R</span><span class="syntax-LITERAL1">)</span><span class="syntax-NULL">&#8679;</span><span class="syntax-LITERAL1">=</span><span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">2880 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2881 </span>  <span class="syntax-KEYWORD1">{</span> <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;N &ne; M&quot;</span> <span class="syntax-LITERAL1">&quot;M - M &cap;# N = {#}&quot;</span>
<span class="gutter">2882 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> y <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;count N y &ne; count M y&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> count_inject<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2883 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&exist;y. count M y &lt; count N y&quot;</span> <span class="syntax-KEYWORD1">using</span> <span class="syntax-LITERAL2">`M - M &cap;# N = {#}`</span>
<span class="gutter">2884 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> count_inject<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> dest<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> le_neq_implies_less fun_cong<span class="syntax-OPERATOR">[</span>of _ _ y<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">2885 </span>  <span class="syntax-KEYWORD1">}</span>
<span class="gutter">2886 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;multeqp P N M &#10231; multp P N M &or; N = M&quot;</span>
<span class="gutter">2887 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> multeqp_def multp_def Let_def in_diff_count<span class="syntax-OPERATOR">)</span>
<span class="gutter">2888 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> multp_iff<span class="syntax-OPERATOR">[</span>OF assms<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2889 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2890 </span>
<span class="gutter">2891 </span>
<span class="gutter">2892 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">P</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2893 </span>
<span class="gutter">2894 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> preorder<span class="syntax-OPERATOR">)</span> mult1_lessE<span class="syntax-OPERATOR">:</span>
<span class="gutterH">2895 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;(N, M) &isin; mult1 {(a, b). a &lt; b}&quot;</span>
<span class="gutter">2896 </span>  <span class="syntax-KEYWORD2">obtains</span> a M0 K <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M0&quot;</span> <span class="syntax-LITERAL1">&quot;N = M0 + K&quot;</span>
<span class="gutter">2897 </span>    <span class="syntax-LITERAL1">&quot;a &notin;# K&quot;</span> <span class="syntax-LITERAL1">&quot;&#8896;b. b &isin;# K &#10233; b &lt; a&quot;</span>
<span class="gutter">2898 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2899 </span>  <span class="syntax-KEYWORD1">from</span> assms <span class="syntax-KEYWORD3">obtain</span> a M0 K <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M0&quot;</span> <span class="syntax-LITERAL1">&quot;N = M0 + K&quot;</span> <span class="syntax-KEYWORD2">and</span>
<span class="gutterH">2900 </span>    *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;b &isin;# K &#10233; b &lt; a&quot;</span> <span class="syntax-KEYWORD2">for</span> b <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast elim<span class="syntax-OPERATOR">:</span> mult1E<span class="syntax-OPERATOR">)</span>
<span class="gutter">2901 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">from</span> * <span class="syntax-OPERATOR">[</span>of a<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;a &notin;# K&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2902 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> that<span class="syntax-OPERATOR">)</span>
<span class="gutter">2903 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">2904 </span>
<span class="gutterH">2905 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>preorder<span class="syntax-OPERATOR">)</span> order
<span class="gutter">2906 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2907 </span>
<span class="gutter">2908 </span><span class="syntax-KEYWORD1">definition</span> less_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span>
<span class="gutter">2909 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M' &lt; M &#10231; (M', M) &isin; mult {(x', x). x' &lt; x}&quot;</span>
<span class="gutterH">2910 </span>
<span class="gutter">2911 </span><span class="syntax-KEYWORD1">definition</span> less_eq_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset &rArr; 'a multiset &rArr; bool&quot;</span>
<span class="gutter">2912 </span>  <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;less_eq_multiset M' M &#10231; M' &lt; M &or; M' = M&quot;</span>
<span class="gutter">2913 </span>
<span class="gutter">2914 </span><span class="syntax-KEYWORD1">instance</span>
<span class="gutterH">2915 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">2916 </span>  <span class="syntax-KEYWORD1">have</span> irrefl<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; M &lt; M&quot;</span> <span class="syntax-KEYWORD2">for</span> M <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter">2917 </span>  <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">2918 </span>    <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;M &lt; M&quot;</span>
<span class="gutter">2919 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> MM<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M, M) &isin; mult {(x, y). x &lt; y}&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> less_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2920 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;trans {(x'::'a, x). x' &lt; x}&quot;</span>
<span class="gutter">2921 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis <span class="syntax-OPERATOR">(</span>mono_tags<span class="syntax-OPERATOR">,</span> lifting<span class="syntax-OPERATOR">)</span> case_prodD case_prodI less_trans mem_Collect_eq transI<span class="syntax-OPERATOR">)</span>
<span class="gutter">2922 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">note</span> MM
<span class="gutter">2923 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&exist;I J K. M = I + J &and; M = I + K</span>
<span class="gutter">2924 </span><span class="syntax-LITERAL1">      &and; J &ne; {#} &and; (&forall;k&isin;set_mset K. &exist;j&isin;set_mset J. (k, j) &isin; {(x, y). x &lt; y})&quot;</span>
<span class="gutterH">2925 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule mult_implies_one_step<span class="syntax-OPERATOR">)</span>
<span class="gutter">2926 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> I J K <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;M = I + J&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;M = I + K&quot;</span>
<span class="gutter">2927 </span>      <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;J &ne; {#}&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;(&forall;k&isin;set_mset K. &exist;j&isin;set_mset J. (k, j) &isin; {(x, y). x &lt; y})&quot;</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">2928 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD1">have</span> *<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K &ne; {#}&quot;</span> <span class="syntax-KEYWORD2">and</span> **<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&forall;k&isin;set_mset K. &exist;j&isin;set_mset K. k &lt; j&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2929 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;finite (set_mset K)&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">2930 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">note</span> **
<span class="gutter">2931 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;set_mset K = {}&quot;</span>
<span class="gutter">2932 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> order_less_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">2933 </span>    <span class="syntax-KEYWORD1">with</span> * <span class="syntax-KEYWORD3">show</span> False <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2934 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2935 </span>  <span class="syntax-KEYWORD1">have</span> trans<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K &lt; M &#10233; M &lt; N &#10233; K &lt; N&quot;</span> <span class="syntax-KEYWORD2">for</span> K M N <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutter">2936 </span>    <span class="syntax-KEYWORD1">unfolding</span> less_multiset_def mult_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast intro<span class="syntax-OPERATOR">:</span> trancl_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">2937 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;OFCLASS('a multiset, order_class)&quot;</span>
<span class="gutter">2938 </span>    <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> less_eq_multiset_def irrefl dest<span class="syntax-OPERATOR">:</span> trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">2939 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">2940 </span><span class="syntax-KEYWORD2">end</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4">I</span><span class="syntax-COMMENT4">X</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">E</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">j</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2941 </span>
<span class="gutter">2942 </span><span class="syntax-KEYWORD1">lemma</span> mset_le_irrefl <span class="syntax-OPERATOR">[</span>elim<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">2943 </span>  <span class="syntax-KEYWORD2">fixes</span> M <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a::preorder multiset&quot;</span>
<span class="gutter">2944 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;M &lt; M &#10233; R&quot;</span>
<span class="gutterH">2945 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">2946 </span>
<span class="gutter">2947 </span>
<span class="gutter">2948 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">M</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2949 </span>
<span class="gutterH">2950 </span><span class="syntax-KEYWORD1">lemma</span> mult1_union<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(B, D) &isin; mult1 r &#10233; (C + B, C + D) &isin; mult1 r&quot;</span>
<span class="gutter">2951 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>force simp<span class="syntax-OPERATOR">:</span> mult1_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2952 </span>
<span class="gutter">2953 </span><span class="syntax-KEYWORD1">lemma</span> union_le_mono2<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B &lt; D &#10233; C + B &lt; C + (D::'a::preorder multiset)&quot;</span>
<span class="gutter">2954 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>unfold less_multiset_def mult_def<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2955 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>erule trancl_induct<span class="syntax-OPERATOR">)</span>
<span class="gutter">2956 </span> <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>blast intro<span class="syntax-OPERATOR">:</span> mult1_union<span class="syntax-OPERATOR">)</span>
<span class="gutter">2957 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>blast intro<span class="syntax-OPERATOR">:</span> mult1_union trancl_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">2958 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">2959 </span>
<span class="gutterH">2960 </span><span class="syntax-KEYWORD1">lemma</span> union_le_mono1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;B &lt; D &#10233; B + C &lt; D + (C::'a::preorder multiset)&quot;</span>
<span class="gutter">2961 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>subst add.commute <span class="syntax-OPERATOR">[</span>of B C<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2962 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>subst add.commute <span class="syntax-OPERATOR">[</span>of D C<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">2963 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>erule union_le_mono2<span class="syntax-OPERATOR">)</span>
<span class="gutter">2964 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutterH">2965 </span>
<span class="gutter">2966 </span><span class="syntax-KEYWORD1">lemma</span> union_less_mono<span class="syntax-OPERATOR">:</span>
<span class="gutter">2967 </span>  <span class="syntax-KEYWORD2">fixes</span> A B C D <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a::preorder multiset&quot;</span>
<span class="gutter">2968 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;A &lt; C &#10233; B &lt; D &#10233; A + B &lt; C + D&quot;</span>
<span class="gutter">2969 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> union_le_mono1 union_le_mono2 less_trans<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2970 </span>
<span class="gutter">2971 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>preorder<span class="syntax-OPERATOR">)</span> ordered_ab_semigroup_add
<span class="gutter">2972 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">2973 </span><span class="syntax-KEYWORD1">instance</span>
<span class="gutter">2974 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> less_eq_multiset_def intro<span class="syntax-OPERATOR">:</span> union_le_mono2<span class="syntax-OPERATOR">)</span>
<span class="gutterH">2975 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">2976 </span>
<span class="gutter">2977 </span>
<span class="gutter">2978 </span><span class="syntax-KEYWORD1">subsubsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">w</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">2979 </span>
<span class="gutterH">2980 </span><span class="syntax-KEYWORD1">lemma</span> multi_member_skip<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# XS &#10233; x &isin;# {# y #} + XS&quot;</span>
<span class="gutter">2981 </span>  <span class="syntax-KEYWORD2">and</span> multi_member_this<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# {# x #} + XS&quot;</span>
<span class="gutter">2982 </span>  <span class="syntax-KEYWORD2">and</span> multi_member_last<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &isin;# {# x #}&quot;</span>
<span class="gutter">2983 </span>  <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">2984 </span>
<span class="gutterH">2985 </span><span class="syntax-KEYWORD1">definition</span> <span class="syntax-LITERAL1">&quot;ms_strict = mult pair_less&quot;</span>
<span class="gutter">2986 </span><span class="syntax-KEYWORD1">definition</span> <span class="syntax-LITERAL1">&quot;ms_weak = ms_strict &cup; Id&quot;</span>
<span class="gutter">2987 </span>
<span class="gutter">2988 </span><span class="syntax-KEYWORD1">lemma</span> ms_reduction_pair<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;reduction_pair (ms_strict, ms_weak)&quot;</span>
<span class="gutter">2989 </span><span class="syntax-KEYWORD1">unfolding</span> reduction_pair_def ms_strict_def ms_weak_def pair_less_def
<span class="gutterH">2990 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> wf_mult1 wf_trancl simp<span class="syntax-OPERATOR">:</span> mult_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">2991 </span>
<span class="gutter">2992 </span><span class="syntax-KEYWORD1">lemma</span> smsI<span class="syntax-OPERATOR">:</span>
<span class="gutter">2993 </span>  <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict &#10233; (Z + A, Z + B) &isin; ms_strict&quot;</span>
<span class="gutter">2994 </span>  <span class="syntax-KEYWORD1">unfolding</span> ms_strict_def
<span class="gutterH">2995 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule one_step_implies_mult<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> max_strict_def pair_less_def elim<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span>max_ext.cases<span class="syntax-OPERATOR">)</span>
<span class="gutter">2996 </span>
<span class="gutter">2997 </span><span class="syntax-KEYWORD1">lemma</span> wmsI<span class="syntax-OPERATOR">:</span>
<span class="gutter">2998 </span>  <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict &or; A = {#} &and; B = {#}</span>
<span class="gutter">2999 </span><span class="syntax-LITERAL1">  &#10233; (Z + A, Z + B) &isin; ms_weak&quot;</span>
<span class="gutterH">3000 </span><span class="syntax-KEYWORD1">unfolding</span> ms_weak_def ms_strict_def
<span class="gutter">3001 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> pair_less_def max_strict_def elim<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span>max_ext.cases intro<span class="syntax-OPERATOR">:</span> one_step_implies_mult<span class="syntax-OPERATOR">)</span>
<span class="gutter">3002 </span>
<span class="gutter">3003 </span><span class="syntax-KEYWORD1">inductive</span> pw_leq
<span class="gutter">3004 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutterH">3005 </span>  pw_leq_empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;pw_leq {#} {#}&quot;</span>
<span class="gutter">3006 </span><span class="syntax-OPERATOR">|</span> pw_leq_step<span class="syntax-OPERATOR">:</span>  <span class="syntax-LITERAL1">&quot;&#10214;(x,y) &isin; pair_leq; pw_leq X Y &#10215; &#10233; pw_leq ({#x#} + X) ({#y#} + Y)&quot;</span>
<span class="gutter">3007 </span>
<span class="gutter">3008 </span><span class="syntax-KEYWORD1">lemma</span> pw_leq_lstep<span class="syntax-OPERATOR">:</span>
<span class="gutter">3009 </span>  <span class="syntax-LITERAL1">&quot;(x, y) &isin; pair_leq &#10233; pw_leq {#x#} {#y#}&quot;</span>
<span class="gutterH">3010 </span><span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>drule pw_leq_step<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>rule pw_leq_empty<span class="syntax-OPERATOR">,</span> simp<span class="syntax-OPERATOR">)</span>
<span class="gutter">3011 </span>
<span class="gutter">3012 </span><span class="syntax-KEYWORD1">lemma</span> pw_leq_split<span class="syntax-OPERATOR">:</span>
<span class="gutter">3013 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;pw_leq X Y&quot;</span>
<span class="gutter">3014 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;A B Z. X = A + Z &and; Y = B + Z &and; ((set_mset A, set_mset B) &isin; max_strict &or; (B = {#} &and; A = {#}))&quot;</span>
<span class="gutterH">3015 </span>  <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">3016 </span><span class="syntax-KEYWORD1">proof</span> induct
<span class="gutter">3017 </span>  <span class="syntax-KEYWORD3">case</span> pw_leq_empty <span class="syntax-KEYWORD3">thus</span> ?case <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3018 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">3019 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>pw_leq_step x y X Y<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3020 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> A B Z <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3021 </span>    <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;X = A + Z&quot;</span> <span class="syntax-LITERAL1">&quot;Y = B + Z&quot;</span>
<span class="gutter">3022 </span>      <span class="syntax-KEYWORD2">and</span> 1<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict &or; (B = {#} &and; A = {#})&quot;</span>
<span class="gutter">3023 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3024 </span>  <span class="syntax-KEYWORD1">from</span> pw_leq_step <span class="syntax-KEYWORD1">consider</span> <span class="syntax-LITERAL1">&quot;x = y&quot;</span> <span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;(x, y) &isin; pair_less&quot;</span>
<span class="gutterH">3025 </span>    <span class="syntax-KEYWORD1">unfolding</span> pair_leq_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3026 </span>  <span class="syntax-KEYWORD3">thus</span> ?case
<span class="gutter">3027 </span>  <span class="syntax-KEYWORD1">proof</span> cases
<span class="gutter">3028 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> 1
<span class="gutter">3029 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{#x#} + X = A + ({#y#}+Z) &and; {#y#} + Y = B + ({#y#}+Z) &and;</span>
<span class="gutterH">3030 </span><span class="syntax-LITERAL1">      ((set_mset A, set_mset B) &isin; max_strict &or; (B = {#} &and; A = {#}))&quot;</span>
<span class="gutter">3031 </span>      <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3032 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3033 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">3034 </span>    <span class="syntax-KEYWORD3">case</span> 2
<span class="gutterH">3035 </span>    <span class="syntax-KEYWORD1">let</span> ?A' <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;{#x#} + A&quot;</span> <span class="syntax-KEYWORD2">and</span> ?B' <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;{#y#} + B&quot;</span>
<span class="gutter">3036 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;{#x#} + X = ?A' + Z&quot;</span>
<span class="gutter">3037 </span>      <span class="syntax-LITERAL1">&quot;{#y#} + Y = ?B' + Z&quot;</span>
<span class="gutter">3038 </span>      <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3039 </span>    <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span>
<span class="gutterH">3040 </span>      <span class="syntax-LITERAL1">&quot;(set_mset ?A', set_mset ?B') &isin; max_strict&quot;</span>
<span class="gutter">3041 </span>      <span class="syntax-KEYWORD1">using</span> 1 2 <span class="syntax-KEYWORD1">unfolding</span> max_strict_def
<span class="gutter">3042 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto elim<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> max_ext.cases<span class="syntax-OPERATOR">)</span>
<span class="gutter">3043 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3044 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3045 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3046 </span>
<span class="gutter">3047 </span><span class="syntax-KEYWORD1">lemma</span>
<span class="gutter">3048 </span>  <span class="syntax-KEYWORD2">assumes</span> pwleq<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;pw_leq Z Z'&quot;</span>
<span class="gutter">3049 </span>  <span class="syntax-KEYWORD2">shows</span> ms_strictI<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict &#10233; (Z + A, Z' + B) &isin; ms_strict&quot;</span>
<span class="gutterH">3050 </span>    <span class="syntax-KEYWORD2">and</span> ms_weakI1<span class="syntax-OPERATOR">:</span>  <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict &#10233; (Z + A, Z' + B) &isin; ms_weak&quot;</span>
<span class="gutter">3051 </span>    <span class="syntax-KEYWORD2">and</span> ms_weakI2<span class="syntax-OPERATOR">:</span>  <span class="syntax-LITERAL1">&quot;(Z + {#}, Z' + {#}) &isin; ms_weak&quot;</span>
<span class="gutter">3052 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3053 </span>  <span class="syntax-KEYWORD1">from</span> pw_leq_split<span class="syntax-OPERATOR">[</span>OF pwleq<span class="syntax-OPERATOR">]</span>
<span class="gutter">3054 </span>  <span class="syntax-KEYWORD3">obtain</span> A' B' Z''
<span class="gutterH">3055 </span>    <span class="syntax-KEYWORD2">where</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;Z = A' + Z''&quot;</span> <span class="syntax-LITERAL1">&quot;Z' = B' + Z''&quot;</span>
<span class="gutter">3056 </span>    <span class="syntax-KEYWORD2">and</span> mx_or_empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(set_mset A', set_mset B') &isin; max_strict &or; (A' = {#} &and; B' = {#})&quot;</span>
<span class="gutter">3057 </span>    <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3058 </span>  <span class="syntax-KEYWORD1">{</span>
<span class="gutter">3059 </span>    <span class="syntax-KEYWORD3">assume</span> max<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(set_mset A, set_mset B) &isin; max_strict&quot;</span>
<span class="gutterH">3060 </span>    <span class="syntax-KEYWORD1">from</span> mx_or_empty
<span class="gutter">3061 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(Z'' + (A + A'), Z'' + (B + B')) &isin; ms_strict&quot;</span>
<span class="gutter">3062 </span>    <span class="syntax-KEYWORD1">proof</span>
<span class="gutter">3063 </span>      <span class="syntax-KEYWORD3">assume</span> max'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(set_mset A', set_mset B') &isin; max_strict&quot;</span>
<span class="gutter">3064 </span>      <span class="syntax-KEYWORD1">with</span> max <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(set_mset (A + A'), set_mset (B + B')) &isin; max_strict&quot;</span>
<span class="gutterH">3065 </span>        <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> max_strict_def intro<span class="syntax-OPERATOR">:</span> max_ext_additive<span class="syntax-OPERATOR">)</span>
<span class="gutter">3066 </span>      <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule smsI<span class="syntax-OPERATOR">)</span>
<span class="gutter">3067 </span>    <span class="syntax-KEYWORD1">next</span>
<span class="gutter">3068 </span>      <span class="syntax-KEYWORD3">assume</span> <span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A' = {#} &and; B' = {#}&quot;</span>
<span class="gutter">3069 </span>      <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule smsI<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> max<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3070 </span>    <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3071 </span>    <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;(Z + A, Z' + B) &isin; ms_strict&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">3072 </span>    <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;(Z + A, Z' + B) &isin; ms_weak&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ms_weak_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">3073 </span>  <span class="syntax-KEYWORD1">}</span>
<span class="gutter">3074 </span>  <span class="syntax-KEYWORD1">from</span> mx_or_empty
<span class="gutterH">3075 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;(Z'' + A', Z'' + B') &isin; ms_weak&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule wmsI<span class="syntax-OPERATOR">)</span>
<span class="gutter">3076 </span>  <span class="syntax-KEYWORD3">thus</span> <span class="syntax-LITERAL1">&quot;(Z + {#}, Z' + {#}) &isin; ms_weak&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">3077 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3078 </span>
<span class="gutter">3079 </span><span class="syntax-KEYWORD1">lemma</span> empty_neutral<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} + x = x&quot;</span> <span class="syntax-LITERAL1">&quot;x + {#} = x&quot;</span>
<span class="gutterH">3080 </span><span class="syntax-KEYWORD2">and</span> nonempty_plus<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{# x #} + rs &ne; {#}&quot;</span>
<span class="gutter">3081 </span><span class="syntax-KEYWORD2">and</span> nonempty_single<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{# x #} &ne; {#}&quot;</span>
<span class="gutter">3082 </span><span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3083 </span>
<span class="gutter">3084 </span><span class="syntax-KEYWORD1">setup</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutterH">3085 </span><span class="syntax-COMMENT4">  let</span>
<span class="gutter">3086 </span><span class="syntax-COMMENT4">    fun msetT T = Type (@{type_name multiset}, [T]);</span>
<span class="gutter">3087 </span>
<span class="gutter">3088 </span><span class="syntax-COMMENT4">    fun mk_mset T [] = Const (@{const_abbrev Mempty}, msetT T)</span>
<span class="gutter">3089 </span><span class="syntax-COMMENT4">      | mk_mset T [x] =</span>
<span class="gutterH">3090 </span><span class="syntax-COMMENT4">        Const (@{const_name add_mset}, T --&gt; msetT T --&gt; msetT T) $ x $</span>
<span class="gutter">3091 </span><span class="syntax-COMMENT4">          Const (@{const_abbrev Mempty}, msetT T)</span>
<span class="gutter">3092 </span><span class="syntax-COMMENT4">      | mk_mset T (x :: xs) =</span>
<span class="gutter">3093 </span><span class="syntax-COMMENT4">        Const (@{const_name plus}, msetT T --&gt; msetT T --&gt; msetT T) $</span>
<span class="gutter">3094 </span><span class="syntax-COMMENT4">          mk_mset T [x] $ mk_mset T xs</span>
<span class="gutterH">3095 </span>
<span class="gutter">3096 </span><span class="syntax-COMMENT4">    fun mset_member_tac ctxt m i =</span>
<span class="gutter">3097 </span><span class="syntax-COMMENT4">      if m &lt;= 0 then</span>
<span class="gutter">3098 </span><span class="syntax-COMMENT4">        resolve_tac ctxt @{thms multi_member_this} i ORELSE</span>
<span class="gutter">3099 </span><span class="syntax-COMMENT4">        resolve_tac ctxt @{thms multi_member_last} i</span>
<span class="gutterH">3100 </span><span class="syntax-COMMENT4">      else</span>
<span class="gutter">3101 </span><span class="syntax-COMMENT4">        resolve_tac ctxt @{thms multi_member_skip} i THEN mset_member_tac ctxt (m - 1) i</span>
<span class="gutter">3102 </span>
<span class="gutter">3103 </span><span class="syntax-COMMENT4">    fun mset_nonempty_tac ctxt =</span>
<span class="gutter">3104 </span><span class="syntax-COMMENT4">      resolve_tac ctxt @{thms nonempty_plus} ORELSE'</span>
<span class="gutterH">3105 </span><span class="syntax-COMMENT4">      resolve_tac ctxt @{thms nonempty_single}</span>
<span class="gutter">3106 </span>
<span class="gutter">3107 </span><span class="syntax-COMMENT4">    fun regroup_munion_conv ctxt =</span>
<span class="gutter">3108 </span><span class="syntax-COMMENT4">      Function_Lib.regroup_conv ctxt @{const_abbrev Mempty} @{const_name plus}</span>
<span class="gutter">3109 </span><span class="syntax-COMMENT4">        (map (fn t =&gt; t RS eq_reflection) (@{thms ac_simps} @ @{thms empty_neutral}))</span>
<span class="gutterH">3110 </span>
<span class="gutter">3111 </span><span class="syntax-COMMENT4">    fun unfold_pwleq_tac ctxt i =</span>
<span class="gutter">3112 </span><span class="syntax-COMMENT4">      (resolve_tac ctxt @{thms pw_leq_step} i THEN (fn st =&gt; unfold_pwleq_tac ctxt (i + 1) st))</span>
<span class="gutter">3113 </span><span class="syntax-COMMENT4">        ORELSE (resolve_tac ctxt @{thms pw_leq_lstep} i)</span>
<span class="gutter">3114 </span><span class="syntax-COMMENT4">        ORELSE (resolve_tac ctxt @{thms pw_leq_empty} i)</span>
<span class="gutterH">3115 </span>
<span class="gutter">3116 </span><span class="syntax-COMMENT4">    val set_mset_simps = [@{thm set_mset_empty}, @{thm set_mset_single}, @{thm set_mset_union},</span>
<span class="gutter">3117 </span><span class="syntax-COMMENT4">                        @{thm Un_insert_left}, @{thm Un_empty_left}]</span>
<span class="gutter">3118 </span><span class="syntax-COMMENT4">  in</span>
<span class="gutter">3119 </span><span class="syntax-COMMENT4">    ScnpReconstruct.multiset_setup (ScnpReconstruct.Multiset</span>
<span class="gutterH">3120 </span><span class="syntax-COMMENT4">    {</span>
<span class="gutter">3121 </span><span class="syntax-COMMENT4">      msetT=msetT, mk_mset=mk_mset, mset_regroup_conv=regroup_munion_conv,</span>
<span class="gutter">3122 </span><span class="syntax-COMMENT4">      mset_member_tac=mset_member_tac, mset_nonempty_tac=mset_nonempty_tac,</span>
<span class="gutter">3123 </span><span class="syntax-COMMENT4">      mset_pwleq_tac=unfold_pwleq_tac, set_of_simps=set_mset_simps,</span>
<span class="gutter">3124 </span><span class="syntax-COMMENT4">      smsI'= @{thm ms_strictI}, wmsI2''= @{thm ms_weakI2}, wmsI1= @{thm ms_weakI1},</span>
<span class="gutterH">3125 </span><span class="syntax-COMMENT4">      reduction_pair = @{thm ms_reduction_pair}</span>
<span class="gutter">3126 </span><span class="syntax-COMMENT4">    })</span>
<span class="gutter">3127 </span><span class="syntax-COMMENT4">  end</span>
<span class="gutter">3128 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3129 </span>
<span class="gutterH">3130 </span>
<span class="gutter">3131 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">L</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3132 </span>
<span class="gutter">3133 </span><span class="syntax-KEYWORD1">lemmas</span> multi_count_eq <span class="syntax-OPERATOR">=</span> multiset_eq_iff <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span>
<span class="gutter">3134 </span>
<span class="gutterH">3135 </span><span class="syntax-KEYWORD1">lemma</span> union_commute<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M + N = N + (M::'a multiset)&quot;</span>
<span class="gutter">3136 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add.commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">3137 </span>
<span class="gutter">3138 </span><span class="syntax-KEYWORD1">lemma</span> union_assoc<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M + N) + K = M + (N + (K::'a multiset))&quot;</span>
<span class="gutter">3139 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add.assoc<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3140 </span>
<span class="gutter">3141 </span><span class="syntax-KEYWORD1">lemma</span> union_lcomm<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M + (N + K) = N + (M + (K::'a multiset))&quot;</span>
<span class="gutter">3142 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add.left_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">3143 </span>
<span class="gutter">3144 </span><span class="syntax-KEYWORD1">lemmas</span> union_ac <span class="syntax-OPERATOR">=</span> union_assoc union_commute union_lcomm add_mset_commute
<span class="gutterH">3145 </span>
<span class="gutter">3146 </span><span class="syntax-KEYWORD1">lemma</span> union_right_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M + K = N + K &#10231; M = (N::'a multiset)&quot;</span>
<span class="gutter">3147 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_right_cancel<span class="syntax-OPERATOR">)</span>
<span class="gutter">3148 </span>
<span class="gutter">3149 </span><span class="syntax-KEYWORD1">lemma</span> union_left_cancel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K + M = K + N &#10231; M = (N::'a multiset)&quot;</span>
<span class="gutterH">3150 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_left_cancel<span class="syntax-OPERATOR">)</span>
<span class="gutter">3151 </span>
<span class="gutter">3152 </span><span class="syntax-KEYWORD1">lemma</span> multi_union_self_other_eq<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(A::'a multiset) + X = A + Y &#10233; X = Y&quot;</span>
<span class="gutter">3153 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact add_left_imp_eq<span class="syntax-OPERATOR">)</span>
<span class="gutter">3154 </span>
<span class="gutterH">3155 </span><span class="syntax-KEYWORD1">lemma</span> mset_subset_trans<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(M::'a multiset) &sub;# K &#10233; K &sub;# N &#10233; M &sub;# N&quot;</span>
<span class="gutter">3156 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.less_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">3157 </span>
<span class="gutter">3158 </span><span class="syntax-KEYWORD1">lemma</span> multiset_inter_commute<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &cap;# B = B &cap;# A&quot;</span>
<span class="gutter">3159 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.inf.commute<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3160 </span>
<span class="gutter">3161 </span><span class="syntax-KEYWORD1">lemma</span> multiset_inter_assoc<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &cap;# (B &cap;# C) = A &cap;# B &cap;# C&quot;</span>
<span class="gutter">3162 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.inf.assoc <span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3163 </span>
<span class="gutter">3164 </span><span class="syntax-KEYWORD1">lemma</span> multiset_inter_left_commute<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;A &cap;# (B &cap;# C) = B &cap;# (A &cap;# C)&quot;</span>
<span class="gutterH">3165 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact subset_mset.inf.left_commute<span class="syntax-OPERATOR">)</span>
<span class="gutter">3166 </span>
<span class="gutter">3167 </span><span class="syntax-KEYWORD1">lemmas</span> multiset_inter_ac <span class="syntax-OPERATOR">=</span>
<span class="gutter">3168 </span>  multiset_inter_commute
<span class="gutter">3169 </span>  multiset_inter_assoc
<span class="gutterH">3170 </span>  multiset_inter_left_commute
<span class="gutter">3171 </span>
<span class="gutter">3172 </span><span class="syntax-KEYWORD1">lemma</span> mset_le_not_refl<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&not; M &lt; (M::'a::preorder multiset)&quot;</span>
<span class="gutter">3173 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact less_irrefl<span class="syntax-OPERATOR">)</span>
<span class="gutter">3174 </span>
<span class="gutterH">3175 </span><span class="syntax-KEYWORD1">lemma</span> mset_le_trans<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K &lt; M &#10233; M &lt; N &#10233; K &lt; (N::'a::preorder multiset)&quot;</span>
<span class="gutter">3176 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact less_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">3177 </span>
<span class="gutter">3178 </span><span class="syntax-KEYWORD1">lemma</span> mset_le_not_sym<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M &lt; N &#10233; &not; N &lt; (M::'a::preorder multiset)&quot;</span>
<span class="gutter">3179 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact less_not_sym<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3180 </span>
<span class="gutter">3181 </span><span class="syntax-KEYWORD1">lemma</span> mset_le_asym<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M &lt; N &#10233; (&not; P &#10233; N &lt; (M::'a::preorder multiset)) &#10233; P&quot;</span>
<span class="gutter">3182 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>fact less_asym<span class="syntax-OPERATOR">)</span>
<span class="gutter">3183 </span>
<span class="gutter">3184 </span><span class="syntax-KEYWORD1">declaration</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutterH">3185 </span><span class="syntax-COMMENT4">  let</span>
<span class="gutter">3186 </span><span class="syntax-COMMENT4">    fun multiset_postproc _ maybe_name all_values (T as Type (_, [elem_T])) (Const _ $ t') =</span>
<span class="gutter">3187 </span><span class="syntax-COMMENT4">          let</span>
<span class="gutter">3188 </span><span class="syntax-COMMENT4">            val (maybe_opt, ps) =</span>
<span class="gutter">3189 </span><span class="syntax-COMMENT4">              Nitpick_Model.dest_plain_fun t'</span>
<span class="gutterH">3190 </span><span class="syntax-COMMENT4">              ||&gt; op ~~</span>
<span class="gutter">3191 </span><span class="syntax-COMMENT4">              ||&gt; map (apsnd (snd o HOLogic.dest_number))</span>
<span class="gutter">3192 </span><span class="syntax-COMMENT4">            fun elems_for t =</span>
<span class="gutter">3193 </span><span class="syntax-COMMENT4">              (case AList.lookup (op =) ps t of</span>
<span class="gutter">3194 </span><span class="syntax-COMMENT4">                SOME n =&gt; replicate n t</span>
<span class="gutterH">3195 </span><span class="syntax-COMMENT4">              | NONE =&gt; [Const (maybe_name, elem_T --&gt; elem_T) $ t])</span>
<span class="gutter">3196 </span><span class="syntax-COMMENT4">          in</span>
<span class="gutter">3197 </span><span class="syntax-COMMENT4">            (case maps elems_for (all_values elem_T) @</span>
<span class="gutter">3198 </span><span class="syntax-COMMENT4">                 (if maybe_opt then [Const (Nitpick_Model.unrep_mixfix (), elem_T)] else []) of</span>
<span class="gutter">3199 </span><span class="syntax-COMMENT4">              [] =&gt; Const (@{const_name zero_class.zero}, T)</span>
<span class="gutterH">3200 </span><span class="syntax-COMMENT4">            | ts =&gt;</span>
<span class="gutter">3201 </span><span class="syntax-COMMENT4">                foldl1 (fn (s, t) =&gt; Const (@{const_name add_mset}, elem_T --&gt; T --&gt; T) $ s $ t)</span>
<span class="gutter">3202 </span><span class="syntax-COMMENT4">                  ts)</span>
<span class="gutter">3203 </span><span class="syntax-COMMENT4">          end</span>
<span class="gutter">3204 </span><span class="syntax-COMMENT4">      | multiset_postproc _ _ _ _ t = t</span>
<span class="gutterH">3205 </span><span class="syntax-COMMENT4">  in Nitpick_Model.register_term_postprocessor @{typ &quot;'a multiset&quot;} multiset_postproc end</span>
<span class="gutter">3206 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3207 </span>
<span class="gutter">3208 </span>
<span class="gutter">3209 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">3210 </span>
<span class="gutter">3211 </span><span class="syntax-KEYWORD1">code_datatype</span> mset
<span class="gutter">3212 </span>
<span class="gutter">3213 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#} = mset []&quot;</span>
<span class="gutter">3214 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">3215 </span>
<span class="gutter">3216 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;add_mset x (mset xs) = mset (x # xs)&quot;</span>
<span class="gutter">3217 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3218 </span>
<span class="gutter">3219 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;Multiset.is_empty (mset xs) &#10231; List.null xs&quot;</span>
<span class="gutterH">3220 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Multiset.is_empty_def List.null_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">3221 </span>
<span class="gutter">3222 </span><span class="syntax-KEYWORD1">lemma</span> union_code <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs + mset ys = mset (xs @ ys)&quot;</span>
<span class="gutter">3223 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3224 </span>
<span class="gutterH">3225 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset f (mset xs) = mset (map f xs)&quot;</span>
<span class="gutter">3226 </span>  <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3227 </span>
<span class="gutter">3228 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;filter_mset f (mset xs) = mset (filter f xs)&quot;</span>
<span class="gutter">3229 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> mset_filter<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3230 </span>
<span class="gutter">3231 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs - mset ys = mset (fold remove1 ys xs)&quot;</span>
<span class="gutter">3232 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule sym<span class="syntax-OPERATOR">,</span> induct ys arbitrary<span class="syntax-OPERATOR">:</span> xs<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> diff_add diff_right_commute diff_diff_add<span class="syntax-OPERATOR">)</span>
<span class="gutter">3233 </span>
<span class="gutter">3234 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutterH">3235 </span>  <span class="syntax-LITERAL1">&quot;mset xs &cap;# mset ys =</span>
<span class="gutter">3236 </span><span class="syntax-LITERAL1">    mset (snd (fold (&lambda;x (ys, zs).</span>
<span class="gutter">3237 </span><span class="syntax-LITERAL1">      if x &isin; set ys then (remove1 x ys, x # zs) else (ys, zs)) xs (ys, [])))&quot;</span>
<span class="gutter">3238 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3239 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;zs. mset (snd (fold (&lambda;x (ys, zs).</span>
<span class="gutterH">3240 </span><span class="syntax-LITERAL1">    if x &isin; set ys then (remove1 x ys, x # zs) else (ys, zs)) xs (ys, zs))) =</span>
<span class="gutter">3241 </span><span class="syntax-LITERAL1">      (mset xs &cap;# mset ys) + mset zs&quot;</span>
<span class="gutter">3242 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">3243 </span>      <span class="syntax-OPERATOR">(</span>auto simp add<span class="syntax-OPERATOR">:</span> inter_add_right1 inter_add_right2 ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">3244 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">3245 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3246 </span>
<span class="gutter">3247 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">3248 </span>  <span class="syntax-LITERAL1">&quot;mset xs &cup;# mset ys =</span>
<span class="gutter">3249 </span><span class="syntax-LITERAL1">    mset (case_prod append (fold (&lambda;x (ys, zs). (remove1 x ys, x # zs)) xs (ys, [])))&quot;</span>
<span class="gutterH">3250 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3251 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;zs. mset (case_prod append (fold (&lambda;x (ys, zs). (remove1 x ys, x # zs)) xs (ys, zs))) =</span>
<span class="gutter">3252 </span><span class="syntax-LITERAL1">      (mset xs &cup;# mset ys) + mset zs&quot;</span>
<span class="gutter">3253 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> multiset_eq_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">3254 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">3255 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3256 </span>
<span class="gutter">3257 </span><span class="syntax-KEYWORD1">declare</span> in_multiset_in_set <span class="syntax-OPERATOR">[</span>code_unfold<span class="syntax-OPERATOR">]</span>
<span class="gutter">3258 </span>
<span class="gutter">3259 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;count (mset xs) x = fold (&lambda;y. if x = y then Suc else id) xs 0&quot;</span>
<span class="gutterH">3260 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3261 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;n. fold (&lambda;y. if x = y then Suc else id) xs n = count (mset xs) x + n&quot;</span>
<span class="gutter">3262 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">3263 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3264 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3265 </span>
<span class="gutter">3266 </span><span class="syntax-KEYWORD1">declare</span> set_mset_mset <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span>
<span class="gutter">3267 </span>
<span class="gutter">3268 </span><span class="syntax-KEYWORD1">declare</span> sorted_list_of_multiset_mset <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span>
<span class="gutter">3269 </span>
<span class="gutterH">3270 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-NULL">&#8213;</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">y</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">,</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">b</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">-</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">!</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3271 </span>  <span class="syntax-LITERAL1">&quot;mset_set A = mset (sorted_list_of_set A)&quot;</span>
<span class="gutter">3272 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;finite A&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3273 </span>  <span class="syntax-KEYWORD1">apply</span> simp_all
<span class="gutter">3274 </span>  <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>induct A rule<span class="syntax-OPERATOR">:</span> finite_induct<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3275 </span>  <span class="syntax-KEYWORD1">apply</span> simp_all
<span class="gutter">3276 </span>  <span class="syntax-KEYWORD1">done</span>
<span class="gutter">3277 </span>
<span class="gutter">3278 </span><span class="syntax-KEYWORD1">declare</span> size_mset <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span>
<span class="gutter">3279 </span>
<span class="gutterH">3280 </span><span class="syntax-KEYWORD1">fun</span> subset_eq_mset_impl <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a list &rArr; 'a list &rArr; bool option&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3281 </span>  <span class="syntax-LITERAL1">&quot;subset_eq_mset_impl [] ys = Some (ys &ne; [])&quot;</span>
<span class="gutter">3282 </span><span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;subset_eq_mset_impl (Cons x xs) ys = (case List.extract (op = x) ys of</span>
<span class="gutter">3283 </span><span class="syntax-LITERAL1">     None &rArr; None</span>
<span class="gutter">3284 </span><span class="syntax-LITERAL1">   | Some (ys1,_,ys2) &rArr; subset_eq_mset_impl xs (ys1 @ ys2))&quot;</span>
<span class="gutterH">3285 </span>
<span class="gutter">3286 </span><span class="syntax-KEYWORD1">lemma</span> subset_eq_mset_impl<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;(subset_eq_mset_impl xs ys = None &#10231; &not; mset xs &sube;# mset ys) &and;</span>
<span class="gutter">3287 </span><span class="syntax-LITERAL1">  (subset_eq_mset_impl xs ys = Some True &#10231; mset xs &sub;# mset ys) &and;</span>
<span class="gutter">3288 </span><span class="syntax-LITERAL1">  (subset_eq_mset_impl xs ys = Some False &#10230; mset xs = mset ys)&quot;</span>
<span class="gutter">3289 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct xs arbitrary<span class="syntax-OPERATOR">:</span> ys<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3290 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Nil ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">3291 </span>  <span class="syntax-KEYWORD3">show</span> ?case <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> subset_mset.zero_less_iff_neq_zero<span class="syntax-OPERATOR">)</span>
<span class="gutter">3292 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">3293 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">3294 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutterH">3295 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;List.extract (op = x) ys&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3296 </span>    <span class="syntax-KEYWORD3">case</span> None
<span class="gutter">3297 </span>    <span class="syntax-KEYWORD1">hence</span> x<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;x &notin; set ys&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> extract_None_iff<span class="syntax-OPERATOR">)</span>
<span class="gutter">3298 </span>    <span class="syntax-KEYWORD1">{</span>
<span class="gutter">3299 </span>      <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;mset (x # xs) &sube;# mset ys&quot;</span>
<span class="gutterH">3300 </span>      <span class="syntax-KEYWORD1">from</span> set_mset_mono<span class="syntax-OPERATOR">[</span>OF this<span class="syntax-OPERATOR">]</span> x <span class="syntax-KEYWORD1">have</span> False <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3301 </span>    <span class="syntax-KEYWORD1">}</span> <span class="syntax-KEYWORD1">note</span> nle <span class="syntax-OPERATOR">=</span> this
<span class="gutter">3302 </span>    <span class="syntax-KEYWORD1">moreover</span>
<span class="gutter">3303 </span>    <span class="syntax-KEYWORD1">{</span>
<span class="gutter">3304 </span>      <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;mset (x # xs) &sub;# mset ys&quot;</span>
<span class="gutterH">3305 </span>      <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;mset (x # xs) &sube;# mset ys&quot;</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3306 </span>      <span class="syntax-KEYWORD1">from</span> nle<span class="syntax-OPERATOR">[</span>OF this<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">have</span> False <span class="syntax-KEYWORD1">.</span>
<span class="gutter">3307 </span>    <span class="syntax-KEYWORD1">}</span>
<span class="gutter">3308 </span>    <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">using</span> None <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3309 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutterH">3310 </span>    <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Some res<span class="syntax-OPERATOR">)</span>
<span class="gutter">3311 </span>    <span class="syntax-KEYWORD3">obtain</span> ys1 y ys2 <span class="syntax-KEYWORD2">where</span> res<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;res = (ys1,y,ys2)&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases res<span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutter">3312 </span>    <span class="syntax-KEYWORD1">note</span> Some <span class="syntax-OPERATOR">=</span> Some<span class="syntax-OPERATOR">[</span>unfolded res<span class="syntax-OPERATOR">]</span>
<span class="gutter">3313 </span>    <span class="syntax-KEYWORD1">from</span> extract_SomeE<span class="syntax-OPERATOR">[</span>OF Some<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;ys = ys1 @ x # ys2&quot;</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3314 </span>    <span class="syntax-KEYWORD1">hence</span> id<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset ys = add_mset x (mset (ys1 @ ys2))&quot;</span>
<span class="gutterH">3315 </span>      <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3316 </span>    <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">unfolding</span> subset_eq_mset_impl.simps
<span class="gutter">3317 </span>      <span class="syntax-KEYWORD1">unfolding</span> Some option.simps split
<span class="gutter">3318 </span>      <span class="syntax-KEYWORD1">unfolding</span> id
<span class="gutter">3319 </span>      <span class="syntax-KEYWORD1">using</span> Cons<span class="syntax-OPERATOR">[</span>of <span class="syntax-LITERAL1">&quot;ys1 @ ys2&quot;</span><span class="syntax-OPERATOR">]</span>
<span class="gutterH">3320 </span>      <span class="syntax-KEYWORD1">unfolding</span> subset_mset_def subseteq_mset_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3321 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3322 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3323 </span>
<span class="gutter">3324 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs &sube;# mset ys &#10231; subset_eq_mset_impl xs ys &ne; None&quot;</span>
<span class="gutterH">3325 </span>  <span class="syntax-KEYWORD1">using</span> subset_eq_mset_impl<span class="syntax-OPERATOR">[</span>of xs ys<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;subset_eq_mset_impl xs ys&quot;</span><span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutter">3326 </span>
<span class="gutter">3327 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs &sub;# mset ys &#10231; subset_eq_mset_impl xs ys = Some True&quot;</span>
<span class="gutter">3328 </span>  <span class="syntax-KEYWORD1">using</span> subset_eq_mset_impl<span class="syntax-OPERATOR">[</span>of xs ys<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;subset_eq_mset_impl xs ys&quot;</span><span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutter">3329 </span>
<span class="gutterH">3330 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>equal<span class="syntax-OPERATOR">)</span> equal
<span class="gutter">3331 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">3332 </span>
<span class="gutter">3333 </span><span class="syntax-KEYWORD1">definition</span>
<span class="gutter">3334 </span>  <span class="syntax-OPERATOR">[</span>code del<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;HOL.equal A (B :: 'a multiset) &#10231; A = B&quot;</span>
<span class="gutterH">3335 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;HOL.equal (mset xs) (mset ys) &#10231; subset_eq_mset_impl xs ys = Some False&quot;</span>
<span class="gutter">3336 </span>  <span class="syntax-KEYWORD1">unfolding</span> equal_multiset_def
<span class="gutter">3337 </span>  <span class="syntax-KEYWORD1">using</span> subset_eq_mset_impl<span class="syntax-OPERATOR">[</span>of xs ys<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;subset_eq_mset_impl xs ys&quot;</span><span class="syntax-OPERATOR">,</span> auto<span class="syntax-OPERATOR">)</span>
<span class="gutter">3338 </span>
<span class="gutter">3339 </span><span class="syntax-KEYWORD1">instance</span>
<span class="gutterH">3340 </span>  <span class="syntax-KEYWORD1">by</span> standard <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> equal_multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">3341 </span>
<span class="gutter">3342 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">3343 </span>
<span class="gutter">3344 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;sum_mset (mset xs) = sum_list xs&quot;</span>
<span class="gutterH">3345 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">3346 </span>
<span class="gutter">3347 </span><span class="syntax-KEYWORD1">lemma</span> <span class="syntax-OPERATOR">[</span>code<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;prod_mset (mset xs) = fold times xs 1&quot;</span>
<span class="gutter">3348 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3349 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&#8896;x. fold times xs x = prod_mset (mset xs) * x&quot;</span>
<span class="gutterH">3350 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct xs<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp_all add<span class="syntax-OPERATOR">:</span> ac_simps<span class="syntax-OPERATOR">)</span>
<span class="gutter">3351 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> ?thesis <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3352 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3353 </span>
<span class="gutter">3354 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutterH">3355 </span><span class="syntax-COMMENT4">  Exercise for the casual reader: add implementations for @{term &quot;op &le;&quot;}</span>
<span class="gutter">3356 </span><span class="syntax-COMMENT4">  and @{term &quot;op &lt;&quot;} (multiset order).</span>
<span class="gutter">3357 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3358 </span>
<span class="gutter">3359 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">Q</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">k</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">g</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutterH">3360 </span>
<span class="gutter">3361 </span><span class="syntax-KEYWORD1">definition</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">in</span> term_syntax<span class="syntax-OPERATOR">)</span>
<span class="gutter">3362 </span>  msetify <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;'a::typerep list &times; (unit &rArr; Code_Evaluation.term)</span>
<span class="gutter">3363 </span><span class="syntax-LITERAL1">    &rArr; 'a multiset &times; (unit &rArr; Code_Evaluation.term)&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3364 </span>  <span class="syntax-OPERATOR">[</span>code_unfold<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;msetify xs = Code_Evaluation.valtermify mset {&sdot;} xs&quot;</span>
<span class="gutterH">3365 </span>
<span class="gutter">3366 </span><span class="syntax-KEYWORD1">notation</span> fcomp <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&#8728;&gt;&quot;</span> 60<span class="syntax-OPERATOR">)</span>
<span class="gutter">3367 </span><span class="syntax-KEYWORD1">notation</span> scomp <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&#8728;&rarr;&quot;</span> 60<span class="syntax-OPERATOR">)</span>
<span class="gutter">3368 </span>
<span class="gutter">3369 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>random<span class="syntax-OPERATOR">)</span> random
<span class="gutterH">3370 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">3371 </span>
<span class="gutter">3372 </span><span class="syntax-KEYWORD1">definition</span>
<span class="gutter">3373 </span>  <span class="syntax-LITERAL1">&quot;Quickcheck_Random.random i = Quickcheck_Random.random i &#8728;&rarr; (&lambda;xs. Pair (msetify xs))&quot;</span>
<span class="gutter">3374 </span>
<span class="gutterH">3375 </span><span class="syntax-KEYWORD1">instance</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutter">3376 </span>
<span class="gutter">3377 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">3378 </span>
<span class="gutter">3379 </span><span class="syntax-KEYWORD1">no_notation</span> fcomp <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&#8728;&gt;&quot;</span> 60<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3380 </span><span class="syntax-KEYWORD1">no_notation</span> scomp <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infixl</span> <span class="syntax-LITERAL1">&quot;&#8728;&rarr;&quot;</span> 60<span class="syntax-OPERATOR">)</span>
<span class="gutter">3381 </span>
<span class="gutter">3382 </span><span class="syntax-KEYWORD1">instantiation</span> multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-OPERATOR">(</span>full_exhaustive<span class="syntax-OPERATOR">)</span> full_exhaustive
<span class="gutter">3383 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">3384 </span>
<span class="gutterH">3385 </span><span class="syntax-KEYWORD1">definition</span> full_exhaustive_multiset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a multiset &times; (unit &rArr; term) &rArr; (bool &times; term list) option) &rArr; natural &rArr; (bool &times; term list) option&quot;</span>
<span class="gutter">3386 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutter">3387 </span>  <span class="syntax-LITERAL1">&quot;full_exhaustive_multiset f i = Quickcheck_Exhaustive.full_exhaustive (&lambda;xs. f (msetify xs)) i&quot;</span>
<span class="gutter">3388 </span>
<span class="gutter">3389 </span><span class="syntax-KEYWORD1">instance</span> <span class="syntax-KEYWORD1">..</span>
<span class="gutterH">3390 </span>
<span class="gutter">3391 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">3392 </span>
<span class="gutter">3393 </span><span class="syntax-KEYWORD1">hide_const</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">open</span><span class="syntax-OPERATOR">)</span> msetify
<span class="gutter">3394 </span>
<span class="gutterH">3395 </span>
<span class="gutter">3396 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">B</span><span class="syntax-COMMENT4">N</span><span class="syntax-COMMENT4">F</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3397 </span>
<span class="gutter">3398 </span><span class="syntax-KEYWORD1">definition</span> rel_mset <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3399 </span>  <span class="syntax-LITERAL1">&quot;rel_mset R X Y &#10231; (&exist;xs ys. mset xs = X &and; mset ys = Y &and; list_all2 R xs ys)&quot;</span>
<span class="gutterH">3400 </span>
<span class="gutter">3401 </span><span class="syntax-KEYWORD1">lemma</span> mset_zip_take_Cons_drop_twice<span class="syntax-OPERATOR">:</span>
<span class="gutter">3402 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;length xs = length ys&quot;</span> <span class="syntax-LITERAL1">&quot;j &le; length xs&quot;</span>
<span class="gutter">3403 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;mset (zip (take j xs @ x # drop j xs) (take j ys @ y # drop j ys)) =</span>
<span class="gutter">3404 </span><span class="syntax-LITERAL1">    add_mset (x,y) (mset (zip xs ys))&quot;</span>
<span class="gutterH">3405 </span>  <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">3406 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct xs ys arbitrary<span class="syntax-OPERATOR">:</span> x y j rule<span class="syntax-OPERATOR">:</span> list_induct2<span class="syntax-OPERATOR">)</span>
<span class="gutter">3407 </span>  <span class="syntax-KEYWORD3">case</span> Nil
<span class="gutter">3408 </span>  <span class="syntax-KEYWORD3">thus</span> ?case
<span class="gutter">3409 </span>    <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">3410 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutter">3411 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs y ys<span class="syntax-OPERATOR">)</span>
<span class="gutter">3412 </span>  <span class="syntax-KEYWORD3">thus</span> ?case
<span class="gutter">3413 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;j = 0&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3414 </span>    <span class="syntax-KEYWORD3">case</span> True
<span class="gutterH">3415 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis
<span class="gutter">3416 </span>      <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3417 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">3418 </span>    <span class="syntax-KEYWORD3">case</span> False
<span class="gutter">3419 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> k <span class="syntax-KEYWORD2">where</span> k<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;j = Suc k&quot;</span>
<span class="gutterH">3420 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>cases j<span class="syntax-OPERATOR">)</span> simp
<span class="gutter">3421 </span>    <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;k &le; length xs&quot;</span>
<span class="gutter">3422 </span>      <span class="syntax-KEYWORD1">using</span> Cons.prems <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3423 </span>    <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;mset (zip (take k xs @ x # drop k xs) (take k ys @ y # drop k ys)) =</span>
<span class="gutter">3424 </span><span class="syntax-LITERAL1">      add_mset (x,y) (mset (zip xs ys))&quot;</span>
<span class="gutterH">3425 </span>      <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule Cons.hyps<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3426 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis
<span class="gutter">3427 </span>      <span class="syntax-KEYWORD1">unfolding</span> k <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3428 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3429 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3430 </span>
<span class="gutter">3431 </span><span class="syntax-KEYWORD1">lemma</span> ex_mset_zip_left<span class="syntax-OPERATOR">:</span>
<span class="gutter">3432 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;length xs = length ys&quot;</span> <span class="syntax-LITERAL1">&quot;mset xs' = mset xs&quot;</span>
<span class="gutter">3433 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;ys'. length ys' = length xs' &and; mset (zip xs' ys') = mset (zip xs ys)&quot;</span>
<span class="gutter">3434 </span><span class="syntax-KEYWORD1">using</span> assms
<span class="gutterH">3435 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct xs ys arbitrary<span class="syntax-OPERATOR">:</span> xs' rule<span class="syntax-OPERATOR">:</span> list_induct2<span class="syntax-OPERATOR">)</span>
<span class="gutter">3436 </span>  <span class="syntax-KEYWORD3">case</span> Nil
<span class="gutter">3437 </span>  <span class="syntax-KEYWORD3">thus</span> ?case
<span class="gutter">3438 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3439 </span><span class="syntax-KEYWORD1">next</span>
<span class="gutterH">3440 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>Cons x xs y ys xs'<span class="syntax-OPERATOR">)</span>
<span class="gutter">3441 </span>  <span class="syntax-KEYWORD3">obtain</span> j <span class="syntax-KEYWORD2">where</span> j_len<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;j &lt; length xs'&quot;</span> <span class="syntax-KEYWORD2">and</span> nth_j<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;xs' ! j = x&quot;</span>
<span class="gutter">3442 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis Cons.prems in_set_conv_nth list.set_intros<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> mset_eq_setD<span class="syntax-OPERATOR">)</span>
<span class="gutter">3443 </span>
<span class="gutter">3444 </span>  <span class="syntax-KEYWORD3">define</span> xsa <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;xsa = take j xs' @ drop (Suc j) xs'&quot;</span>
<span class="gutterH">3445 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;mset xs' = {#x#} + mset xsa&quot;</span>
<span class="gutter">3446 </span>    <span class="syntax-KEYWORD1">unfolding</span> xsa_def <span class="syntax-KEYWORD1">using</span> j_len nth_j
<span class="gutter">3447 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis Cons_nth_drop_Suc union_mset_add_mset_right add_mset_remove_trivial add_diff_cancel_left'
<span class="gutter">3448 </span>        append_take_drop_id mset.simps<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> mset_append<span class="syntax-OPERATOR">)</span>
<span class="gutter">3449 </span>  <span class="syntax-KEYWORD1">hence</span> ms_x<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xsa = mset xs&quot;</span>
<span class="gutterH">3450 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> Cons.prems<span class="syntax-OPERATOR">)</span>
<span class="gutter">3451 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> ysa <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3452 </span>    len_a<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;length ysa = length xsa&quot;</span> <span class="syntax-KEYWORD2">and</span> ms_a<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (zip xsa ysa) = mset (zip xs ys)&quot;</span>
<span class="gutter">3453 </span>    <span class="syntax-KEYWORD1">using</span> Cons.hyps<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3454 </span>
<span class="gutterH">3455 </span>  <span class="syntax-KEYWORD3">define</span> ys' <span class="syntax-KEYWORD2">where</span> <span class="syntax-LITERAL1">&quot;ys' = take j ysa @ y # drop j ysa&quot;</span>
<span class="gutter">3456 </span>  <span class="syntax-KEYWORD1">have</span> xs'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;xs' = take j xsa @ x # drop j xsa&quot;</span>
<span class="gutter">3457 </span>    <span class="syntax-KEYWORD1">using</span> ms_x j_len nth_j Cons.prems xsa_def
<span class="gutter">3458 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis append_eq_append_conv append_take_drop_id diff_Suc_Suc Cons_nth_drop_Suc length_Cons
<span class="gutter">3459 </span>      length_drop size_mset<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3460 </span>  <span class="syntax-KEYWORD1">have</span> j_len'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;j &le; length xsa&quot;</span>
<span class="gutter">3461 </span>    <span class="syntax-KEYWORD1">using</span> j_len xs' xsa_def
<span class="gutter">3462 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_Suc_right append_take_drop_id length_Cons length_append less_eq_Suc_le not_less<span class="syntax-OPERATOR">)</span>
<span class="gutter">3463 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;length ys' = length xs'&quot;</span>
<span class="gutter">3464 </span>    <span class="syntax-KEYWORD1">unfolding</span> ys'_def <span class="syntax-KEYWORD1">using</span> Cons.prems len_a ms_x
<span class="gutterH">3465 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis add_Suc_right append_take_drop_id length_Cons length_append mset_eq_length<span class="syntax-OPERATOR">)</span>
<span class="gutter">3466 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;mset (zip xs' ys') = mset (zip (x # xs) (y # ys))&quot;</span>
<span class="gutter">3467 </span>    <span class="syntax-KEYWORD1">unfolding</span> xs' ys'_def
<span class="gutter">3468 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule trans<span class="syntax-OPERATOR">[</span>OF mset_zip_take_Cons_drop_twice<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3469 </span>      <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> len_a ms_a j_len'<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3470 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">3471 </span>    <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3472 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3473 </span>
<span class="gutter">3474 </span><span class="syntax-KEYWORD1">lemma</span> list_all2_reorder_left_invariance<span class="syntax-OPERATOR">:</span>
<span class="gutterH">3475 </span>  <span class="syntax-KEYWORD2">assumes</span> rel<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;list_all2 R xs ys&quot;</span> <span class="syntax-KEYWORD2">and</span> ms_x<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset xs' = mset xs&quot;</span>
<span class="gutter">3476 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;ys'. list_all2 R xs' ys' &and; mset ys' = mset ys&quot;</span>
<span class="gutter">3477 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3478 </span>  <span class="syntax-KEYWORD1">have</span> len<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;length xs = length ys&quot;</span>
<span class="gutter">3479 </span>    <span class="syntax-KEYWORD1">using</span> rel list_all2_conv_all_nth <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3480 </span>  <span class="syntax-KEYWORD3">obtain</span> ys' <span class="syntax-KEYWORD2">where</span>
<span class="gutter">3481 </span>    len'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;length xs' = length ys'&quot;</span> <span class="syntax-KEYWORD2">and</span> ms_xy<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;mset (zip xs' ys') = mset (zip xs ys)&quot;</span>
<span class="gutter">3482 </span>    <span class="syntax-KEYWORD1">using</span> len ms_x <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis ex_mset_zip_left<span class="syntax-OPERATOR">)</span>
<span class="gutter">3483 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;list_all2 R xs' ys'&quot;</span>
<span class="gutter">3484 </span>    <span class="syntax-KEYWORD1">using</span> assms<span class="syntax-OPERATOR">(</span>1<span class="syntax-OPERATOR">)</span> len' ms_xy <span class="syntax-KEYWORD1">unfolding</span> list_all2_iff <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>blast dest<span class="syntax-OPERATOR">:</span> mset_eq_setD<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3485 </span>  <span class="syntax-KEYWORD1">moreover</span> <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;mset ys' = mset ys&quot;</span>
<span class="gutter">3486 </span>    <span class="syntax-KEYWORD1">using</span> len len' ms_xy map_snd_zip mset_map <span class="syntax-KEYWORD1">by</span> metis
<span class="gutter">3487 </span>  <span class="syntax-KEYWORD1">ultimately</span> <span class="syntax-KEYWORD3">show</span> ?thesis
<span class="gutter">3488 </span>    <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3489 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3490 </span>
<span class="gutter">3491 </span><span class="syntax-KEYWORD1">lemma</span> ex_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&exist;xs. mset xs = X&quot;</span>
<span class="gutter">3492 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct X<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp<span class="syntax-OPERATOR">,</span> metis mset.simps<span class="syntax-OPERATOR">(</span>2<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3493 </span>
<span class="gutter">3494 </span><span class="syntax-KEYWORD1">inductive</span> pred_mset <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;('a &rArr; bool) &rArr; 'a multiset &rArr; bool&quot;</span>
<span class="gutterH">3495 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutter">3496 </span>  <span class="syntax-LITERAL1">&quot;pred_mset P {#}&quot;</span>
<span class="gutter">3497 </span><span class="syntax-OPERATOR">|</span> <span class="syntax-LITERAL1">&quot;&#10214;P a; pred_mset P M&#10215; &#10233; pred_mset P (add_mset a M)&quot;</span>
<span class="gutter">3498 </span>
<span class="gutter">3499 </span><span class="syntax-KEYWORD1">bnf</span> <span class="syntax-LITERAL1">&quot;'a multiset&quot;</span>
<span class="gutterH">3500 </span>  map<span class="syntax-OPERATOR">:</span> image_mset
<span class="gutter">3501 </span>  sets<span class="syntax-OPERATOR">:</span> set_mset
<span class="gutter">3502 </span>  bd<span class="syntax-OPERATOR">:</span> natLeq
<span class="gutter">3503 </span>  wits<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;{#}&quot;</span>
<span class="gutter">3504 </span>  rel<span class="syntax-OPERATOR">:</span> rel_mset
<span class="gutterH">3505 </span>  pred<span class="syntax-OPERATOR">:</span> pred_mset
<span class="gutter">3506 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3507 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;image_mset id = id&quot;</span>
<span class="gutter">3508 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule image_mset.id<span class="syntax-OPERATOR">)</span>
<span class="gutter">3509 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;image_mset (g &#8728; f) = image_mset g &#8728; image_mset f&quot;</span> <span class="syntax-KEYWORD2">for</span> f g
<span class="gutterH">3510 </span>    <span class="syntax-KEYWORD1">unfolding</span> comp_def <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule ext<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>simp add<span class="syntax-OPERATOR">:</span> comp_def image_mset.compositionality<span class="syntax-OPERATOR">)</span>
<span class="gutter">3511 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;(&#8896;z. z &isin; set_mset X &#10233; f z = g z) &#10233; image_mset f X = image_mset g X&quot;</span> <span class="syntax-KEYWORD2">for</span> f g X
<span class="gutter">3512 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct X<span class="syntax-OPERATOR">)</span> simp_all
<span class="gutter">3513 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;set_mset &#8728; image_mset f = op ` f &#8728; set_mset&quot;</span> <span class="syntax-KEYWORD2">for</span> f
<span class="gutter">3514 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3515 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;card_order natLeq&quot;</span>
<span class="gutter">3516 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule natLeq_card_order<span class="syntax-OPERATOR">)</span>
<span class="gutter">3517 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;BNF_Cardinal_Arithmetic.cinfinite natLeq&quot;</span>
<span class="gutter">3518 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>rule natLeq_cinfinite<span class="syntax-OPERATOR">)</span>
<span class="gutter">3519 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;ordLeq3 (card_of (set_mset X)) natLeq&quot;</span> <span class="syntax-KEYWORD2">for</span> X
<span class="gutterH">3520 </span>    <span class="syntax-KEYWORD1">by</span> transfer
<span class="gutter">3521 </span>      <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">!</span><span class="syntax-OPERATOR">:</span> ordLess_imp_ordLeq simp<span class="syntax-OPERATOR">:</span> finite_iff_ordLess_natLeq<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> multiset_def<span class="syntax-OPERATOR">)</span>
<span class="gutter">3522 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;rel_mset R OO rel_mset S &le; rel_mset (R OO S)&quot;</span> <span class="syntax-KEYWORD2">for</span> R S
<span class="gutter">3523 </span>    <span class="syntax-KEYWORD1">unfolding</span> rel_mset_def<span class="syntax-OPERATOR">[</span>abs_def<span class="syntax-OPERATOR">]</span> OO_def
<span class="gutter">3524 </span>    <span class="syntax-KEYWORD1">apply</span> clarify
<span class="gutterH">3525 </span>    <span class="syntax-KEYWORD1">subgoal</span> <span class="syntax-KEYWORD2">for</span> X Z Y xs ys' ys zs
<span class="gutter">3526 </span>      <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>drule list_all2_reorder_left_invariance <span class="syntax-OPERATOR">[</span><span class="syntax-KEYWORD2">where</span> xs <span class="syntax-OPERATOR">=</span> ys' <span class="syntax-KEYWORD2">and</span> ys <span class="syntax-OPERATOR">=</span> zs <span class="syntax-KEYWORD2">and</span> xs' <span class="syntax-OPERATOR">=</span> ys<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3527 </span>      <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto intro<span class="syntax-OPERATOR">:</span> list_all2_trans<span class="syntax-OPERATOR">)</span>
<span class="gutter">3528 </span>      <span class="syntax-KEYWORD1">done</span>
<span class="gutter">3529 </span>    <span class="syntax-KEYWORD1">done</span>
<span class="gutterH">3530 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;rel_mset R =</span>
<span class="gutter">3531 </span><span class="syntax-LITERAL1">    (&lambda;x y. &exist;z. set_mset z &sube; {(x, y). R x y} &and;</span>
<span class="gutter">3532 </span><span class="syntax-LITERAL1">    image_mset fst z = x &and; image_mset snd z = y)&quot;</span> <span class="syntax-KEYWORD2">for</span> R
<span class="gutter">3533 </span>    <span class="syntax-KEYWORD1">unfolding</span> rel_mset_def<span class="syntax-OPERATOR">[</span>abs_def<span class="syntax-OPERATOR">]</span>
<span class="gutter">3534 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule ext<span class="syntax-OPERATOR">)</span><span class="syntax-OPERATOR">+</span>
<span class="gutterH">3535 </span>    <span class="syntax-KEYWORD1">apply</span> safe
<span class="gutter">3536 </span>     <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;mset (zip xs ys)&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">;</span>
<span class="gutter">3537 </span>       auto simp<span class="syntax-OPERATOR">:</span> in_set_zip list_all2_iff mset_map<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3538 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rename_tac XY<span class="syntax-OPERATOR">)</span>
<span class="gutter">3539 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>cut_tac X <span class="syntax-OPERATOR">=</span> XY <span class="syntax-KEYWORD2">in</span> ex_mset<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3540 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>erule exE<span class="syntax-OPERATOR">)</span>
<span class="gutter">3541 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rename_tac xys<span class="syntax-OPERATOR">)</span>
<span class="gutter">3542 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;map fst xys&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">)</span>
<span class="gutter">3543 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> mset_map<span class="syntax-OPERATOR">)</span>
<span class="gutter">3544 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule_tac x <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;map snd xys&quot;</span> <span class="syntax-KEYWORD2">in</span> exI<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3545 </span>    <span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> mset_map list_all2I subset_eq zip_map_fst_snd<span class="syntax-OPERATOR">)</span>
<span class="gutter">3546 </span>    <span class="syntax-KEYWORD1">done</span>
<span class="gutter">3547 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;z &isin; set_mset {#} &#10233; False&quot;</span> <span class="syntax-KEYWORD2">for</span> z
<span class="gutter">3548 </span>    <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3549 </span>  <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;pred_mset P = (&lambda;x. Ball (set_mset x) P)&quot;</span> <span class="syntax-KEYWORD2">for</span> P
<span class="gutterH">3550 </span>  <span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>intro ext iffI<span class="syntax-OPERATOR">)</span>
<span class="gutter">3551 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter">3552 </span>    <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;pred_mset P x&quot;</span>
<span class="gutter">3553 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;Ball (set_mset x) P&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct pred<span class="syntax-OPERATOR">:</span> pred_mset<span class="syntax-OPERATOR">;</span> simp<span class="syntax-OPERATOR">)</span>
<span class="gutter">3554 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutterH">3555 </span>    <span class="syntax-KEYWORD3">fix</span> x
<span class="gutter">3556 </span>    <span class="syntax-KEYWORD3">assume</span> <span class="syntax-LITERAL1">&quot;Ball (set_mset x) P&quot;</span>
<span class="gutter">3557 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">show</span> <span class="syntax-LITERAL1">&quot;pred_mset P x&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct x<span class="syntax-OPERATOR">;</span> auto intro<span class="syntax-OPERATOR">:</span> pred_mset.intros<span class="syntax-OPERATOR">)</span>
<span class="gutter">3558 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3559 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3560 </span>
<span class="gutter">3561 </span><span class="syntax-KEYWORD1">inductive</span> rel_mset'
<span class="gutter">3562 </span><span class="syntax-KEYWORD2">where</span>
<span class="gutter">3563 </span>  Zero<span class="syntax-OPERATOR">[</span>intro<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset' R {#} {#}&quot;</span>
<span class="gutter">3564 </span><span class="syntax-OPERATOR">|</span> Plus<span class="syntax-OPERATOR">[</span>intro<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#10214;R a b; rel_mset' R M N&#10215; &#10233; rel_mset' R (add_mset a M) (add_mset b N)&quot;</span>
<span class="gutterH">3565 </span>
<span class="gutter">3566 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset_Zero<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset R {#} {#}&quot;</span>
<span class="gutter">3567 </span><span class="syntax-KEYWORD1">unfolding</span> rel_mset_def Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3568 </span>
<span class="gutter">3569 </span><span class="syntax-KEYWORD1">declare</span> multiset.count<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutterH">3570 </span><span class="syntax-KEYWORD1">declare</span> Abs_multiset_inverse<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">3571 </span><span class="syntax-KEYWORD1">declare</span> multiset.count_inverse<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">3572 </span><span class="syntax-KEYWORD1">declare</span> union_preserves_multiset<span class="syntax-OPERATOR">[</span>simp<span class="syntax-OPERATOR">]</span>
<span class="gutter">3573 </span>
<span class="gutter">3574 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset_Plus<span class="syntax-OPERATOR">:</span>
<span class="gutterH">3575 </span>  <span class="syntax-KEYWORD2">assumes</span> ab<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;R a b&quot;</span>
<span class="gutter">3576 </span>    <span class="syntax-KEYWORD2">and</span> MN<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset R M N&quot;</span>
<span class="gutter">3577 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;rel_mset R (add_mset a M) (add_mset b N)&quot;</span>
<span class="gutter">3578 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3579 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;&exist;ya. add_mset a (image_mset fst y) = image_mset fst ya &and;</span>
<span class="gutterH">3580 </span><span class="syntax-LITERAL1">    add_mset b (image_mset snd y) = image_mset snd ya &and;</span>
<span class="gutter">3581 </span><span class="syntax-LITERAL1">    set_mset ya &sube; {(x, y). R x y}&quot;</span>
<span class="gutter">3582 </span>    <span class="syntax-KEYWORD2">if</span> <span class="syntax-LITERAL1">&quot;R a b&quot;</span> <span class="syntax-KEYWORD2">and</span> <span class="syntax-LITERAL1">&quot;set_mset y &sube; {(x, y). R x y}&quot;</span> <span class="syntax-KEYWORD2">for</span> y
<span class="gutter">3583 </span>    <span class="syntax-KEYWORD1">using</span> that <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>intro exI<span class="syntax-OPERATOR">[</span>of _ <span class="syntax-LITERAL1">&quot;add_mset (a,b) y&quot;</span><span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span> auto
<span class="gutter">3584 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis
<span class="gutterH">3585 </span>  <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">3586 </span>  <span class="syntax-KEYWORD1">unfolding</span> multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3587 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3588 </span>
<span class="gutter">3589 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset'_imp_rel_mset<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset' R M N &#10233; rel_mset R M N&quot;</span>
<span class="gutterH">3590 </span>  <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct rule<span class="syntax-OPERATOR">:</span> rel_mset'.induct<span class="syntax-OPERATOR">)</span> <span class="syntax-OPERATOR">(</span>auto simp<span class="syntax-OPERATOR">:</span> rel_mset_Zero rel_mset_Plus<span class="syntax-OPERATOR">)</span>
<span class="gutter">3591 </span>
<span class="gutter">3592 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset_size<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset R M N &#10233; size M = size N&quot;</span>
<span class="gutter">3593 </span>  <span class="syntax-KEYWORD1">unfolding</span> multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3594 </span>
<span class="gutterH">3595 </span><span class="syntax-KEYWORD1">lemma</span> multiset_induct2<span class="syntax-OPERATOR">[</span>case_names empty addL addR<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">3596 </span>  <span class="syntax-KEYWORD2">assumes</span> empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;P {#} {#}&quot;</span>
<span class="gutter">3597 </span>    <span class="syntax-KEYWORD2">and</span> addL<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;a M N. P M N &#10233; P (add_mset a M) N&quot;</span>
<span class="gutter">3598 </span>    <span class="syntax-KEYWORD2">and</span> addR<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;a M N. P M N &#10233; P M (add_mset a N)&quot;</span>
<span class="gutter">3599 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;P M N&quot;</span>
<span class="gutterH">3600 </span><span class="syntax-KEYWORD1">apply</span><span class="syntax-OPERATOR">(</span>induct N rule<span class="syntax-OPERATOR">:</span> multiset_induct<span class="syntax-OPERATOR">)</span>
<span class="gutter">3601 </span>  <span class="syntax-KEYWORD1">apply</span><span class="syntax-OPERATOR">(</span>induct M rule<span class="syntax-OPERATOR">:</span> multiset_induct<span class="syntax-OPERATOR">,</span> rule empty<span class="syntax-OPERATOR">,</span> erule addL<span class="syntax-OPERATOR">)</span>
<span class="gutter">3602 </span>  <span class="syntax-KEYWORD1">apply</span><span class="syntax-OPERATOR">(</span>induct M rule<span class="syntax-OPERATOR">:</span> multiset_induct<span class="syntax-OPERATOR">,</span> erule addR<span class="syntax-OPERATOR">,</span> erule addR<span class="syntax-OPERATOR">)</span>
<span class="gutter">3603 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">3604 </span>
<span class="gutterH">3605 </span><span class="syntax-KEYWORD1">lemma</span> multiset_induct2_size<span class="syntax-OPERATOR">[</span>consumes 1<span class="syntax-OPERATOR">,</span> case_names empty add<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">:</span>
<span class="gutter">3606 </span>  <span class="syntax-KEYWORD2">assumes</span> c<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size M = size N&quot;</span>
<span class="gutter">3607 </span>    <span class="syntax-KEYWORD2">and</span> empty<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;P {#} {#}&quot;</span>
<span class="gutter">3608 </span>    <span class="syntax-KEYWORD2">and</span> add<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#8896;a b M N a b. P M N &#10233; P (add_mset a M) (add_mset b N)&quot;</span>
<span class="gutter">3609 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;P M N&quot;</span>
<span class="gutterH">3610 </span>  <span class="syntax-KEYWORD1">using</span> c
<span class="gutter">3611 </span><span class="syntax-KEYWORD1">proof</span> <span class="syntax-OPERATOR">(</span>induct M arbitrary<span class="syntax-OPERATOR">:</span> N rule<span class="syntax-OPERATOR">:</span> measure_induct_rule<span class="syntax-OPERATOR">[</span>of size<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3612 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>less M<span class="syntax-OPERATOR">)</span>
<span class="gutter">3613 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">3614 </span>  <span class="syntax-KEYWORD1">proof</span><span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;M = {#}&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutterH">3615 </span>    <span class="syntax-KEYWORD3">case</span> True <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;N = {#}&quot;</span> <span class="syntax-KEYWORD1">using</span> less.prems <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3616 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> True empty <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3617 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">3618 </span>    <span class="syntax-KEYWORD3">case</span> False <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> M1 a <span class="syntax-KEYWORD2">where</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M1&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis multi_nonempty_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">3619 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;N &ne; {#}&quot;</span> <span class="syntax-KEYWORD1">using</span> False less.prems <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3620 </span>    <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> N1 b <span class="syntax-KEYWORD2">where</span> N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = add_mset b N1&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis multi_nonempty_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">3621 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;size M1 = size N1&quot;</span> <span class="syntax-KEYWORD1">using</span> less.prems <span class="syntax-KEYWORD1">unfolding</span> M N <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3622 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> M N less.hyps add <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3623 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3624 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutterH">3625 </span>
<span class="gutter">3626 </span><span class="syntax-KEYWORD1">lemma</span> msed_map_invL<span class="syntax-OPERATOR">:</span>
<span class="gutter">3627 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;image_mset f (add_mset a M) = N&quot;</span>
<span class="gutter">3628 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;N1. N = add_mset (f a) N1 &and; image_mset f M = N1&quot;</span>
<span class="gutter">3629 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutterH">3630 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;f a &isin;# N&quot;</span>
<span class="gutter">3631 </span>    <span class="syntax-KEYWORD1">using</span> assms multiset.set_map<span class="syntax-OPERATOR">[</span>of f <span class="syntax-LITERAL1">&quot;add_mset a M&quot;</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3632 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> N1 <span class="syntax-KEYWORD2">where</span> N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = add_mset (f a) N1&quot;</span> <span class="syntax-KEYWORD1">using</span> multi_member_split <span class="syntax-KEYWORD1">by</span> metis
<span class="gutter">3633 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;image_mset f M = N1&quot;</span> <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">unfolding</span> N <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3634 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> N <span class="syntax-KEYWORD1">by</span> blast
<span class="gutterH">3635 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3636 </span>
<span class="gutter">3637 </span><span class="syntax-KEYWORD1">lemma</span> msed_map_invR<span class="syntax-OPERATOR">:</span>
<span class="gutter">3638 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;image_mset f M = add_mset b N&quot;</span>
<span class="gutter">3639 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;M1 a. M = add_mset a M1 &and; f a = b &and; image_mset f M1 = N&quot;</span>
<span class="gutterH">3640 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3641 </span>  <span class="syntax-KEYWORD3">obtain</span> a <span class="syntax-KEYWORD2">where</span> a<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;a &isin;# M&quot;</span> <span class="syntax-KEYWORD2">and</span> fa<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;f a = b&quot;</span>
<span class="gutter">3642 </span>    <span class="syntax-KEYWORD1">using</span> multiset.set_map<span class="syntax-OPERATOR">[</span>of f M<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">unfolding</span> assms
<span class="gutter">3643 </span>    <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis image_iff union_single_eq_member<span class="syntax-OPERATOR">)</span>
<span class="gutter">3644 </span>  <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> M1 <span class="syntax-KEYWORD2">where</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M1&quot;</span> <span class="syntax-KEYWORD1">using</span> multi_member_split <span class="syntax-KEYWORD1">by</span> metis
<span class="gutterH">3645 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;image_mset f M1 = N&quot;</span> <span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">unfolding</span> M fa<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3646 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> M fa <span class="syntax-KEYWORD1">by</span> blast
<span class="gutter">3647 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3648 </span>
<span class="gutter">3649 </span><span class="syntax-KEYWORD1">lemma</span> msed_rel_invL<span class="syntax-OPERATOR">:</span>
<span class="gutterH">3650 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;rel_mset R (add_mset a M) N&quot;</span>
<span class="gutter">3651 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;N1 b. N = add_mset b N1 &and; R a b &and; rel_mset R M N1&quot;</span>
<span class="gutter">3652 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3653 </span>  <span class="syntax-KEYWORD3">obtain</span> K <span class="syntax-KEYWORD2">where</span> KM<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset fst K = add_mset a M&quot;</span>
<span class="gutter">3654 </span>    <span class="syntax-KEYWORD2">and</span> KN<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset snd K = N&quot;</span> <span class="syntax-KEYWORD2">and</span> sK<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset K &sube; {(a, b). R a b}&quot;</span>
<span class="gutterH">3655 </span>    <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">3656 </span>    <span class="syntax-KEYWORD1">unfolding</span> multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3657 </span>  <span class="syntax-KEYWORD3">obtain</span> K1 ab <span class="syntax-KEYWORD2">where</span> K<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K = add_mset ab K1&quot;</span> <span class="syntax-KEYWORD2">and</span> a<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;fst ab = a&quot;</span>
<span class="gutter">3658 </span>    <span class="syntax-KEYWORD2">and</span> K1M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset fst K1 = M&quot;</span> <span class="syntax-KEYWORD1">using</span> msed_map_invR<span class="syntax-OPERATOR">[</span>OF KM<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3659 </span>  <span class="syntax-KEYWORD3">obtain</span> N1 <span class="syntax-KEYWORD2">where</span> N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = add_mset (snd ab) N1&quot;</span> <span class="syntax-KEYWORD2">and</span> K1N1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset snd K1 = N1&quot;</span>
<span class="gutterH">3660 </span>    <span class="syntax-KEYWORD1">using</span> msed_map_invL<span class="syntax-OPERATOR">[</span>OF KN<span class="syntax-OPERATOR">[</span>unfolded K<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3661 </span>  <span class="syntax-KEYWORD1">have</span> Rab<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;R a (snd ab)&quot;</span> <span class="syntax-KEYWORD1">using</span> sK a <span class="syntax-KEYWORD1">unfolding</span> K <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3662 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;rel_mset R M N1&quot;</span> <span class="syntax-KEYWORD1">using</span> sK K1M K1N1
<span class="gutter">3663 </span>    <span class="syntax-KEYWORD1">unfolding</span> K multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3664 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> N Rab <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3665 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3666 </span>
<span class="gutter">3667 </span><span class="syntax-KEYWORD1">lemma</span> msed_rel_invR<span class="syntax-OPERATOR">:</span>
<span class="gutter">3668 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;rel_mset R M (add_mset b N)&quot;</span>
<span class="gutter">3669 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;&exist;M1 a. M = add_mset a M1 &and; R a b &and; rel_mset R M1 N&quot;</span>
<span class="gutterH">3670 </span><span class="syntax-KEYWORD1">proof</span> -
<span class="gutter">3671 </span>  <span class="syntax-KEYWORD3">obtain</span> K <span class="syntax-KEYWORD2">where</span> KN<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset snd K = add_mset b N&quot;</span>
<span class="gutter">3672 </span>    <span class="syntax-KEYWORD2">and</span> KM<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset fst K = M&quot;</span> <span class="syntax-KEYWORD2">and</span> sK<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;set_mset K &sube; {(a, b). R a b}&quot;</span>
<span class="gutter">3673 </span>    <span class="syntax-KEYWORD1">using</span> assms
<span class="gutter">3674 </span>    <span class="syntax-KEYWORD1">unfolding</span> multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3675 </span>  <span class="syntax-KEYWORD3">obtain</span> K1 ab <span class="syntax-KEYWORD2">where</span> K<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;K = add_mset ab K1&quot;</span> <span class="syntax-KEYWORD2">and</span> b<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;snd ab = b&quot;</span>
<span class="gutter">3676 </span>    <span class="syntax-KEYWORD2">and</span> K1N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset snd K1 = N&quot;</span> <span class="syntax-KEYWORD1">using</span> msed_map_invR<span class="syntax-OPERATOR">[</span>OF KN<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3677 </span>  <span class="syntax-KEYWORD3">obtain</span> M1 <span class="syntax-KEYWORD2">where</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = add_mset (fst ab) M1&quot;</span> <span class="syntax-KEYWORD2">and</span> K1M1<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;image_mset fst K1 = M1&quot;</span>
<span class="gutter">3678 </span>    <span class="syntax-KEYWORD1">using</span> msed_map_invL<span class="syntax-OPERATOR">[</span>OF KM<span class="syntax-OPERATOR">[</span>unfolded K<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3679 </span>  <span class="syntax-KEYWORD1">have</span> Rab<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;R (fst ab) b&quot;</span> <span class="syntax-KEYWORD1">using</span> sK b <span class="syntax-KEYWORD1">unfolding</span> K <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3680 </span>  <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;rel_mset R M1 N&quot;</span> <span class="syntax-KEYWORD1">using</span> sK K1N K1M1
<span class="gutter">3681 </span>    <span class="syntax-KEYWORD1">unfolding</span> K multiset.rel_compp_Grp Grp_def <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3682 </span>  <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> M Rab <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3683 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3684 </span>
<span class="gutterH">3685 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset_imp_rel_mset'<span class="syntax-OPERATOR">:</span>
<span class="gutter">3686 </span>  <span class="syntax-KEYWORD2">assumes</span> <span class="syntax-LITERAL1">&quot;rel_mset R M N&quot;</span>
<span class="gutter">3687 </span>  <span class="syntax-KEYWORD2">shows</span> <span class="syntax-LITERAL1">&quot;rel_mset' R M N&quot;</span>
<span class="gutter">3688 </span><span class="syntax-KEYWORD1">using</span> assms <span class="syntax-KEYWORD1">proof</span><span class="syntax-OPERATOR">(</span>induct M arbitrary<span class="syntax-OPERATOR">:</span> N rule<span class="syntax-OPERATOR">:</span> measure_induct_rule<span class="syntax-OPERATOR">[</span>of size<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3689 </span>  <span class="syntax-KEYWORD3">case</span> <span class="syntax-OPERATOR">(</span>less M<span class="syntax-OPERATOR">)</span>
<span class="gutterH">3690 </span>  <span class="syntax-KEYWORD1">have</span> c<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;size M = size N&quot;</span> <span class="syntax-KEYWORD1">using</span> rel_mset_size<span class="syntax-OPERATOR">[</span>OF less.prems<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">.</span>
<span class="gutter">3691 </span>  <span class="syntax-KEYWORD3">show</span> ?case
<span class="gutter">3692 </span>  <span class="syntax-KEYWORD1">proof</span><span class="syntax-OPERATOR">(</span>cases <span class="syntax-LITERAL1">&quot;M = {#}&quot;</span><span class="syntax-OPERATOR">)</span>
<span class="gutter">3693 </span>    <span class="syntax-KEYWORD3">case</span> True <span class="syntax-KEYWORD1">hence</span> <span class="syntax-LITERAL1">&quot;N = {#}&quot;</span> <span class="syntax-KEYWORD1">using</span> c <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3694 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> True rel_mset'.Zero <span class="syntax-KEYWORD1">by</span> auto
<span class="gutterH">3695 </span>  <span class="syntax-KEYWORD1">next</span>
<span class="gutter">3696 </span>    <span class="syntax-KEYWORD3">case</span> False <span class="syntax-KEYWORD1">then</span> <span class="syntax-KEYWORD3">obtain</span> M1 a <span class="syntax-KEYWORD2">where</span> M<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;M = add_mset a M1&quot;</span> <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>metis multi_nonempty_split<span class="syntax-OPERATOR">)</span>
<span class="gutter">3697 </span>    <span class="syntax-KEYWORD3">obtain</span> N1 b <span class="syntax-KEYWORD2">where</span> N<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;N = add_mset b N1&quot;</span> <span class="syntax-KEYWORD2">and</span> R<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;R a b&quot;</span> <span class="syntax-KEYWORD2">and</span> ms<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset R M1 N1&quot;</span>
<span class="gutter">3698 </span>      <span class="syntax-KEYWORD1">using</span> msed_rel_invL<span class="syntax-OPERATOR">[</span>OF less.prems<span class="syntax-OPERATOR">[</span>unfolded M<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3699 </span>    <span class="syntax-KEYWORD1">have</span> <span class="syntax-LITERAL1">&quot;rel_mset' R M1 N1&quot;</span> <span class="syntax-KEYWORD1">using</span> less.hyps<span class="syntax-OPERATOR">[</span>of M1 N1<span class="syntax-OPERATOR">]</span> ms <span class="syntax-KEYWORD1">unfolding</span> M <span class="syntax-KEYWORD1">by</span> simp
<span class="gutterH">3700 </span>    <span class="syntax-KEYWORD3">thus</span> ?thesis <span class="syntax-KEYWORD1">using</span> rel_mset'.Plus<span class="syntax-OPERATOR">[</span>of R a b<span class="syntax-OPERATOR">,</span> OF R<span class="syntax-OPERATOR">]</span> <span class="syntax-KEYWORD1">unfolding</span> M N <span class="syntax-KEYWORD1">by</span> simp
<span class="gutter">3701 </span>  <span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3702 </span><span class="syntax-KEYWORD1">qed</span>
<span class="gutter">3703 </span>
<span class="gutter">3704 </span><span class="syntax-KEYWORD1">lemma</span> rel_mset_rel_mset'<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;rel_mset R M N = rel_mset' R M N&quot;</span>
<span class="gutterH">3705 </span>  <span class="syntax-KEYWORD1">using</span> rel_mset_imp_rel_mset' rel_mset'_imp_rel_mset <span class="syntax-KEYWORD1">by</span> auto
<span class="gutter">3706 </span>
<span class="gutter">3707 </span><span class="syntax-KEYWORD1">text</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">T</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">f</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">@</span><span class="syntax-COMMENT4">{</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">l</span><span class="syntax-COMMENT4">_</span><span class="syntax-COMMENT4">m</span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">}</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">d</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">v</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">h</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">c</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">r</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">a</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">o</span><span class="syntax-COMMENT4">n</span><span class="syntax-COMMENT4">:</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3708 </span><span class="syntax-KEYWORD1">lemmas</span> rel_mset_induct<span class="syntax-OPERATOR">[</span>case_names empty add<span class="syntax-OPERATOR">,</span> induct pred<span class="syntax-OPERATOR">:</span> rel_mset<span class="syntax-OPERATOR">]</span> <span class="syntax-OPERATOR">=</span>
<span class="gutter">3709 </span>  rel_mset'.induct<span class="syntax-OPERATOR">[</span>unfolded rel_mset_rel_mset'<span class="syntax-OPERATOR">[</span>symmetric<span class="syntax-OPERATOR">]</span><span class="syntax-OPERATOR">]</span>
<span class="gutterH">3710 </span>
<span class="gutter">3711 </span>
<span class="gutter">3712 </span><span class="syntax-KEYWORD1">subsection</span> <span class="syntax-COMMENT4">&lsaquo;</span><span class="syntax-COMMENT4">S</span><span class="syntax-COMMENT4">i</span><span class="syntax-COMMENT4">z</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4"> </span><span class="syntax-COMMENT4">s</span><span class="syntax-COMMENT4">e</span><span class="syntax-COMMENT4">t</span><span class="syntax-COMMENT4">u</span><span class="syntax-COMMENT4">p</span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3713 </span>
<span class="gutter">3714 </span><span class="syntax-KEYWORD1">lemma</span> multiset_size_o_map<span class="syntax-OPERATOR">:</span>
<span class="gutterH">3715 </span>  <span class="syntax-LITERAL1">&quot;size_multiset g &#8728; image_mset f = size_multiset (g &#8728; f)&quot;</span>
<span class="gutter">3716 </span><span class="syntax-KEYWORD1">apply</span> <span class="syntax-OPERATOR">(</span>rule ext<span class="syntax-OPERATOR">)</span>
<span class="gutter">3717 </span><span class="syntax-KEYWORD1">subgoal</span> <span class="syntax-KEYWORD2">for</span> x <span class="syntax-KEYWORD1">by</span> <span class="syntax-OPERATOR">(</span>induct x<span class="syntax-OPERATOR">)</span> auto
<span class="gutter">3718 </span><span class="syntax-KEYWORD1">done</span>
<span class="gutter">3719 </span>
<span class="gutterH">3720 </span><span class="syntax-KEYWORD1">setup</span> <span class="syntax-COMMENT4">&lsaquo;</span>
<span class="gutter">3721 </span><span class="syntax-COMMENT4">  BNF_LFP_Size.register_size_global @{type_name multiset} @{const_name size_multiset}</span>
<span class="gutter">3722 </span><span class="syntax-COMMENT4">    @{thm size_multiset_overloaded_def}</span>
<span class="gutter">3723 </span><span class="syntax-COMMENT4">    @{thms size_multiset_empty size_multiset_single size_multiset_union size_empty size_single</span>
<span class="gutter">3724 </span><span class="syntax-COMMENT4">      size_union}</span>
<span class="gutterH">3725 </span><span class="syntax-COMMENT4">    @{thms multiset_size_o_map}</span>
<span class="gutter">3726 </span><span class="syntax-COMMENT4">&rsaquo;</span>
<span class="gutter">3727 </span>
<span class="gutter">3728 </span><span class="syntax-KEYWORD1">hide_const</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">open</span><span class="syntax-OPERATOR">)</span> wcount
<span class="gutter">3729 </span>
<span class="gutterH">3730 </span><span class="syntax-KEYWORD2">end</span>
<span class="gutter">3731 </span>
</span></pre>
</body>
</html>
